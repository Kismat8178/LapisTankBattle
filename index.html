<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tank Battle by Lapis Yamz - V2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #2c2c2c; 
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none; 
        }
        #gameArea { 
            position: relative; 
            box-shadow: 0 0 15px rgba(0,0,0,0.7);
            display: none; 
        }
        #gameContainer {
            position: relative; 
            background-color: #e0e0e0; 
        }
        canvas {
            display: block;
            image-rendering: -webkit-optimize-contrast; 
            image-rendering: crisp-edges;
        }
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            pointer-events: none;
        }
        .health-bar-container {
            position: absolute;
            width: 50px; 
            height: 8px;
            background-color: rgba(85, 85, 85, 0.7);
            border: 1px solid #222;
            border-radius: 2px;
        }
        .health-bar {
            height: 100%;
            background-color: limegreen;
            border-radius: 1px;
            transition: width 0.2s ease-out;
        }
        .shield-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: deepskyblue;
            border-radius: 50%;
            border: 1px solid #fff;
            top: -12px; 
            left: 50%;
            transform: translateX(-50%);
        }

        .joystick-container-base {
            position: fixed;
            width: 120px; 
            height: 120px;
            background-color: rgba(100, 100, 100, 0.25);
            border-radius: 50%;
            display: none; 
            z-index: 100;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        .joystick-handle-base {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(150, 150, 150, 0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        /* P1 Joystick: Default bottom-left for VS CPU, top-left for 2P */
        #joystickContainerP1 { bottom: 20px; left: 20px; } 
        /* P2 Joystick: Default bottom-right (used in 2P mode) */
        #joystickContainerP2 { bottom: 20px; right: 20px; } 

        .fire-button-container-base {
            position: fixed;
            display: none; 
            z-index: 100;
        }
        .fire-button-base {
            width: 70px; 
            height: 70px;
            background-color: rgba(255, 0, 0, 0.4);
            color: white;
            border: 2px solid rgba(200,0,0,0.7);
            border-radius: 50%;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            box-shadow: 0 0 10px rgba(255,0,0,0.3);
        }
        /* P1 Fire: Default bottom-right for VS CPU, top-right for 2P */
        #fireButtonContainerP1 { bottom: 30px; right: 20px; }
        /* P2 Fire: Default bottom-left (used in 2P mode) */
        #fireButtonContainerP2 { bottom: 30px; left: 20px; }


        #menuScreen {
            display: flex; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85);
            z-index: 200;
            padding: 20px; box-sizing: border-box;
        }
        #menuScreen h1 { font-size: clamp(2em, 8vw, 3.5em); margin-bottom: 10px; color: gold; text-shadow: 2px 2px #000;}
        #menuScreen p { margin-bottom: 20px; font-size: clamp(0.9em, 3vw, 1.2em); }
        .menuButton {
            padding: clamp(10px, 3vw, 15px) clamp(20px, 5vw, 30px);
            font-size: clamp(1em, 4vw, 1.5em);
            margin: 10px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            box-shadow: 0 4px #3a8a3e;
        }
        .menuButton:hover { background-color: #45a049; }
        .menuButton:active { background-color: #3e8e41; box-shadow: 0 2px #2c6f2f; transform: translateY(2px); }

        #messageScreen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.9);
            z-index: 300;
            text-align: center;
            padding: 20px; box-sizing: border-box;
        }
        #messageText { font-size: clamp(1.8em, 6vw, 2.8em); color: white; margin-bottom: 20px; }
        .game-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(1em, 3vw, 1.5em);
            color: #eee;
            opacity: 0.6;
            text-shadow: 1px 1px #000;
            pointer-events: none;
        }
        #otherGameLinkContainer {
            position: fixed;
            bottom: 5px;
            width: 100%;
            text-align: center;
            font-size: clamp(0.7em, 2vw, 0.9em);
            z-index: 500; 
            color: #ccc;
            padding: 5px 0;
            background-color: rgba(0,0,0,0.3); 
        }
        #otherGameLinkContainer a {
            color: #87CEFA; 
            text-decoration: none;
        }
        #otherGameLinkContainer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="menuScreen">
        <h1>Tank Battle</h1>
        <p>By Lapis Yamz</p>
        <button class="menuButton" id="vsCPUButton">VS Computer</button>
        <button class="menuButton" id="twoPlayerButton">2 Player Local</button>
        <button class="menuButton" id="fullscreenButton">Enter Fullscreen</button>
        <div style="margin-top: 20px; font-size: clamp(0.7em, 2.5vw, 0.9em); text-align: center; max-width: 90%;">
            <p>P1: WASD (move), QE (turret), Space (shoot)</p>
            <p>P2: Arrows (move), Comma/Period (turret), Enter (shoot)</p>
            <p>Mobile (VS CPU): P1 Joystick Bottom-Left, Fire Bottom-Right</p>
            <p>Mobile (2 Player): P1 Joystick Top-Left, Fire Top-Right</p>
            <p style="margin-top:5px;">                           P2 Joystick Bottom-Right, Fire Bottom-Left</p>
        </div>
    </div>

    <div id="gameArea">
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div id="uiLayer"></div>
        </div>
        <div class="game-title">Tank Battle by Lapis Yamz</div>
    </div>

    <div id="joystickContainerP1" class="joystick-container-base">
        <div id="joystickHandleP1" class="joystick-handle-base"></div>
    </div>
    <div id="fireButtonContainerP1" class="fire-button-container-base">
        <button id="fireButtonP1" class="fire-button-base">FIRE</button>
    </div>

    <div id="joystickContainerP2" class="joystick-container-base">
        <div id="joystickHandleP2" class="joystick-handle-base"></div>
    </div>
    <div id="fireButtonContainerP2" class="fire-button-container-base">
        <button id="fireButtonP2" class="fire-button-base">FIRE</button>
    </div>
    
    <div id="messageScreen">
        <div id="messageText">Game Over!</div>
        <button class="menuButton" id="playAgainButton">Play Again</button>
        <button class="menuButton" id="backToMenuButton">Back to Menu</button>
    </div>

    <div id="otherGameLinkContainer">
        Please try our other game: <a href="https://kismat8178.github.io/LapisYamCricket/" target="_blank">LapisYamCricket</a>
    </div>

    <script>
        const gameArea = document.getElementById('gameArea');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('uiLayer');
        const gameContainer = document.getElementById('gameContainer'); 

        const joystickContainerP1 = document.getElementById('joystickContainerP1');
        const joystickHandleP1 = document.getElementById('joystickHandleP1');
        const fireButtonContainerP1 = document.getElementById('fireButtonContainerP1');
        const fireButtonP1 = document.getElementById('fireButtonP1');
        const joystickContainerP2 = document.getElementById('joystickContainerP2');
        const joystickHandleP2 = document.getElementById('joystickHandleP2');
        const fireButtonContainerP2 = document.getElementById('fireButtonContainerP2');
        const fireButtonP2 = document.getElementById('fireButtonP2');
        
        const menuScreen = document.getElementById('menuScreen');
        const vsCPUButton = document.getElementById('vsCPUButton');
        const twoPlayerButton = document.getElementById('twoPlayerButton');
        const fullscreenButton = document.getElementById('fullscreenButton');
        
        const messageScreen = document.getElementById('messageScreen');
        const messageText = document.getElementById('messageText');
        const playAgainButton = document.getElementById('playAgainButton');
        const backToMenuButton = document.getElementById('backToMenuButton');

        let gameMode = null; 
        let gameRunning = false;
        let animationFrameId;

        const MAP_WIDTH = 1200; 
        const MAP_HEIGHT = 800;
        const TANK_SIZE = 40;
        const TURRET_LENGTH = TANK_SIZE * 0.8;
        const TURRET_WIDTH = TANK_SIZE * 0.3;
        const BULLET_SPEED = 8;
        const BULLET_SIZE = 6;
        const BASE_TANK_SPEED = 2;
        const TANK_TURN_SPEED = 0.05; 
        const TURRET_TURN_SPEED = 0.07; 
        const MAX_HEALTH = 100;
        const SHOOT_COOLDOWN = 600; 
        const POWERUP_SIZE = 25;
        const POWERUP_DURATION = 10000; 
        const POWERUP_SPAWN_INTERVAL = 12000;

        canvas.width = MAP_WIDTH;
        canvas.height = MAP_HEIGHT;
        gameContainer.style.width = MAP_WIDTH + 'px';
        gameContainer.style.height = MAP_HEIGHT + 'px';
        gameArea.style.width = MAP_WIDTH + 'px'; 
        gameArea.style.height = MAP_HEIGHT + 'px';


        let player1, player2;
        const bullets = [];
        const obstacles = [];
        const powerUps = [];
        let lastPowerUpSpawnTime = 0;

        const keys = {};
        let G_SCALE = 1;

        class Tank {
            constructor(x, y, color, id, isAI = false) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.width = TANK_SIZE;
                this.height = TANK_SIZE;
                this.color = color;
                this.angle = Math.random() * Math.PI * 2; 
                this.turretAngle = this.angle;
                this.speed = BASE_TANK_SPEED;
                this.turnSpeed = TANK_TURN_SPEED;
                this.turretTurnSpeed = TURRET_TURN_SPEED;
                this.health = MAX_HEALTH;
                this.maxHealth = MAX_HEALTH;
                this.lastShotTime = 0;
                this.isAI = isAI;
                this.shielded = false;
                this.shieldTimer = 0;
                this.speedBoostActive = false; 
                this.speedBoostTimer = 0;

                if (this.isAI) {
                    this.aiState = 'IDLE'; 
                    this.aiTarget = null;
                    this.aiMoveCooldown = 0;
                    this.aiLastPosition = { x: this.x, y: this.y };
                    this.aiStuckTimer = 0;
                    this.AI_STUCK_THRESHOLD = 1300; 
                    this.AI_MIN_MOVE_DIST_SQR = 1*1; 
                    this.aiAimInaccuracyFactor = 0.45; 
                    this.aiShootingAngleTolerance = 0.5; 
                    this.aiCurrentAimOffset = 0;    
                    this.aiNextAimAdjustTimer = 0;  
                    this.aiHesitationFactor = 0.25; 
                    this.aiPostActionReactionTime = 300; 
                    this.aiGeneralReactionTimer = 0; 
                    this.aiTargetLostTimer = 0; 
                    this.AI_TARGET_LOST_PATROL_THRESHOLD = 4000; 
                }

                this.healthBarContainer = document.createElement('div');
                this.healthBarContainer.className = 'health-bar-container';
                this.healthBarDiv = document.createElement('div');
                this.healthBarDiv.className = 'health-bar';
                this.healthBarContainer.appendChild(this.healthBarDiv);
                this.shieldIndicatorDiv = document.createElement('div');
                this.shieldIndicatorDiv.className = 'shield-indicator';
                this.shieldIndicatorDiv.style.display = 'none';
                this.healthBarContainer.appendChild(this.shieldIndicatorDiv);
                uiLayer.appendChild(this.healthBarContainer);
                this.updateHealthBar();
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(-this.width/2 - 2, -this.height/2 - 5, this.width + 4, 5); 
                ctx.fillRect(-this.width/2 - 2, this.height/2, this.width + 4, 5);     
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.restore();

                ctx.save();
                ctx.translate(this.x, this.y);
                const baseColor = this.color.startsWith('#') ? this.color : '#CCCCCC'; 
                const r = parseInt(baseColor.slice(1,3),16), g = parseInt(baseColor.slice(3,5),16), b = parseInt(baseColor.slice(5,7),16);
                ctx.fillStyle = `rgba(${r*0.8}, ${g*0.8}, ${b*0.8}, 1)`;
                ctx.beginPath();
                ctx.arc(0, 0, this.width / 3.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.turretAngle);
                ctx.fillStyle = `rgba(${r*0.7}, ${g*0.7}, ${b*0.7}, 1)`;
                ctx.fillRect(0, -TURRET_WIDTH / 2, TURRET_LENGTH, TURRET_WIDTH);
                ctx.fillStyle = `rgba(${r*0.6}, ${g*0.6}, ${b*0.6}, 1)`;
                ctx.beginPath();
                ctx.arc(TURRET_LENGTH, 0, TURRET_WIDTH/2.5, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();

                if (this.shielded) {
                    ctx.save();
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now()/200)*0.2; 
                    ctx.translate(this.x, this.y);
                    ctx.strokeStyle = 'deepskyblue';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width / 2 + 6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                this.updateHealthBarPosition();
            }

            updateHealthBarPosition() {
                this.healthBarContainer.style.left = (this.x - this.width / 2) + 'px';
                this.healthBarContainer.style.top = (this.y - this.height / 2 - 15) + 'px';
            }

            updateHealthBar() {
                const healthPercentage = (this.health / this.maxHealth) * 100;
                this.healthBarDiv.style.width = healthPercentage + '%';
                if (healthPercentage <= 0) this.healthBarDiv.style.backgroundColor = 'black';
                else if (healthPercentage < 30) this.healthBarDiv.style.backgroundColor = 'red';
                else if (healthPercentage < 60) this.healthBarDiv.style.backgroundColor = 'orange';
                else this.healthBarDiv.style.backgroundColor = 'limegreen';
                this.shieldIndicatorDiv.style.display = this.shielded ? 'block' : 'none';
            }
            
            move(direction) { 
                const currentSpeed = this.speed * (this.speedBoostActive ? 1.7 : 1);
                const prevX = this.x;
                const prevY = this.y;
                const newXUnchecked = this.x + direction * currentSpeed * Math.cos(this.angle);
                const newYUnchecked = this.y + direction * currentSpeed * Math.sin(this.angle);
                const hitBoxWidth = this.width * 0.9;
                const hitBoxHeight = this.height * 0.9;

                this.x = newXUnchecked;
                if (this.checkCollision(this.x, prevY, hitBoxWidth, hitBoxHeight) || this.checkBoundaryCollisionX()) {
                    this.x = prevX; 
                }
                this.y = newYUnchecked;
                 if (this.checkCollision(this.x, this.y, hitBoxWidth, hitBoxHeight) || this.checkBoundaryCollisionY()) { 
                    this.y = prevY; 
                }
                if(this.x !== prevX && this.y !== prevY && this.checkCollision(this.x, this.y, hitBoxWidth, hitBoxHeight)){
                    this.x = prevX;
                    this.y = prevY;
                }
            }
            checkBoundaryCollisionX() {
                 return (this.x - this.width / 2 < 0 || this.x + this.width / 2 > MAP_WIDTH);
            }
            checkBoundaryCollisionY() {
                 return (this.y - this.height / 2 < 0 || this.y + this.height / 2 > MAP_HEIGHT);
            }
            rotateBody(direction) { 
                this.angle += direction * this.turnSpeed;
            }
            rotateTurret(direction) { 
                this.turretAngle += direction * this.turretTurnSpeed;
            }
            setTurretAngle(targetAngle) {
                let current = (this.turretAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                let target = (targetAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                let diff = target - current;
                if (diff > Math.PI) diff -= 2 * Math.PI;
                if (diff < -Math.PI) diff += 2 * Math.PI;

                if (Math.abs(diff) < this.turretTurnSpeed * 1.1) { 
                    this.turretAngle = targetAngle;
                } else {
                    this.turretAngle += Math.sign(diff) * this.turretTurnSpeed;
                }
            }
            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime > SHOOT_COOLDOWN) {
                    const bulletX = this.x + TURRET_LENGTH * Math.cos(this.turretAngle);
                    const bulletY = this.y + TURRET_LENGTH * Math.sin(this.turretAngle);
                    bullets.push(new Bullet(bulletX, bulletY, this.turretAngle, this));
                    this.lastShotTime = currentTime;
                    return true; 
                }
                return false; 
            }
            takeDamage(amount) {
                if (this.shielded) return; 
                this.health -= amount;
                this.updateHealthBar();
                if (this.health <= 0) {
                    this.health = 0;
                    this.destroy();
                }
            }
            destroy() {
                this.updateHealthBar(); 
                if (this === player1) {
                    endGame(gameMode === 'vsCPU' ? "Computer Wins!" : "Player 2 Wins!");
                } else if (this === player2) { 
                    endGame("Player 1 Wins!");
                }
            }
            checkCollision(checkX, checkY, colWidth = this.width, colHeight = this.height) {
                const tankRect = {
                    x: checkX - colWidth / 2,
                    y: checkY - colHeight / 2,
                    width: colWidth,
                    height: colHeight
                };
                for (const obs of obstacles) {
                    if (rectIntersect(tankRect, obs)) return true;
                }
                const otherTank = (this === player1 && player2) ? player2 : (this === player2 && player1) ? player1 : null;
                if(otherTank && otherTank.health > 0) {
                    const otherTankRect = {
                        x: otherTank.x - otherTank.width / 2,
                        y: otherTank.y - otherTank.height / 2,
                        width: otherTank.width,
                        height: otherTank.height
                    };
                    if (rectIntersect(tankRect, otherTankRect)) return true; 
                }
                return false;
            }
            applyPowerUp(type) {
                if (type === 'shield') {
                    this.shielded = true;
                    this.shieldTimer = POWERUP_DURATION;
                    this.shieldIndicatorDiv.style.display = 'block';
                } else if (type === 'speed') {
                    this.speedBoostActive = true;
                    this.speedBoostTimer = POWERUP_DURATION;
                } else if (type === 'health') {
                    this.health = Math.min(this.maxHealth, this.health + 40); 
                    this.updateHealthBar();
                }
            }
            updatePowerUps(deltaTime) {
                if (this.shielded) {
                    this.shieldTimer -= deltaTime;
                    if (this.shieldTimer <= 0) {
                        this.shielded = false; this.shieldTimer = 0; this.shieldIndicatorDiv.style.display = 'none';
                    }
                }
                if (this.speedBoostActive) {
                    this.speedBoostTimer -= deltaTime;
                    if (this.speedBoostTimer <= 0) {
                        this.speedBoostActive = false; this.speedBoostTimer = 0;
                    }
                }
            }
            
            aiAttemptShoot(targetAngle, targetIsShielded) { 
                if (this.aiGeneralReactionTimer > 0) return;
                if (targetIsShielded && Math.random() < 0.75) return; 
            
                let turretNormalized = (this.turretAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                let targetNormalized = (targetAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI); 
                let diff = targetNormalized - turretNormalized;
                if (diff > Math.PI) diff -= 2 * Math.PI;
                if (diff < -Math.PI) diff += 2 * Math.PI;
            
                if (Math.abs(diff) < this.aiShootingAngleTolerance) {
                    if (Math.random() > this.aiHesitationFactor) this.shoot(); 
                    this.aiGeneralReactionTimer = this.aiPostActionReactionTime + Math.random() * 200; 
                }
            }

            updateAI(deltaTime, targetTank) {
                if (!this.isAI || !targetTank || targetTank.health <= 0 || this.health <= 0) return;
                this.aiTarget = targetTank;
                this.aiMoveCooldown -= deltaTime;
                this.updatePowerUps(deltaTime);

                if (this.aiGeneralReactionTimer > 0) this.aiGeneralReactionTimer -= deltaTime;
                this.aiNextAimAdjustTimer -= deltaTime;

                if (this.aiNextAimAdjustTimer <= 0) {
                    this.aiCurrentAimOffset = (Math.random() - 0.5) * 2 * this.aiAimInaccuracyFactor; 
                    this.aiNextAimAdjustTimer = 600 + Math.random() * 700; 
                }
                
                const trueAngleToTarget = Math.atan2(targetTank.y - this.y, targetTank.x - this.x);
                const effectiveAimAngle = trueAngleToTarget + this.aiCurrentAimOffset;

                const distMovedSqr = (this.x - this.aiLastPosition.x)**2 + (this.y - this.aiLastPosition.y)**2;
                if (this.aiState !== 'IDLE' && this.aiState !== 'ATTACKING_HOLD' && this.aiState !== 'PATROLLING') { 
                    if (distMovedSqr < this.AI_MIN_MOVE_DIST_SQR * (deltaTime/16)) { 
                        this.aiStuckTimer += deltaTime;
                    } else {
                        this.aiStuckTimer = 0; this.aiLastPosition = { x: this.x, y: this.y };
                    }
                } else {
                     this.aiStuckTimer = 0; this.aiLastPosition = { x: this.x, y: this.y };
                }

                if (this.aiStuckTimer > this.AI_STUCK_THRESHOLD) {
                    this.angle += Math.PI / 1.5 + (Math.random() - 0.5) * (Math.PI / 2); 
                    this.move(Math.random() < 0.6 ? -0.7 : 0.5); 
                    this.aiState = 'IDLE'; this.aiStuckTimer = 0; 
                    this.aiMoveCooldown = 500 + Math.random() * 400;
                    return; 
                }

                const distanceToTarget = Math.hypot(this.x - targetTank.x, this.y - targetTank.y);
                const canSee = this.canSeeTarget(targetTank);
                
                let closestPowerUp = null; // Moved declaration earlier for broader scope
                let minDistToPowerUp = Infinity; // Moved declaration earlier

                if (canSee) this.aiTargetLostTimer = 0;
                else this.aiTargetLostTimer += deltaTime;

                // Power-up seeking logic moved here to be prioritized
                if (this.health < this.maxHealth * 0.7 || (!this.shielded && Math.random() < 0.3)) {
                    powerUps.forEach(p => {
                        if (p.active) {
                            const dist = Math.hypot(this.x - p.x, this.y - p.y);
                            if (dist < minDistToPowerUp) {
                                minDistToPowerUp = dist; closestPowerUp = p;
                            }
                        }
                    });
                }


                if (this.aiTargetLostTimer > this.AI_TARGET_LOST_PATROL_THRESHOLD) {
                    this.aiState = 'PATROLLING';
                } else if (closestPowerUp && minDistToPowerUp < MAP_WIDTH / 3.5 && (this.health < this.maxHealth * 0.6 || (closestPowerUp.type === 'shield' && !this.shielded && Math.random() < 0.6))) { 
                     this.aiState = 'SEEKING_POWERUP';
                } else if (canSee && distanceToTarget < TANK_SIZE * 6) { 
                     this.aiState = 'ATTACKING_CLOSE'; 
                } else if (canSee && distanceToTarget < MAP_WIDTH / 2) { 
                    this.aiState = 'ATTACKING_RANGED';
                } else if (distanceToTarget > MAP_WIDTH / 1.3) { 
                    this.aiState = 'SEEKING_PLAYER';
                } else if (!canSee && this.aiMoveCooldown <=0) { 
                    this.aiState = 'REPOSITIONING';
                } else if (this.aiMoveCooldown <=0 && this.aiState !== 'PATROLLING') { 
                    this.aiState = 'IDLE';
                }


                switch(this.aiState) {
                    case 'PATROLLING':
                        this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.2); 
                        if (this.aiMoveCooldown <= 0) {
                            this.angle += (Math.random() - 0.7) * Math.PI / 2.5; 
                            this.move(0.6 + Math.random()*0.3); 
                            this.aiMoveCooldown = Math.random() * 1800 + 1000; 
                        }
                        if (canSee) { 
                            this.aiTargetLostTimer = 0; 
                            this.aiState = 'ATTACKING_RANGED'; 
                        }
                        break;
                    case 'SEEKING_POWERUP':
                        const angleToPowerUp = Math.atan2(closestPowerUp.y - this.y, closestPowerUp.x - this.x);
                        this.setTurretAngle(canSee ? effectiveAimAngle : angleToPowerUp); 
                        if (!this.isPathClearToPoint(closestPowerUp.x, closestPowerUp.y)) {
                            this.aiSmartTurn(angleToPowerUp); this.move(0.5); 
                        } else {
                             this.angle = angleToPowerUp; this.move(1);
                        }
                        if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                        break;
                    case 'ATTACKING_CLOSE':
                        this.setTurretAngle(effectiveAimAngle);
                        this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                        if (this.aiMoveCooldown <= 0) {
                            let strafeAngle = trueAngleToTarget + (Math.random() < 0.5 ? Math.PI/2.2 : -Math.PI/2.2); 
                            if(this.isPathClear(strafeAngle, TANK_SIZE*1.5)){
                                this.angle = strafeAngle; this.move(0.6 + Math.random()*0.2);
                            } else { 
                                this.angle = trueAngleToTarget + Math.PI; this.move(0.4 + Math.random()*0.2);
                            }
                            this.aiMoveCooldown = Math.random() * 700 + 300;
                        }
                        break;
                    case 'ATTACKING_RANGED':
                        this.setTurretAngle(effectiveAimAngle);
                        this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                        if (this.aiMoveCooldown <= 0) {
                            if (Math.random() < 0.3) { 
                                this.angle = trueAngleToTarget + (Math.random()-0.5) * Math.PI / 3; this.move(0.2 + Math.random()*0.2);
                            }
                            this.aiMoveCooldown = Math.random() * 900 + 500;
                        }
                        break;
                    case 'SEEKING_PLAYER':
                        this.setTurretAngle(effectiveAimAngle);
                         if (!this.isPathClearToPoint(targetTank.x, targetTank.y, TANK_SIZE*3)) { 
                            this.aiSmartTurn(trueAngleToTarget); this.move(0.5 + Math.random()*0.2);
                        } else {
                            this.angle = trueAngleToTarget; this.move(0.8 + Math.random()*0.2);
                        }
                        if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                        break;
                    case 'REPOSITIONING':
                        this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.35 ); 
                        this.angle += (Math.random() - 0.5) * Math.PI / 2.5;
                        this.move(0.6 + Math.random()*0.2);
                        this.aiMoveCooldown = Math.random() * 600 + 250;
                        break;
                    default: // IDLE
                        if (this.aiMoveCooldown <= 0) {
                            this.angle += (Math.random() - 0.5) * Math.PI / 1.8; 
                            if(Math.random() < 0.4) this.move(0.4 + Math.random()*0.2); 
                            this.aiMoveCooldown = Math.random() * 1300 + 700; 
                        }
                        this.setTurretAngle(this.turretAngle + (Math.random()-0.5)*0.15); 
                        break;
                }
            }
            aiSmartTurn(desiredAngle) { 
                let bestTurn = 0;
                let maxClearDistance = 0;
                const anglesToTest = [0, -Math.PI / 6, Math.PI / 6, -Math.PI/3, Math.PI/3]; 
                for (const offset of anglesToTest) {
                    const testAngle = desiredAngle + offset;
                    let clearDist = 0;
                    for (let d = TANK_SIZE/2; d < TANK_SIZE * 2.5; d += TANK_SIZE/2) { 
                        if (this.isPathClear(testAngle, d)) {
                            clearDist = d;
                        } else break;
                    }
                    if (clearDist > maxClearDistance) {
                        maxClearDistance = clearDist;
                        bestTurn = testAngle;
                    }
                }
                if (maxClearDistance > TANK_SIZE*0.4) this.angle = bestTurn; 
                else this.angle = desiredAngle + (Math.random() < 0.5 ? Math.PI/1.8 : -Math.PI/1.8) + (Math.random()-0.5)*0.6; 
            }
            isPathClear(angle, distance) {
                const numChecks = 3; 
                const perpendicularOffset = this.width / 3; 
                const cosA = Math.cos(angle);
                const sinA = Math.sin(angle);
                const cosPerp = Math.cos(angle + Math.PI/2);
                const sinPerp = Math.sin(angle + Math.PI/2);

                for (let i = 0; i < numChecks; i++) {
                    let offsetX = 0, offsetY = 0;
                    if (i === 1) { 
                        offsetX = perpendicularOffset * cosPerp; offsetY = perpendicularOffset * sinPerp;
                    } else if (i === 2) { 
                        offsetX = -perpendicularOffset * cosPerp; offsetY = -perpendicularOffset * sinPerp;
                    }
                    const lookAheadX = this.x + offsetX + distance * cosA;
                    const lookAheadY = this.y + offsetY + distance * sinA;
                    if (lookAheadX < 0 || lookAheadX > MAP_WIDTH || lookAheadY < 0 || lookAheadY > MAP_HEIGHT) return false;
                    for (const obs of obstacles) {
                        if (pointInRect({x: lookAheadX, y: lookAheadY}, obs)) return false;
                    }
                }
                return true;
            }
            isPathClearToPoint(targetX, targetY, maxDist = MAP_WIDTH) { 
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distToTarget = Math.hypot(dx, dy);
                if (distToTarget > maxDist) return false; 
                const angleToTarget = Math.atan2(dy, dx);
                return this.isPathClear(angleToTarget, distToTarget - TANK_SIZE/2); 
            }
            canSeeTarget(target) {
                if (!target) return false;
                return this.isPathClearToPoint(target.x, target.y);
            }
        }
        class Bullet { 
            constructor(x, y, angle, owner) {
                this.x = x; this.y = y; this.angle = angle;
                this.speed = BULLET_SPEED; this.size = BULLET_SIZE; this.owner = owner; 
            }
            draw() {
                ctx.fillStyle = '#222'; 
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2); ctx.fill();
            }
            update() {
                this.x += this.speed * Math.cos(this.angle); this.y += this.speed * Math.sin(this.angle);
            }
        }
        class Obstacle { 
            constructor(x, y, width, height, color = '#7a5230') { 
                this.x = x; this.y = y; this.width = width; this.height = height;
                this.color = color; this.darkerColor = shadeColor(color, -20); 
            }
            draw() {
                ctx.fillStyle = this.darkerColor; 
                ctx.fillRect(this.x + 3, this.y + 3, this.width, this.height);
                ctx.fillStyle = this.color; 
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }
        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1,3),16); let G = parseInt(color.substring(3,5),16); let B = parseInt(color.substring(5,7),16);
            R = parseInt(R * (100 + percent) / 100); G = parseInt(G * (100 + percent) / 100); B = parseInt(B * (100 + percent) / 100);
            R = (R<255)?R:255; G = (G<255)?G:255; B = (B<255)?B:255; R = (R>0)?R:0; G = (G>0)?G:0; B = (B>0)?B:0;
            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
            return "#"+RR+GG+BB;
        }
        class PowerUp { 
            constructor(x, y, type) {
                this.x = x; this.y = y; this.radius = POWERUP_SIZE / 2;
                this.type = type; this.active = true; this.spawnTime = Date.now(); this.lifeTime = 18000; 
            }
            draw() {
                if (!this.active) return;
                ctx.save(); ctx.translate(this.x, this.y);
                const pulseFactor = 0.8 + Math.abs(Math.sin(Date.now() / 300)) * 0.4; 
                const currentRadius = this.radius * pulseFactor;
                ctx.beginPath(); ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                let fillColor, strokeColor, letter;
                if (this.type === 'shield') { 
                    fillColor = 'rgba(0, 191, 255, 0.6)'; strokeColor = 'rgba(0, 121, 205, 1)'; letter = 'S';
                } else if (this.type === 'speed') {
                    fillColor = 'rgba(255, 215, 0, 0.6)'; strokeColor = 'rgba(205, 165, 0, 1)'; letter = 'F';
                } else if (this.type === 'health') {
                    fillColor = 'rgba(50, 205, 50, 0.6)'; strokeColor = 'rgba(0, 155, 0, 1)'; letter = 'H';
                }
                ctx.fillStyle = fillColor; ctx.fill();
                ctx.strokeStyle = strokeColor; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = `bold ${this.radius*0.9}px Arial`; 
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(letter, 0, 1); 
                ctx.restore();
            }
            update(deltaTime) {
                if (Date.now() - this.spawnTime > this.lifeTime && this.active) this.active = false;
            }
        }
        
        function initGame() {
            bullets.length = 0;
            powerUps.length = 0;
            lastPowerUpSpawnTime = Date.now();
            while (uiLayer.firstChild) uiLayer.removeChild(uiLayer.firstChild);

            player1 = new Tank(150, MAP_HEIGHT / 2 + 50, '#337ab7', 'player1'); 
            if (gameMode === 'vsCPU') {
                player2 = new Tank(MAP_WIDTH - 150, MAP_HEIGHT / 2 - 50, '#d9534f', 'player2_ai', true); 
            } else if (gameMode === 'twoPlayer') {
                player2 = new Tank(MAP_WIDTH - 150, MAP_HEIGHT / 2 - 50, '#d9534f', 'player2'); 
            }
            
            initObstacles();
            spawnInitialPowerUps(3); 
            setupMobileControls(); // CRITICAL: Call AFTER gameMode is set.

            gameRunning = true;
            menuScreen.style.display = 'none';
            messageScreen.style.display = 'none';
            gameArea.style.display = 'block'; 
            
            rescaleGame(); 
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = performance.now(); 
            gameLoop();
        }

        function initObstacles() {
            obstacles.length = 0;
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 120, MAP_HEIGHT/2 - 200, 240, 80)); 
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 120, MAP_HEIGHT/2 + 120, 240, 80)); 
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 40, MAP_HEIGHT/2 - 120, 80, 240)); 
            obstacles.push(new Obstacle(100, 100, 120, 60));
            obstacles.push(new Obstacle(MAP_WIDTH - 220, 100, 120, 60));
            obstacles.push(new Obstacle(100, MAP_HEIGHT - 160, 120, 60));
            obstacles.push(new Obstacle(MAP_WIDTH - 220, MAP_HEIGHT - 160, 120, 60));
            obstacles.push(new Obstacle(300, MAP_HEIGHT/2 - 30, 60, 100, '#8c6c46'));
            obstacles.push(new Obstacle(MAP_WIDTH - 360, MAP_HEIGHT/2 - 70, 60, 100, '#8c6c46'));
            obstacles.push(new Obstacle(MAP_WIDTH/2 + 150, 200, 100, 50));
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 250, MAP_HEIGHT - 250, 100, 50));
        }

        function spawnPowerUp() {
            if (powerUps.filter(p => p.active).length >= 4) return; 
            let validPosition = false; let x, y, attempts = 0;
            const types = ['shield', 'speed', 'health', 'health']; 
            const type = types[Math.floor(Math.random() * types.length)];
            while (!validPosition && attempts < 50) {
                x = Math.random() * (MAP_WIDTH - POWERUP_SIZE * 3) + POWERUP_SIZE * 1.5; 
                y = Math.random() * (MAP_HEIGHT - POWERUP_SIZE * 3) + POWERUP_SIZE * 1.5;
                validPosition = true;
                const powerUpRect = { x: x - POWERUP_SIZE, y: y - POWERUP_SIZE, width: POWERUP_SIZE*2, height: POWERUP_SIZE*2 }; 
                for (const obs of obstacles) if (rectIntersect(powerUpRect, obs)) { validPosition = false; break; }
                for (const pup of powerUps) if (pup.active && Math.hypot(x-pup.x, y-pup.y) < POWERUP_SIZE * 4) { validPosition = false; break; }
                attempts++;
            }
            if (validPosition) powerUps.push(new PowerUp(x, y, type));
        }
        function spawnInitialPowerUps(count) { for(let i = 0; i < count; i++) spawnPowerUp(); }

        let lastTime = 0;
        function update(currentTime) {
            if (!gameRunning) return;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (player1 && player1.health > 0) {
                if (isTouch && p1JoystickState.active) { 
                    if (p1JoystickState.joyX !== 0 || p1JoystickState.joyY !== 0) {
                        const moveAngle = Math.atan2(p1JoystickState.joyY, p1JoystickState.joyX);
                        player1.angle = moveAngle; player1.turretAngle = moveAngle; player1.move(1);
                    }
                } else { 
                    if (keys['w'] || keys['W']) player1.move(1); if (keys['s'] || keys['S']) player1.move(-1);
                    if (keys['a'] || keys['A']) player1.rotateBody(-1); if (keys['d'] || keys['D']) player1.rotateBody(1);
                    if (keys['q'] || keys['Q']) player1.rotateTurret(-1); if (keys['e'] || keys['E']) player1.rotateTurret(1);
                }
                if ((isTouch && fireP1Active) || keys[' ']) player1.shoot(); 
                player1.updatePowerUps(deltaTime);
            }
            
            if (player2 && player2.health > 0) {
                if (gameMode === 'twoPlayer') {
                    if (isTouch && p2JoystickState.active) { 
                        if (p2JoystickState.joyX !== 0 || p2JoystickState.joyY !== 0) {
                            const moveAngle = Math.atan2(p2JoystickState.joyY, p2JoystickState.joyX);
                            player2.angle = moveAngle; player2.turretAngle = moveAngle; player2.move(1);
                        }
                    } else { 
                        if (keys['ArrowUp']) player2.move(1); if (keys['ArrowDown']) player2.move(-1);
                        if (keys['ArrowLeft']) player2.rotateBody(-1); if (keys['ArrowRight']) player2.rotateBody(1);
                        if (keys[','] || keys['<']) player2.rotateTurret(-1); if (keys['.'] || keys['>']) player2.rotateTurret(1);
                    }
                    if ((isTouch && fireP2Active) || keys['Enter']) player2.shoot();
                    player2.updatePowerUps(deltaTime);
                } else if (gameMode === 'vsCPU' && player1 && player1.health > 0) { 
                    player2.updateAI(deltaTime, player1); 
                }
            }
            
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i]; bullet.update();
                if (bullet.x < -BULLET_SIZE || bullet.x > MAP_WIDTH + BULLET_SIZE || bullet.y < -BULLET_SIZE || bullet.y > MAP_HEIGHT + BULLET_SIZE) {
                    bullets.splice(i, 1); continue;
                }
                let hit = false;
                for (const obs of obstacles) if (pointInRect({x: bullet.x, y: bullet.y}, obs)) { bullets.splice(i, 1); hit = true; break; }
                if (hit) continue;
                const targets = [];
                if (player1 && player1.health > 0) targets.push(player1); if (player2 && player2.health > 0) targets.push(player2);
                for (const tank of targets) {
                    if (bullet.owner !== tank) { 
                        const dist = Math.hypot(bullet.x - tank.x, bullet.y - tank.y);
                        if (dist < tank.width / 2 + bullet.size / 2) { 
                            tank.takeDamage(12); bullets.splice(i, 1); hit = true; break; 
                        }
                    }
                }
                if (hit) continue;
            }
            
            const activeTanks = [];
            if (player1 && player1.health > 0) activeTanks.push(player1); if (player2 && player2.health > 0) activeTanks.push(player2);
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i]; pu.update(deltaTime); 
                if (!pu.active) { powerUps.splice(i, 1); continue; }
                for (const tank of activeTanks) {
                    const dist = Math.hypot(tank.x - pu.x, tank.y - pu.y);
                    if (dist < tank.width / 2 + pu.radius) {
                        tank.applyPowerUp(pu.type); pu.active = false; break; 
                    }
                }
            }
            if (Date.now() - lastPowerUpSpawnTime > POWERUP_SPAWN_INTERVAL) { spawnPowerUp(); lastPowerUpSpawnTime = Date.now(); }
        }
        function draw() {
            ctx.fillStyle = '#bfa870'; 
            ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
            obstacles.forEach(obs => obs.draw());
            powerUps.forEach(pu => pu.draw()); 
            if (player1 && player1.health > 0) player1.draw();
            if (player2 && player2.health > 0) player2.draw();
            bullets.forEach(bullet => bullet.draw());
        }
        function gameLoop(currentTime) { 
            if (!gameRunning) return;
            animationFrameId = requestAnimationFrame(gameLoop);
            update(currentTime); draw();
        }
        function endGame(message) {
            gameRunning = false;
            messageText.textContent = message;
            messageScreen.style.display = 'flex';
            hideAllMobileControls(); 
        }
        function rectIntersect(r1, r2) { 
            return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
        }
        function pointInRect(point, rect) { 
            return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height;
        }

        window.addEventListener('keydown', (e) => { keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key] = false; });

        let isTouch = false;
        let fireP1Active = false; let fireP1Identifier = null;
        let fireP2Active = false; let fireP2Identifier = null;

        function isTouchDevice() { return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)); }
        
        function setupMobileControls() {
            isTouch = isTouchDevice();
            hideAllMobileControls(); // Clear previous settings

            if (isTouch) {
                if (gameMode === 'twoPlayer') {
                    // P1 Joystick: Top-Left
                    joystickContainerP1.style.top = '20px';
                    joystickContainerP1.style.bottom = 'auto';
                    joystickContainerP1.style.left = '20px';
                    joystickContainerP1.style.right = 'auto';
                    joystickContainerP1.style.display = 'block';

                    // P1 Fire Button: Top-Right
                    fireButtonContainerP1.style.top = '30px';
                    fireButtonContainerP1.style.bottom = 'auto';
                    fireButtonContainerP1.style.right = '20px';
                    fireButtonContainerP1.style.left = 'auto';
                    fireButtonContainerP1.style.display = 'flex';

                    // P2 Joystick: Bottom-Right
                    joystickContainerP2.style.top = 'auto';
                    joystickContainerP2.style.bottom = '20px';
                    joystickContainerP2.style.right = '20px';
                    joystickContainerP2.style.left = 'auto';
                    joystickContainerP2.style.display = 'block';

                    // P2 Fire Button: Bottom-Left
                    fireButtonContainerP2.style.top = 'auto';
                    fireButtonContainerP2.style.bottom = '30px';
                    fireButtonContainerP2.style.left = '20px';
                    fireButtonContainerP2.style.right = 'auto';
                    fireButtonContainerP2.style.display = 'flex';

                } else if (gameMode === 'vsCPU') {
                    // P1 Joystick: Bottom-Left (default CSS is fine, ensure it's displayed)
                    joystickContainerP1.style.top = 'auto'; // Reset from potential 2P mode
                    joystickContainerP1.style.bottom = '20px';
                    joystickContainerP1.style.left = '20px';
                    joystickContainerP1.style.right = 'auto';
                    joystickContainerP1.style.display = 'block';

                    // P1 Fire Button: Bottom-Right (default CSS is fine, ensure it's displayed)
                    fireButtonContainerP1.style.top = 'auto'; // Reset from potential 2P mode
                    fireButtonContainerP1.style.bottom = '30px';
                    fireButtonContainerP1.style.right = '20px';
                    fireButtonContainerP1.style.left = 'auto';
                    fireButtonContainerP1.style.display = 'flex';

                    // Ensure P2 controls are hidden in VS CPU
                    joystickContainerP2.style.display = 'none';
                    fireButtonContainerP2.style.display = 'none';
                }
            }
        }
        function hideAllMobileControls() {
            joystickContainerP1.style.display = 'none'; fireButtonContainerP1.style.display = 'none';
            joystickContainerP2.style.display = 'none'; fireButtonContainerP2.style.display = 'none';
        }

        const p1JoystickState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };
        const p2JoystickState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };

        function newJoystickInit(joystickCont, joystickHandle, stateObj) {
            if (joystickCont.offsetWidth > 0) {
                stateObj.radius = joystickCont.offsetWidth / 2;
                stateObj.handleRadius = joystickHandle.offsetWidth / 2;
            } else { 
                stateObj.radius = 60; stateObj.handleRadius = 30; 
            }
            joystickHandle.style.left = '50%'; 
            joystickHandle.style.top = '50%';
            joystickHandle.style.transform = 'translate(-50%, -50%)';

            joystickCont.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (stateObj.active) return; 
                if (joystickCont.offsetWidth > 0) {
                     stateObj.radius = joystickCont.offsetWidth / 2;
                     stateObj.handleRadius = joystickHandle.offsetWidth / 2;
                }
                const touch = e.changedTouches[0];
                stateObj.active = true; stateObj.identifier = touch.identifier;
                newUpdateJoystickPosition(touch, joystickCont, joystickHandle, stateObj);
            }, { passive: false });
        }
        function newUpdateJoystickPosition(touch, joystickCont, joystickHandle, stateObj) {
            const rect = joystickCont.getBoundingClientRect();
            let currentX = touch.clientX - rect.left; let currentY = touch.clientY - rect.top;
            let deltaX = currentX - stateObj.radius; let deltaY = currentY - stateObj.radius;
            const distance = Math.hypot(deltaX, deltaY);
            const maxDist = stateObj.radius - stateObj.handleRadius;

            if (maxDist <= 0) return; 

            if (distance > maxDist) {
                deltaX = (deltaX / distance) * maxDist; deltaY = (deltaY / distance) * maxDist;
            }
            joystickHandle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            stateObj.joyX = maxDist ? deltaX / maxDist : 0; 
            stateObj.joyY = maxDist ? deltaY / maxDist : 0;
        }
        function newResetJoystick(joystickHandle, stateObj) {
            stateObj.active = false; stateObj.identifier = null;
            joystickHandle.style.transform = 'translate(-50%, -50%)';
            stateObj.joyX = 0; stateObj.joyY = 0;
        }

        window.addEventListener('touchmove', (e) => {
            if (!gameRunning) return; 
            e.preventDefault(); 
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (p1JoystickState.active && touch.identifier === p1JoystickState.identifier) {
                    newUpdateJoystickPosition(touch, joystickContainerP1, joystickHandleP1, p1JoystickState);
                }
                if (p2JoystickState.active && touch.identifier === p2JoystickState.identifier) {
                    newUpdateJoystickPosition(touch, joystickContainerP2, joystickHandleP2, p2JoystickState);
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            if (!gameRunning) return; 
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (p1JoystickState.active && touch.identifier === p1JoystickState.identifier) {
                    newResetJoystick(joystickHandleP1, p1JoystickState);
                }
                if (p2JoystickState.active && touch.identifier === p2JoystickState.identifier) {
                    newResetJoystick(joystickHandleP2, p2JoystickState);
                }
                if (fireP1Active && touch.identifier === fireP1Identifier) {
                    fireP1Active = false; fireP1Identifier = null;
                }
                if (fireP2Active && touch.identifier === fireP2Identifier) {
                    fireP2Active = false; fireP2Identifier = null;
                }
            }
        }, { passive: false });
        
        function setupFireButton(fireButtonElem, playerIndex) { 
            fireButtonElem.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                if (playerIndex === 1) {
                    if (fireP1Active) return;
                    fireP1Active = true; fireP1Identifier = touch.identifier;
                } else if (playerIndex === 2) {
                    if (fireP2Active) return;
                    fireP2Active = true; fireP2Identifier = touch.identifier;
                }
            }, { passive: false });
        }
        
        function rescaleGame() {
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;
            const scaleX = availableWidth / MAP_WIDTH;
            const scaleY = availableHeight / MAP_HEIGHT;
            G_SCALE = Math.min(scaleX, scaleY, 1); 
            gameArea.style.transformOrigin = 'top left';
            gameArea.style.transform = `scale(${G_SCALE})`;
            gameArea.style.width = (MAP_WIDTH * G_SCALE) + 'px';
            gameArea.style.height = (MAP_HEIGHT * G_SCALE) + 'px';
            
            if (isTouch) { 
                if (joystickContainerP1.style.display !== 'none' && joystickContainerP1.offsetWidth > 0) {
                     p1JoystickState.radius = joystickContainerP1.offsetWidth / 2;
                     p1JoystickState.handleRadius = joystickHandleP1.offsetWidth / 2;
                }
                if (joystickContainerP2.style.display !== 'none' && joystickContainerP2.offsetWidth > 0) {
                     p2JoystickState.radius = joystickContainerP2.offsetWidth / 2;
                     p2JoystickState.handleRadius = joystickHandleP2.offsetWidth / 2;
                }
                // Only call setupMobileControls if game is running to avoid messing with menu state
                if (gameRunning) { 
                    setupMobileControls();
                }
            }
            fullscreenButton.textContent = document.fullscreenElement ? "Exit Fullscreen" : "Enter Fullscreen";
        }
        window.addEventListener('load', () => {
            gameArea.style.display = 'none'; 
            menuScreen.style.display = 'flex'; 
            rescaleGame();
            isTouch = isTouchDevice(); 
            if(isTouch) {
                newJoystickInit(joystickContainerP1, joystickHandleP1, p1JoystickState);
                newJoystickInit(joystickContainerP2, joystickHandleP2, p2JoystickState);
                setupFireButton(fireButtonP1, 1); 
                setupFireButton(fireButtonP2, 2); 
            }
            hideAllMobileControls(); 
            
            ctx.fillStyle = '#2c2c2c';
            ctx.fillRect(0,0,MAP_WIDTH, MAP_HEIGHT);
            ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center";
            ctx.fillText("Tank Battle by Lapis Yamz", MAP_WIDTH/2, MAP_HEIGHT/2 - 20);
            ctx.font = "20px Arial";
            ctx.fillText("Select an option from the menu.", MAP_WIDTH/2, MAP_HEIGHT/2 + 20);
        });

        window.addEventListener('resize', rescaleGame);
        document.addEventListener('fullscreenchange', rescaleGame); 

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        fullscreenButton.addEventListener('click', toggleFullScreen);

        vsCPUButton.addEventListener('click', () => { gameMode = 'vsCPU'; initGame(); });
        twoPlayerButton.addEventListener('click', () => { gameMode = 'twoPlayer'; initGame(); });
        playAgainButton.addEventListener('click', () => { initGame(); });
        backToMenuButton.addEventListener('click', () => {
            messageScreen.style.display = 'none';
            gameArea.style.display = 'none'; 
            menuScreen.style.display = 'flex';
            gameRunning = false;
            hideAllMobileControls();
            rescaleGame(); 
        });
        
    </script>
</body>
</html>