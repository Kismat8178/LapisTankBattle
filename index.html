
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tank Battle by Lapis Yamz - V2.7.0 (Controls/UI/Events/Skills Update)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #1c1c1c; /* Darker background */
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        #gameArea {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            display: none;
            background-color: #333; /* Fallback for canvas */
        }
        #gameContainer {
            position: relative;
        }
        canvas {
            display: block;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        .health-bar-container {
            position: absolute;
            width: 50px;
            height: 8px;
            background-color: rgba(85, 85, 85, 0.7);
            border: 1px solid #222;
            border-radius: 2px;
            box-sizing: border-box;
        }
        .health-bar {
            height: 100%;
            background-color: limegreen;
            border-radius: 1px;
            transition: width 0.2s ease-out;
        }
        .shield-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: deepskyblue;
            border-radius: 50%;
            border: 1px solid #fff;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .joystick-container-base {
            position: fixed;
            width: 120px;
            height: 120px;
            background-color: rgba(120, 120, 120, 0.35); /* Slightly lighter joystick base */
            border-radius: 50%;
            display: none;
            z-index: 100;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            border: 2px solid rgba(255,255,255,0.15);
        }
        .joystick-handle-base {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(200, 200, 200, 0.65); /* Slightly lighter handle */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.25);
        }
        /* P1 Controls */
        #joystickContainerP1Move { bottom: 20px; left: 20px; }
        #joystickContainerP1Aim { bottom: 20px; right: 20px; }
        
        /* P2 Controls (for 2-player mobile) */
        #joystickContainerP2Move { top: 20px; left: 20px; }
        #joystickContainerP2Aim { top: 20px; right: 20px; }


        /* Active Skill Button */
        .skill-button-container-base {
            position: fixed;
            display: none;
            z-index: 100;
        }
        .skill-button-base {
            width: 70px;
            height: 70px;
            background-color: rgba(150, 50, 255, 0.6); /* Purple-ish */
            color: white;
            border: 2px solid rgba(120, 30, 220, 0.8);
            border-radius: 50%;
            font-size: 13px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            box-shadow: 0 0 12px rgba(150, 50, 255, 0.4);
            transition: background-color 0.1s ease-out, box-shadow 0.1s ease-out, transform 0.1s ease-out;
            padding: 5px;
            box-sizing: border-box;
            text-align: center;
            line-height: 1.2;
        }
        .skill-button-base.on-cooldown {
            background-color: rgba(100, 100, 100, 0.7);
            color: #aaa;
            border-color: rgba(80,80,80,0.8);
            cursor: not-allowed;
        }
        .skill-button-base .cooldown-text {
            font-size: 16px;
            font-weight: bold;
        }

        #skillButtonContainerP1 { bottom: 140px; right: 35px; /* Adjust based on aim joystick */ }
        #skillButtonContainerP2 { top: 140px; right: 35px; /* Adjust based on P2 aim joystick */}


        /* --- Screen Styles --- */
        .screen {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,10,10,0.92); /* Darker screen background */
            z-index: 200;
            padding: 0;
            box-sizing: border-box;
            text-align: center;
            color: #fff;
        }
        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center; 
        }
        .screen h1 {
            font-size: clamp(2.2em, 7vw, 3.8em); margin-bottom: 15px; margin-top: 10px;
            color: #00BFFF; /* Deep Sky Blue for titles */ text-shadow: 2px 2px 2px #0000CD; /* Medium Blue shadow */
        }
        .screen p {
             margin-bottom: 20px; font-size: clamp(0.9em, 3vw, 1.2em); color: #ccc;
        }
        .screen input[type="text"], .screen input[type="password"] {
            padding: 10px; margin: 8px 0; border-radius: 5px; border: 1px solid #557; /* Bluish gray border */
            background-color: #334; color: white; font-size: 1em; width: 80%; max-width: 300px;
        }

        /* --- Menu Screen Redesign --- */
        #menuScreen { justify-content: flex-start; }
        .menu-top-bar {
            width: 100%;
            padding: 10px 15px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0,0,0,0.4); /* Darker top bar */
            flex-shrink: 0;
        }
        .menu-top-bar button {
            padding: 8px 12px; font-size: clamp(0.8em, 2vw, 1em);
            margin-left: 8px;
        }
        #loggedInUserDisplay { font-size: clamp(0.9em, 2.5vw, 1.1em); color: #FFD700; }

        #menuScreen h1 { margin-top: clamp(10px, 3vh, 20px); margin-bottom: clamp(5px, 1vh, 10px); }
        #menuScreen > p { margin-bottom: clamp(15px, 4vh, 30px); } /* This targets the <p>By Lapis Yamz</p> */

        .menu-main-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(10px, 2vh, 15px);
            margin-bottom: clamp(15px, 4vh, 30px);
            width: 100%;
        }
        .menu-main-actions .baseButton, .menu-secondary-actions .baseButton {
            width: clamp(250px, 60vw, 350px);
        }
        .large-menu-button { 
            padding: clamp(15px, 3.5vw, 22px) clamp(30px, 6vw, 40px) !important;
            font-size: clamp(1.3em, 4.5vw, 1.8em) !important;
        }
        .large-menu-button:disabled {
            background: #546E7A !important; color: #90A4AE !important; /* Lighter disabled text */
            box-shadow: 0 5px 0 #37474F !important; cursor: not-allowed;
        }


        .menu-secondary-actions {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: clamp(8px, 1.5vw, 12px);
            margin-bottom: clamp(15px, 3vh, 25px);
            width: 90%;
        }
         .menu-secondary-actions .baseButton {
            min-width: clamp(130px, 35vw, 160px);
            width: auto;
            padding: clamp(10px, 2.5vw, 15px) clamp(15px, 4vw, 22px) !important;
            font-size: clamp(0.9em, 3vw, 1.2em) !important;
        }

        /* Event Screen Specifics (previously #eventSection) */
        #eventScreen .event-section-item { /* New class for individual event blocks */
            background-color: rgba(30,30,50,0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            width: 90%;
            max-width: 450px;
            border: 1px solid rgba(100,100,200,0.3);
        }
        #eventScreen .event-section-item h3 {
            color: #FFD700; /* Gold */
            margin-top: 0; margin-bottom: 10px;
            font-size: clamp(1.1em, 3vw, 1.4em);
        }
        #eventScreen .event-section-item p { font-size: clamp(0.85em, 2.5vw, 1.05em); margin-bottom: 8px; color: #ddd; }
        #eventScreen .event-timer { font-weight: bold; color: #FFA07A; /* Light Salmon */ }
        
        .claimButton { /* Class for claim buttons */
            background: linear-gradient(145deg, #FF9800, #F57C00); /* Orange gradient */
            box-shadow: 0 5px 0 #E65100, 0 8px 15px rgba(0,0,0,0.3);
            color: white;
            padding: 10px 20px !important;
            font-size: clamp(0.9em, 3vw, 1.1em) !important;
        }
        .claimButton:hover { background: linear-gradient(145deg, #FFA726, #FB8C00); transform: translateY(-2px); box-shadow: 0 7px 0 #E65100, 0 10px 20px rgba(0,0,0,0.2); }
        .claimButton:active { background: linear-gradient(145deg, #F57C00, #E65100); transform: translateY(2px); box-shadow: 0 2px 0 #E65100, 0 5px 10px rgba(0,0,0,0.4); }
        .claimButton:disabled {
             background: #78909C !important; color: #B0BEC5 !important;
             box-shadow: 0 5px 0 #546E7A !important; cursor: not-allowed;
        }


        #mapSelectorContainer, #mySkinsSection { 
            margin-top: clamp(10px, 2vh, 15px); /* Reduced margin */
            width: 90%;
            max-width: 380px; /* Slightly smaller */
            overflow: hidden; /* Helps contain children */
        }


        .baseButton {
            padding: clamp(12px, 3vw, 18px) clamp(25px, 5vw, 35px);
            font-size: clamp(1.1em, 4vw, 1.6em);
            margin: 8px;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            min-width: 220px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        .menuButton { /* General style for all menu buttons - now BLUE */
            background: linear-gradient(145deg, #2196F3, #1976D2); /* Blue gradient */
            box-shadow: 0 5px 0 #1565C0, 0 8px 15px rgba(0,0,0,0.3); /* Darker blue shadow */
        }
        .menuButton:hover { background: linear-gradient(145deg, #42A5F5, #1E88E5); transform: translateY(-2px); box-shadow: 0 7px 0 #1565C0, 0 10px 20px rgba(0,0,0,0.2);}
        .menuButton:active { background: linear-gradient(145deg, #1976D2, #1565C0); transform: translateY(2px); box-shadow: 0 2px 0 #1565C0, 0 5px 10px rgba(0,0,0,0.4); }

        .shopButton.secondary-menu-button { /* Kept blue as it was already blue-ish, adjusted to match new theme */
            background: linear-gradient(145deg, #03A9F4, #0288D1); /* Light blue variant */
            box-shadow: 0 5px 0 #0277BD, 0 8px 15px rgba(0,0,0,0.3);
        }
        .shopButton.secondary-menu-button:hover { background: linear-gradient(145deg, #29B6F6, #039BE5); transform: translateY(-2px);box-shadow: 0 7px 0 #0277BD, 0 10px 20px rgba(0,0,0,0.2); }
        .shopButton.secondary-menu-button:active { background: linear-gradient(145deg, #0288D1, #0277BD);transform: translateY(2px); box-shadow: 0 2px 0 #0277BD, 0 5px 10px rgba(0,0,0,0.4);}

        .profileButton.secondary-menu-button { /* Purple to a different contrasting color - e.g., Teal */
             background: linear-gradient(145deg, #009688, #00796B); /* Teal */
             box-shadow: 0 5px 0 #004D40, 0 8px 15px rgba(0,0,0,0.3);
        }
        .profileButton.secondary-menu-button:hover { background: linear-gradient(145deg, #26A69A, #00897B); transform: translateY(-2px); box-shadow: 0 7px 0 #004D40, 0 10px 20px rgba(0,0,0,0.2);}
        .profileButton.secondary-menu-button:active { background: linear-gradient(145deg, #00796B, #00695C); transform: translateY(2px); box-shadow: 0 2px 0 #004D40, 0 5px 10px rgba(0,0,0,0.4);}

        .leaderboardButton.secondary-menu-button { /* Gold/Yellow, distinct and good */
             background: linear-gradient(145deg, #FFC107, #FFA000);
             box-shadow: 0 5px 0 #FF6F00, 0 8px 15px rgba(0,0,0,0.3);
        }
        .leaderboardButton.secondary-menu-button:hover { background: linear-gradient(145deg, #FFCA28, #FFB300); transform: translateY(-2px); box-shadow: 0 7px 0 #FF6F00, 0 10px 20px rgba(0,0,0,0.2);}
        .leaderboardButton.secondary-menu-button:active { background: linear-gradient(145deg, #FFA000, #FF8F00); transform: translateY(2px); box-shadow: 0 2px 0 #FF6F00, 0 5px 10px rgba(0,0,0,0.4);}
        
        .howToPlayButton.secondary-menu-button { /* Was teal, can remain or shift slightly, using Indigo now for variety */
            background: linear-gradient(145deg, #3F51B5, #303F9F); /* Indigo */
            box-shadow: 0 5px 0 #1A237E, 0 8px 15px rgba(0,0,0,0.3);
        }
        .howToPlayButton.secondary-menu-button:hover { background: linear-gradient(145deg, #5C6BC0, #3949AB); transform: translateY(-2px);box-shadow: 0 7px 0 #1A237E, 0 10px 20px rgba(0,0,0,0.2); }
        .howToPlayButton.secondary-menu-button:active { background: linear-gradient(145deg, #303F9F, #283593); transform: translateY(2px); box-shadow: 0 2px 0 #1A237E, 0 5px 10px rgba(0,0,0,0.4);}

        /* New Events Button Style */
        .eventsButton.secondary-menu-button {
            background: linear-gradient(145deg, #4CAF50, #388E3C); /* Green gradient */
            box-shadow: 0 5px 0 #2E7D32, 0 8px 15px rgba(0,0,0,0.3);
        }
        .eventsButton.secondary-menu-button:hover { background: linear-gradient(145deg, #66BB6A, #43A047); transform: translateY(-2px); box-shadow: 0 7px 0 #2E7D32, 0 10px 20px rgba(0,0,0,0.2); }
        .eventsButton.secondary-menu-button:active { background: linear-gradient(145deg, #388E3C, #2E7D32); transform: translateY(2px); box-shadow: 0 2px 0 #2E7D32, 0 5px 10px rgba(0,0,0,0.4); }


        .difficultyButton { /* Orange, good contrast */
            background: linear-gradient(145deg, #ff9800, #f57c00);
            box-shadow: 0 5px 0 #e65100, 0 8px 15px rgba(0,0,0,0.3);
        }
        .difficultyButton:hover { background: linear-gradient(145deg, #ffa726, #fb8c00);transform: translateY(-2px);box-shadow: 0 7px 0 #e65100, 0 10px 20px rgba(0,0,0,0.2); }
        .difficultyButton:active { background: linear-gradient(145deg, #f57c00, #e65100); transform: translateY(2px);box-shadow: 0 2px 0 #e65100, 0 5px 10px rgba(0,0,0,0.4); }

        .backButton { /* Red, good for "back" or "cancel" */
            background: linear-gradient(145deg, #f44336, #d32f2f);
            box-shadow: 0 5px 0 #b71c1c, 0 8px 15px rgba(0,0,0,0.3);
            margin-top: 25px;
        }
        .backButton:hover { background: linear-gradient(145deg, #ef5350, #e53935); transform: translateY(-2px); box-shadow: 0 7px 0 #b71c1c, 0 10px 20px rgba(0,0,0,0.2); }
        .backButton:active { background: linear-gradient(145deg, #d32f2f, #c62828); transform: translateY(2px);box-shadow: 0 2px 0 #b71c1c, 0 5px 10px rgba(0,0,0,0.4); }

        #playerMoneyDisplay { 
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(1.1em, 3.2vw, 1.6em);
            color: #FFD700;
            background-color: rgba(0,0,0,0.7); /* Darker bg */
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 210; 
            border: 1px solid rgba(255,215,0,0.6); /* Brighter border */
            font-weight: bold;
        }

        .screen-content-wrapper {
            padding: 20px;
            padding-top: 10px; 
            box-sizing: border-box;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top to allow scrolling for more content */
            overflow-y: auto;
            flex-grow: 1; 
            -webkit-overflow-scrolling: touch;
        }


        #shopItemsContainer {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 18px; /* Slightly reduced gap */
            max-height: 70vh; /* Increased max height for better scrolling */
            overflow-y: auto;
            padding: 15px;
            width: 95%;
            max-width: 900px;
            background-color: rgba(20,20,30,0.05); /* Bluish tint */
            border-radius: 10px;
            border: 1px solid rgba(100,100,150,0.15); /* Bluish border */
            margin-bottom: 15px;
        }
        .shopItem {
            background-color: rgba(30,30,50,0.85); /* Darker blue-gray */
            border: 1px solid #445; /* Darker border */
            border-radius: 10px;
            padding: 15px; 
            width: clamp(200px, 28vw, 260px); 
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.6); /* Stronger shadow */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .shopItem:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
        }
        .shopItem.expensive-skin-glow {
            box-shadow: 0 0 18px gold, 0 0 30px #FFFF99, 0 5px 15px rgba(0,0,0,0.5);
            border: 1px solid gold;
        }
        .shopItem.expensive-skin-glow:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 25px gold, 0 0 40px #FFFF99, 0 8px 25px rgba(0,0,0,0.4);
        }

        .shopItem h3 { margin-top: 0; margin-bottom: 8px; color: #FFD700; font-size: clamp(1.1em, 2.8vw, 1.4em);}
        .shopItem p { font-size: clamp(0.8em, 2.3vw, 1em); margin-bottom: 8px; color: #bbb;}
        .shopItem .price { font-weight: bold; color: #8BC34A; font-size: clamp(0.9em, 2.5vw, 1.1em); }
        .shopItem .owned { color: #4CAF50; font-weight: bold; font-size: clamp(0.9em, 2.5vw, 1.1em); }
        .buySkinButton { /* Matched to main menu button style */
            background: linear-gradient(145deg, #2196F3, #1976D2);
            box-shadow: 0 4px 0 #1565C0, 0 6px 12px rgba(0,0,0,0.25);
            font-size: clamp(0.9em, 3vw, 1.3em); padding: 8px 18px; min-width: 130px; margin-top: auto;
        }
        .buySkinButton:hover { background: linear-gradient(145deg, #42A5F5, #1E88E5);transform: translateY(-1px);box-shadow: 0 5px 0 #1565C0, 0 7px 15px rgba(0,0,0,0.2); }
        .buySkinButton:active { background: linear-gradient(145deg, #1976D2, #1565C0);transform: translateY(1px);box-shadow: 0 2px 0 #1565C0, 0 4px 8px rgba(0,0,0,0.3); }
        .buySkinButton:disabled {
            background: #546E7A; color: #CFD8DC;
            box-shadow: 0 4px #37474F; cursor: not-allowed;
        }
        
        .skin-preview-canvas {
            width: 80px; 
            height: 60px; 
            margin-bottom: 10px;
            border: 1px solid #557; /* Bluish gray border */
            background-color: #445; /* Darker fallback bg */
            border-radius: 5px;
        }

        .bullet-color-preview { 
            width: 15px; height: 15px; border-radius: 50%;
            display: inline-block; margin-left: 8px;
            border: 1px solid rgba(255,255,255,0.7);
            vertical-align: middle;
        }

        #mySkinsSection, #mapSelectorContainer {
            margin-top: 15px;
            text-align: center;
            background-color: rgba(20,20,40,0.3); /* Darker blue-ish */
            padding: 10px 15px;
            border-radius: 8px;
            width: 90%;
            max-width: 380px; /* Adjusted for responsiveness */
             box-sizing: border-box; /* Ensure padding is included in width */
        }
        #mySkinsSection h2, #mapSelectorContainer h2 {
            font-size: clamp(1.2em, 3.5vw, 1.7em);
            margin-bottom: 8px; color: #87CEFA; /* Light Sky Blue */
        }
        #skinSelector, #mapSelectorMenu {
            padding: 10px 15px;
            font-size: clamp(1em, 3vw, 1.3em);
            border-radius: 6px;
            background-color: #334; /* Dark blue-gray */
            color: white;
            border: 1px solid #557; /* Bluish gray border */
            min-width: auto; /* Allow to shrink */
            width: 100%; /* Take full width of container */
            box-sizing: border-box; /* Important for width: 100% */
            -webkit-appearance: none; /* For better styling on iOS */
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23DDDDDD%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: .65em auto;
            padding-right: 2.5em; /* Make space for arrow */
        }


        /* Profile Screen */
        #profileScreen .profile-info {
            background-color: rgba(30,30,50,0.1); /* Bluish tint */
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(100,100,150,0.2); /* Bluish border */
        }
        #profileScreen label { display: block; margin-top: 10px; font-size: 1.1em; color: #FFC107; }
        #profileScreen #usernameInputProfile { 
            padding: 8px; margin-top: 5px; border-radius: 5px; border: 1px solid #557;
            background-color: #334; color: white; font-size: 1em; width: 80%;
        }
        #profileScreen .stat { margin: 8px 0; font-size: 1.2em; }
        #profileScreen .stat-label { color: #B0C4DE; /* Light Steel Blue */ }
        #profileScreen .stat-value { color: #87CEFA; /* Light Sky Blue */ font-weight: bold; }
        #profileScreen #ownedSkinsList { list-style: none; padding: 0; margin-top: 10px;}
        #profileScreen #ownedSkinsList li {
            background-color: rgba(100,100,150,0.15); /* Light bluish */
            margin: 5px 0;
            padding: 8px 12px;
            border-radius: 4px;
            display: flex;
            align-items: center;
        }

        /* Leaderboard Screen */
        #leaderboardScreen .leaderboard-section {
            background-color: rgba(30,30,50,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            width: 90%;
            max-width: 600px;
            border: 1px solid rgba(100,100,150,0.2);
        }
        #leaderboardScreen h2 {
            color: #FFC107;
            font-size: clamp(1.4em, 4vw, 2em);
            margin-bottom: 10px;
        }
        #leaderboardScreen ol {
            list-style-type: decimal;
            padding-left: 30px;
            margin: 0;
            text-align: left;
            max-height: 30vh; /* Max height for list */
            overflow-y: auto;
        }
        #leaderboardScreen li {
            padding: 8px 5px;
            font-size: clamp(1em, 2.8vw, 1.3em);
            color: #ddd;
            border-bottom: 1px solid rgba(100,100,150,0.12);
        }
        #leaderboardScreen li:last-child { border-bottom: none; }
        #leaderboardScreen li .username { font-weight: bold; color: #87CEFA; }
        #leaderboardScreen li .score { float: right; color: #FFD700; }


        #messageScreen { z-index: 300; }
        .game-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(1em, 3vw, 1.5em);
            color: #bbb; /* Lighter gray */
            opacity: 0.7;
            text-shadow: 1px 1px #000;
            pointer-events: none;
        }
        #otherGameLinkContainer {
            position: fixed;
            bottom: 0px; /* Flush to bottom */
            width: 100%;
            text-align: center;
            font-size: 0.7em;
            z-index: 500;
            color: #aaa;
            padding: 3px 0; /* Slightly more padding */
            background-color: rgba(0,0,0,0.5); /* Darker bg */
        }
        #otherGameLinkContainer a { color: #87CEFA; text-decoration: none; }
        #otherGameLinkContainer a:hover { text-decoration: underline; }

        /* How to Play Screen */
        #howToPlayScreen .instructions {
            margin-top: 20px; font-size: clamp(0.8em, 2.8vw, 1.1em);
            text-align: left; max-width: 90%; color: #ccc;
            padding: 15px; background-color: rgba(30,30,50,0.1); border-radius: 8px;
        }
        #howToPlayScreen .instructions p { margin: 8px 0; }
        #howToPlayScreen .instructions strong { color: #87CEFA; }


        /* Login/Register Screen Specifics */
        #loginScreen .form-container, #registerScreen .form-container {
            background-color: rgba(30,30,50,0.1);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 400px;
            border: 1px solid rgba(100,100,150,0.2);
        }
        #loginScreen p, #registerScreen p {
            font-size: clamp(0.9em, 2.8vw, 1.1em);
        }
        #loginScreen .switch-form-link, #registerScreen .switch-form-link {
            color: #87CEFA;
            cursor: pointer;
            text-decoration: underline;
            margin-top: 15px;
            display: inline-block;
        }
        .error-message {
            color: #ff6b6b;
            margin-top: -10px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

    </style>
</head>
<body>
    <audio id="menuMusic" loop src="https://www.chosic.com/wp-content/uploads/2022/01/The-Epic-2.mp3"></audio>
    <div id="playerMoneyDisplay">$0</div>

    <div id="menuScreen" class="screen active">
        <div class="menu-top-bar">
            <div>
                <span id="loggedInUserDisplay">Guest</span>
                <button class="baseButton menuButton" id="loginRegisterButton" style="font-size: 0.8em; padding: 6px 10px; min-width:auto; margin-left: 5px;">Login/Register</button>
                <button class="baseButton backButton" id="logoutButton" style="font-size: 0.8em; padding: 6px 10px; min-width:auto; margin-left: 5px; display:none;">Logout</button>
            </div>
            <div>
                <button class="baseButton menuButton" id="musicToggleButton" style="font-size: 0.8em; padding: 6px 10px; min-width:auto;">üéµ Mute</button>
                <button class="baseButton menuButton" id="fullscreenButtonMenu" style="font-size: 0.8em; padding: 6px 10px; min-width:auto;">‚ÜîÔ∏è Fullscreen</button>
            </div>
        </div>

        <div class="screen-content-wrapper"> <!-- Wrap content for scrolling -->
            <h1>Tank Battle</h1>
            <p>By Lapis Yamz</p> <!-- This P tag is targeted by #menuScreen > p currently -->

            <div class="menu-main-actions">
                <button class="menuButton baseButton large-menu-button" id="vsCPUButton">VS Computer</button>
                <button class="menuButton baseButton large-menu-button" id="twoPlayerButton">2 Player Local</button>
                <button class="menuButton baseButton large-menu-button" id="tournamentButton" disabled>üèÜ Tournament (Soon)</button>
            </div>

            <div class="menu-secondary-actions">
                 <button class="shopButton baseButton secondary-menu-button" id="shopButtonMenu">üõçÔ∏è Shop</button>
                 <button class="profileButton baseButton secondary-menu-button" id="profileButtonMenu">üë§ Profile</button>
                 <button class="leaderboardButton baseButton secondary-menu-button" id="leaderboardButtonMenu">üèÜ Leaderboard</button>
                 <button class="eventsButton baseButton secondary-menu-button" id="eventsButtonMenu">üìÖ Events</button> <!-- New Events Button -->
                 <button class="howToPlayButton baseButton secondary-menu-button" id="howToPlayButton">‚ùì How to Play</button>
            </div>

            <div id="mapSelectorContainer">
                <h2>Select Map:</h2>
                <select id="mapSelectorMenu"></select>
            </div>

            <div id="mySkinsSection">
                <h2>My Tank Skin:</h2>
                <select id="skinSelector"></select>
            </div>
        </div>
    </div>

    <div id="eventScreen" class="screen"> <!-- New Event Screen -->
        <div class="screen-content-wrapper">
            <h1>üéâ Special Events üéâ</h1>
            <div class="event-section-item" id="rcbEventSection">
                <h3>üèÜ RCB Won IPL! üèÜ</h3>
                <p>As a reward, claim your free Sniper skin!</p>
                <button id="rcbClaimButton" class="baseButton claimButton">Claim Sniper Skin</button>
            </div>
            <hr style="border-color: rgba(100,100,200,0.2); margin: 20px 0; width: 80%;">
            <div class="event-section-item" id="collabEventSection">
                 <h3>üöÄ Upcoming Collaboration! üöÄ</h3>
                 <p>LapisTankBattle X For the Last Time!</p>
                 <p>Event Starts In: <span id="collabTimer" class="event-timer">Loading...</span></p>
                 <p style="font-size:0.9em; color: #ccc;"><em>Get ready for 2 New Skins, Free Rewards & more!</em></p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromEvent">Back to Menu</button>
        </div>
    </div>


    <div id="loginScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Login</h1>
            <div class="form-container">
                <p id="loginErrorMessage" class="error-message" style="display:none;"></p>
                <input type="text" id="loginUsername" placeholder="Username" autocomplete="username">
                <input type="password" id="loginPassword" placeholder="Password" autocomplete="current-password">
                <button class="baseButton menuButton" id="loginSubmitButton" style="margin-top:15px;">Login</button>
                <p>Don't have an account? <span id="switchToRegisterLink" class="switch-form-link">Register here</span></p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromLogin">Back to Menu</button>
        </div>
    </div>

    <div id="registerScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Register</h1>
            <div class="form-container">
                <p id="registerErrorMessage" class="error-message" style="display:none;"></p>
                <input type="text" id="registerUsername" placeholder="Username (min 3 chars)" autocomplete="username">
                <input type="password" id="registerPassword" placeholder="Password (min 4 chars)" autocomplete="new-password">
                <button class="baseButton menuButton" id="registerSubmitButton" style="margin-top:15px;">Register</button>
                <p>Already have an account? <span id="switchToLoginLink" class="switch-form-link">Login here</span></p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromRegister">Back to Menu</button>
        </div>
    </div>

    <div id="howToPlayScreen" class="screen">
        <div class="screen-content-wrapper">
             <h1>How to Play</h1>
             <div class="instructions">
                <p><strong>Player 1 (Keyboard):</strong></p>
                <p>&nbsp;&nbsp;WASD: Move Tank</p>
                <p>&nbsp;&nbsp;Q/E: Rotate Turret</p>
                <p>&nbsp;&nbsp;Spacebar: Shoot</p>
                <p>&nbsp;&nbsp;Left Shift: Use Active Skill (if equipped)</p>
                <br>
                <p><strong>Player 2 (Keyboard):</strong></p>
                <p>&nbsp;&nbsp;Arrow Keys: Move Tank</p>
                <p>&nbsp;&nbsp;Comma (,)/Period (.): Rotate Turret</p>
                <p>&nbsp;&nbsp;Enter: Shoot</p>
                <p>&nbsp;&nbsp;Right Shift or NumPad 0: Use Active Skill (if equipped)</p>
                <br>
                <p><strong>Mobile Controls (VS CPU - Player 1):</strong></p>
                <p>&nbsp;&nbsp;Joystick Bottom-Left: Move Tank</p>
                <p>&nbsp;&nbsp;Joystick Bottom-Right: Aim Turret & Shoot (move to aim, release or move past threshold to shoot)</p>
                <p>&nbsp;&nbsp;Skill Button (Above Aim Joystick): Use Active Skill</p>
                <br>
                <p><strong>Mobile Controls (2 Player Local):</strong></p>
                <p>&nbsp;&nbsp;Player 1: Joystick Bottom-Left (Move), Joystick Bottom-Right (Aim/Shoot), Skill Button (Above Aim)</p>
                <p>&nbsp;&nbsp;Player 2: Joystick Top-Left (Move), Joystick Top-Right (Aim/Shoot), Skill Button (Above Aim)</p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromHowToPlay">Back to Menu</button>
        </div>
    </div>


    <div id="difficultyScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Select AI Difficulty</h1>
            <button class="difficultyButton baseButton" data-difficulty="EASY">Easy ($5 Reward)</button>
            <button class="difficultyButton baseButton" data-difficulty="NORMAL">Normal ($10 Reward)</button>
            <button class="difficultyButton baseButton" data-difficulty="HARD">Hard ($20 Reward)</button>
            <button class="difficultyButton baseButton" data-difficulty="FREESTYLE">Freestyle ($30 Reward)</button>
            <button class="backButton baseButton" id="backToMenuFromDifficulty">Back to Menu</button>
        </div>
    </div>

    <div id="shopScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Tank Skin Shop</h1>
            <div id="shopItemsContainer">
                <!-- Shop items will be populated here by JavaScript -->
            </div>
            <button class="backButton baseButton" id="backToMenuFromShop">Back to Menu</button>
        </div>
    </div>

    <div id="profileScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Player Profile</h1>
            <div class="profile-info">
                <div>
                    <label for="usernameInputProfile">Username:</label>
                    <input type="text" id="usernameInputProfile" placeholder="Enter your name" readonly>
                </div>
                <p class="stat"><span class="stat-label">Money:</span> <span id="profileMoney" class="stat-value">$0</span></p>
                <p class="stat"><span class="stat-label">Games Played:</span> <span id="profileGamesPlayed" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">Wins:</span> <span id="profileWins" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">Losses:</span> <span id="profileLosses" class="stat-value">0</span></p>
                <div>
                    <h3 style="color: #FFC107; margin-top: 15px;">Owned Skins:</h3>
                    <ul id="ownedSkinsList"></ul>
                </div>
            </div>
            <button class="backButton baseButton" id="backToMenuFromProfile">Back to Menu</button>
            <p style="font-size: 0.8em; color: #777; margin-top: 15px;">Profile data is saved locally in your browser.</p>
        </div>
    </div>

    <div id="leaderboardScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Leaderboards</h1>
            <div class="leaderboard-section">
                <h2>üí∞ Richest Players (Top Money)</h2>
                <ol id="leaderboardMoneyList"></ol>
            </div>
            <div class="leaderboard-section">
                <h2>üèÜ Top Victors (Most Wins)</h2>
                <ol id="leaderboardWinsList"></ol>
            </div>
            <div class="leaderboard-section">
                <h2>‚ú® Skin Collectors (Most Skins)</h2>
                <ol id="leaderboardSkinsList"></ol>
            </div>
            <button class="backButton baseButton" id="backToMenuFromLeaderboard">Back to Menu</button>
        </div>
    </div>


    <div id="gameArea">
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div id="uiLayer"></div>
        </div>
        <div class="game-title">Tank Battle by Lapis Yamz</div>
    </div>

    <!-- Player 1 Controls -->
    <div id="joystickContainerP1Move" class="joystick-container-base">
        <div id="joystickHandleP1Move" class="joystick-handle-base"></div>
    </div>
    <div id="joystickContainerP1Aim" class="joystick-container-base">
        <div id="joystickHandleP1Aim" class="joystick-handle-base"></div>
    </div>
    <div id="skillButtonContainerP1" class="skill-button-container-base">
        <button id="skillButtonP1" class="skill-button-base">SKILL <span class="cooldown-text"></span></button>
    </div>

    <!-- Player 2 Controls -->
    <div id="joystickContainerP2Move" class="joystick-container-base">
        <div id="joystickHandleP2Move" class="joystick-handle-base"></div>
    </div>
    <div id="joystickContainerP2Aim" class="joystick-container-base">
        <div id="joystickHandleP2Aim" class="joystick-handle-base"></div>
    </div>
    <div id="skillButtonContainerP2" class="skill-button-container-base">
        <button id="skillButtonP2" class="skill-button-base">SKILL <span class="cooldown-text"></span></button>
    </div>


    <div id="messageScreen" class="screen">
        <div class="screen-content-wrapper">
            <div id="messageText" style="font-size: clamp(1.8em, 6vw, 2.8em); color: white; margin-bottom: 20px;">Game Over!</div>
            <button class="menuButton baseButton" id="playAgainButton">Play Again (Same Mode)</button>
            <button class="backButton baseButton" id="backToMenuButton">Back to Menu</button>
        </div>
    </div>

    <div id="otherGameLinkContainer">
        Try our other game: <a href="https://kismat8178.github.io/LapisYamCricket/" target="_blank">LapisYamCricket</a> |
        My YouTube: <a href="https://www.youtube.com/@gamingwithkismat8178" target="_blank">@gamingwithkismat8178</a>
    </div>

    <script>
        const gameArea = document.getElementById('gameArea');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('uiLayer');
        const gameContainer = document.getElementById('gameContainer');

        // P1 Controls
        const joystickContainerP1Move = document.getElementById('joystickContainerP1Move');
        const joystickHandleP1Move = document.getElementById('joystickHandleP1Move');
        const joystickContainerP1Aim = document.getElementById('joystickContainerP1Aim');
        const joystickHandleP1Aim = document.getElementById('joystickHandleP1Aim');
        const skillButtonContainerP1 = document.getElementById('skillButtonContainerP1');
        const skillButtonP1 = document.getElementById('skillButtonP1');

        // P2 Controls
        const joystickContainerP2Move = document.getElementById('joystickContainerP2Move');
        const joystickHandleP2Move = document.getElementById('joystickHandleP2Move');
        const joystickContainerP2Aim = document.getElementById('joystickContainerP2Aim');
        const joystickHandleP2Aim = document.getElementById('joystickHandleP2Aim');
        const skillButtonContainerP2 = document.getElementById('skillButtonContainerP2');
        const skillButtonP2 = document.getElementById('skillButtonP2');


        const menuScreen = document.getElementById('menuScreen');
        const eventScreen = document.getElementById('eventScreen'); // New Event Screen
        const loginScreen = document.getElementById('loginScreen');
        const registerScreen = document.getElementById('registerScreen');
        const howToPlayScreen = document.getElementById('howToPlayScreen');
        const difficultyScreen = document.getElementById('difficultyScreen');
        const shopScreen = document.getElementById('shopScreen');
        const profileScreen = document.getElementById('profileScreen');
        const leaderboardScreen = document.getElementById('leaderboardScreen');
        const messageScreen = document.getElementById('messageScreen');

        const vsCPUButton = document.getElementById('vsCPUButton');
        const twoPlayerButton = document.getElementById('twoPlayerButton');
        const tournamentButton = document.getElementById('tournamentButton'); 
        const shopButtonMenu = document.getElementById('shopButtonMenu');
        const profileButtonMenu = document.getElementById('profileButtonMenu');
        const leaderboardButtonMenu = document.getElementById('leaderboardButtonMenu');
        const eventsButtonMenu = document.getElementById('eventsButtonMenu'); // New Events Button
        const howToPlayButton = document.getElementById('howToPlayButton');
        const fullscreenButtonMenu = document.getElementById('fullscreenButtonMenu');
        const musicToggleButton = document.getElementById('musicToggleButton');
        const menuMusic = document.getElementById('menuMusic');
        menuMusic.volume = 0.3; // Lower default volume for menu music

        const loginRegisterButton = document.getElementById('loginRegisterButton');
        const logoutButton = document.getElementById('logoutButton');
        const loggedInUserDisplay = document.getElementById('loggedInUserDisplay');
        const loginUsernameInput = document.getElementById('loginUsername');
        const loginPasswordInput = document.getElementById('loginPassword');
        const loginSubmitButton = document.getElementById('loginSubmitButton');
        const switchToRegisterLink = document.getElementById('switchToRegisterLink');
        const loginErrorMessage = document.getElementById('loginErrorMessage');
        const registerUsernameInput = document.getElementById('registerUsername');
        const registerPasswordInput = document.getElementById('registerPassword');
        const registerSubmitButton = document.getElementById('registerSubmitButton');
        const switchToLoginLink = document.getElementById('switchToLoginLink');
        const registerErrorMessage = document.getElementById('registerErrorMessage');
        const backToMenuFromLogin = document.getElementById('backToMenuFromLogin');
        const backToMenuFromRegister = document.getElementById('backToMenuFromRegister');

        const rcbClaimButton = document.getElementById('rcbClaimButton'); 
        const collabTimerDisplay = document.getElementById('collabTimer'); 


        const backToMenuFromEvent = document.getElementById('backToMenuFromEvent'); 
        const backToMenuFromHowToPlay = document.getElementById('backToMenuFromHowToPlay');
        const backToMenuFromDifficulty = document.getElementById('backToMenuFromDifficulty');
        const backToMenuFromShop = document.getElementById('backToMenuFromShop');
        const backToMenuFromProfile = document.getElementById('backToMenuFromProfile');
        const backToMenuFromLeaderboard = document.getElementById('backToMenuFromLeaderboard');

        const messageText = document.getElementById('messageText');
        const playAgainButton = document.getElementById('playAgainButton');
        const backToMenuButton = document.getElementById('backToMenuButton');

        const playerMoneyDisplay = document.getElementById('playerMoneyDisplay');
        const shopItemsContainer = document.getElementById('shopItemsContainer');
        const skinSelector = document.getElementById('skinSelector');
        const mapSelectorMenu = document.getElementById('mapSelectorMenu');

        const usernameInputProfile = document.getElementById('usernameInputProfile');
        const profileMoney = document.getElementById('profileMoney');
        const profileGamesPlayed = document.getElementById('profileGamesPlayed');
        const profileWins = document.getElementById('profileWins');
        const profileLosses = document.getElementById('profileLosses');
        const ownedSkinsList = document.getElementById('ownedSkinsList');

        const leaderboardMoneyList = document.getElementById('leaderboardMoneyList');
        const leaderboardWinsList = document.getElementById('leaderboardWinsList');
        const leaderboardSkinsList = document.getElementById('leaderboardSkinsList');


        let gameMode = null;
        let currentAiDifficulty = 'NORMAL';
        let gameRunning = false;
        let animationFrameId;
        let musicPlaying = false;

        let G_MAP_WIDTH = 1200;
        let G_MAP_HEIGHT = 800;

        const TANK_SIZE = 40;
        const TURRET_LENGTH = TANK_SIZE * 0.9;
        const TURRET_WIDTH = TANK_SIZE * 0.25;
        const BULLET_SPEED_BASE = 8;
        const BULLET_SIZE = 6;
        const BASE_TANK_SPEED = 2;
        const TANK_TURN_SPEED = 0.05;
        const TURRET_TURN_SPEED = 0.07;
        const MAX_HEALTH_BASE = 100;
        const SHOOT_COOLDOWN_BASE = 600; //ms
        const BASE_BULLET_DAMAGE = 12;
        const POWERUP_SIZE = 25;
        const POWERUP_DURATION_BASE = 10000; //ms
        const POWERUP_SPAWN_INTERVAL = 12000; //ms
        const AIM_JOYSTICK_SHOOT_THRESHOLD = 0.85; // How far aim joystick needs to be moved to shoot

        let player1, player2;
        const bullets = [];
        const obstacles = [];
        const powerUps = [];
        let lastPowerUpSpawnTime = 0;

        const keys = {};
        let G_SCALE = 1;

        const GUEST_PROFILE_KEY = 'tankBattleGuestProfile_v2.7'; 
        const USER_PROFILES_KEY = 'tankBattleUserProfiles_v2.7'; 
        const LOGGED_IN_USER_KEY = 'tankBattleLoggedInUser_v2.7'; 
        const RCB_CLAIMED_KEY = 'tankBattleRCBClaimed_v2.7';
        const COLLAB_EVENT_END_TIME_KEY = 'tankBattleCollabEndTime_v2.7';


        let currentUser = null; 
        let currentProfileData = { 
            username: 'Guest', 
            money: 0,
            ownedSkins: ['default'],
            selectedSkinId: 'default',
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            selectedMapId: 'classic'
        };

        const SKINS = {
            'default': {
                name: 'Default Mark I', price: 0, color: '#337ab7', bulletColor: '#222222',
                description: "The tried and true classic.",
                p2Color: '#d9534f',
                ability: null
            },
            'scout': {
                name: 'Light Scout X2', price: 75, color: '#90EE90', bulletColor: '#7FFF00',
                description: "Faster movement & fire rate, lighter armor.",
                healthMultiplier: 0.85, speedMultiplier: 1.25, cooldownMultiplier: 0.92,
                ability: null
            },
            'bruiser': {
                name: 'Heavy Bruiser T7', price: 150, color: '#B22222', bulletColor: '#FF4500',
                description: "Heavy armor, stronger shells, but slower.",
                healthMultiplier: 1.30, speedMultiplier: 0.80, damageMultiplier: 1.20,
                ability: null
            },
            'sharpshooter': { 
                name: 'Sniper Model S', price: 300, color: '#00CED1', bulletColor: '#00FFFF',
                description: "Enhanced targeting. Higher damage, quick reload. Fragile.",
                healthMultiplier: 0.80, damageMultiplier: 1.35, cooldownMultiplier: 0.75,
                ability: { type: 'QUICK_AIM', name: 'Focus', cooldown: 20000, duration: 5000 } 
            },
            'phantom': { 
                name: 'Phantom Stealth', price: 550, color: '#6A0DAD', bulletColor: '#DA70D6',
                description: "Quick & deadly. Starts with a temporary shield for 6s.",
                healthMultiplier: 0.95, speedMultiplier: 1.20, damageMultiplier: 1.15, cooldownMultiplier: 0.88,
                special: 'starts_shielded_briefly',
                ability: { type: 'SHIELD_FIREBALL', name: 'Phase Shift', cooldown: 40000, shieldDuration: 5000, fireballDamageMultiplier: 1.5 }
            },
            'golden_goliath': { 
                name: 'Golden Goliath', price: 1200, color: '#B8860B', bulletColor: '#FF8C00',
                description: "The ultimate tank. Superior stats. Power-ups last 30% longer. Slight health regen. Fires glowing missiles & has exhaust fx.",
                healthMultiplier: 1.5, speedMultiplier: 1.15, damageMultiplier: 1.25, cooldownMultiplier: 0.80,
                special: 'powerup_duration_boost_regen',
                ability: { type: 'HEAL_SPEED', name: 'Overdrive', cooldown: 30000, healAmount: 40, speedBoostDuration: 7000, speedBoostMultiplier: 1.5 }
            }
        };

        const MAPS_CONFIG = {
            classic: {
                name: "Classic Arena",
                width: 1200,
                height: 800,
                playerSpawns: [
                    { x: () => 150, y: () => G_MAP_HEIGHT / 2 + 50, angle: Math.PI / 2 },
                    { x: () => G_MAP_WIDTH - 150, y: () => G_MAP_HEIGHT / 2 - 50, angle: -Math.PI / 2 }
                ],
                obstacles: [ 
                    { x: () => G_MAP_WIDTH/2 - 120, y: () => G_MAP_HEIGHT/2 - 200, w: 240, h: 80 }, { x: () => G_MAP_WIDTH/2 - 120, y: () => G_MAP_HEIGHT/2 + 120, w: 240, h: 80 }, { x: () => G_MAP_WIDTH/2 - 40,  y: () => G_MAP_HEIGHT/2 - 120, w: 80,  h: 240 }, { x: () => 100, y: () => 100, w: 120, h: 60 }, { x: () => G_MAP_WIDTH - 220, y: () => 100, w: 120, h: 60 }, { x: () => 100, y: () => G_MAP_HEIGHT - 160, w: 120, h: 60 }, { x: () => G_MAP_WIDTH - 220, y: () => G_MAP_HEIGHT - 160, w: 120, h: 60 }, { x: () => 300, y: () => G_MAP_HEIGHT/2 - 30, w: 60, h: 100, color: '#8c6c46' }, { x: () => G_MAP_WIDTH - 360, y: () => G_MAP_HEIGHT/2 - 70, w: 60, h: 100, color: '#8c6c46' }, { x: () => G_MAP_WIDTH/2 + 150, y: () => 200, w: 100, h: 50 }, { x: () => G_MAP_WIDTH/2 - 250, y: () => G_MAP_HEIGHT - 250, w: 100, h: 50 }
                ],
                bgColor: '#a08860' 
            },
            urban_chaos: { 
                name: "Urban Chaos", width: 1600, height: 1000,
                playerSpawns: [ { x: () => 100, y: () => 100, angle: Math.PI / 4 }, { x: () => G_MAP_WIDTH - 100, y: () => G_MAP_HEIGHT - 100, angle: -3 * Math.PI / 4 } ],
                obstacles: [ { x: () => G_MAP_WIDTH * 0.2, y: () => G_MAP_HEIGHT * 0.2, w: 300, h: 60, color: '#585858' }, { x: () => G_MAP_WIDTH * 0.2, y: () => G_MAP_HEIGHT * 0.2 + 100, w: 60, h: 200, color: '#585858' }, { x: () => G_MAP_WIDTH * 0.8 - 300, y: () => G_MAP_HEIGHT * 0.8 - 60, w: 300, h: 60, color: '#505050' }, { x: () => G_MAP_WIDTH * 0.8 - 60, y: () => G_MAP_HEIGHT * 0.8 - 260, w: 60, h: 200, color: '#505050' }, { x: () => G_MAP_WIDTH / 2 - 150, y: () => G_MAP_HEIGHT / 2 - 30, w: 300, h: 60, color: '#606060' }, { x: () => G_MAP_WIDTH / 2 - 30, y: () => G_MAP_HEIGHT / 2 - 150, w: 60, h: 300, color: '#606060' }, { x: () => 150, y: () => G_MAP_HEIGHT - 200, w: 250, h: 50, color: '#484848' }, { x: () => G_MAP_WIDTH - 400, y: () => 150, w: 250, h: 50, color: '#484848' } ],
                bgColor: '#909090' 
            },
            vast_wasteland: { 
                name: "Vast Wasteland", width: 2400, height: 1600,
                playerSpawns: [ { x: () => 200, y: () => G_MAP_HEIGHT / 2, angle: 0 }, { x: () => G_MAP_WIDTH - 200, y: () => G_MAP_HEIGHT / 2, angle: Math.PI } ],
                obstacles: [ { x: () => G_MAP_WIDTH/2 - 200, y: () => G_MAP_HEIGHT/2 - 200, w: 400, h: 400, color: '#505050'}, { x: () => G_MAP_WIDTH * 0.25 - 100, y: () => G_MAP_HEIGHT * 0.25 - 100, w: 200, h: 200, color: '#685A2B'}, { x: () => G_MAP_WIDTH * 0.75 - 100, y: () => G_MAP_HEIGHT * 0.25 - 100, w: 200, h: 200, color: '#685A2B'}, { x: () => G_MAP_WIDTH * 0.25 - 100, y: () => G_MAP_HEIGHT * 0.75 - 100, w: 200, h: 200, color: '#685A2B'}, { x: () => G_MAP_WIDTH * 0.75 - 100, y: () => G_MAP_HEIGHT * 0.75 - 100, w: 200, h: 200, color: '#685A2B'}, ...Array.from({length: 30}).map((_,i) => ({ x: () => Math.random() * (G_MAP_WIDTH - 150) + 50, y: () => Math.random() * (G_MAP_HEIGHT - 150) + 50, w: () => Math.random() * 100 + 50, h: () => Math.random() * 100 + 50, color: (Math.random() < 0.6 ? '#7c5c36' : '#6a4220') })) ].filter(obs => { const x = typeof obs.x === 'function' ? obs.x() : obs.x; const y = typeof obs.y === 'function' ? obs.y() : obs.y; if (Math.hypot(x - G_MAP_WIDTH/2, y - G_MAP_HEIGHT/2) < 300 && obs.w < 300) return false; if (Math.hypot(x - 200, y - G_MAP_HEIGHT/2) < 200) return false; if (Math.hypot(x - (G_MAP_WIDTH-200), y - G_MAP_HEIGHT/2) < 200) return false; return true; }),
                bgColor: '#C0A07C' 
            }
        };
        let currentMapId = 'classic';

        const MAX_LEADERBOARD_ENTRIES = 10;


        function loadUserProfiles() {
            const savedProfiles = localStorage.getItem(USER_PROFILES_KEY);
            return savedProfiles ? JSON.parse(savedProfiles) : {};
        }

        function saveUserProfiles(profiles) {
            localStorage.setItem(USER_PROFILES_KEY, JSON.stringify(profiles));
        }
        
        function obfuscatePassword(pass) { return btoa(pass.split("").reverse().join("")); }

        function registerUser(username, password) {
            const profiles = loadUserProfiles();
            if (profiles[username]) {
                return { success: false, message: "Username already exists." };
            }
            if (username.length < 3) return { success: false, message: "Username too short (min 3)." };
            if (password.length < 4) return { success: false, message: "Password too short (min 4)." };

            const defaultData = { 
                username: username, 
                money: 0,
                ownedSkins: ['default'],
                selectedSkinId: 'default',
                gamesPlayed: 0,
                wins: 0,
                losses: 0,
                selectedMapId: 'classic' // Ensure new profiles have a default map
            };
            
            // Lapis Yamz special money - apply directly during registration
            if (username === 'Lapis Yamz') {
                defaultData.money = Math.max(defaultData.money, 1000000); // At least 1 million
            }

            profiles[username] = {
                hashedPassword: obfuscatePassword(password),
                profileData: defaultData
            };
            saveUserProfiles(profiles);
            return { success: true, message: "Registration successful! Please login." };
        }

        function loginUser(username, password) {
            const profiles = loadUserProfiles();
            if (!profiles[username]) {
                return { success: false, message: "Username not found." };
            }
            if (profiles[username].hashedPassword !== obfuscatePassword(password)) {
                return { success: false, message: "Incorrect password." };
            }
            currentUser = username;
            localStorage.setItem(LOGGED_IN_USER_KEY, currentUser); 
            loadPlayerData(); // This will load the profile into currentProfileData

            // Lapis Yamz special money for logged-in user
            if (currentProfileData.username === 'Lapis Yamz') {
                currentProfileData.money = Math.max(currentProfileData.money, 1000000); // Ensure at least 1M
                savePlayerData(); // Save the updated money
            }
            updateUIAfterAuthChange(); // Explicitly call to refresh UI after potential money change
            return { success: true };
        }

        function logoutUser() {
            currentUser = null;
            localStorage.removeItem(LOGGED_IN_USER_KEY); 
            loadPlayerData(); 
            updateUIAfterAuthChange();
        }


        function loadPlayerData() {
            const persistedUser = localStorage.getItem(LOGGED_IN_USER_KEY);
            if (persistedUser) {
                currentUser = persistedUser; 
            }

            const defaultProfileStructure = { 
                username: 'Guest', 
                money: 0,
                ownedSkins: ['default'],
                selectedSkinId: 'default',
                gamesPlayed: 0,
                wins: 0,
                losses: 0,
                selectedMapId: 'classic'
            };

            if (currentUser) {
                const profiles = loadUserProfiles();
                if (profiles[currentUser] && profiles[currentUser].profileData) {
                    // Merge with default structure to ensure all keys exist, prioritizing saved data
                    currentProfileData = { ...defaultProfileStructure, ...profiles[currentUser].profileData, username: currentUser };
                    
                    // Ensure all skins have an ability property, default to null if missing
                    // This part can be removed if SKINS structure is always complete
                    Object.keys(SKINS).forEach(skinId => {
                        if (SKINS[skinId] && SKINS[skinId].ability === undefined) {
                            SKINS[skinId].ability = null;
                        }
                    });
                    if(currentProfileData.ownedSkins && Array.isArray(currentProfileData.ownedSkins)) {
                        currentProfileData.ownedSkins = currentProfileData.ownedSkins.filter(id => SKINS[id]);
                    }
                } else {
                    console.warn("Logged in user profile data not found for", currentUser, "- logging out.");
                    logoutUser(); 
                    return; 
                }
            } else {
                loadGuestData();
            }

            // Ensure base data integrity for currentProfileData
            if (!currentProfileData.ownedSkins || !Array.isArray(currentProfileData.ownedSkins) || currentProfileData.ownedSkins.length === 0) {
                currentProfileData.ownedSkins = ['default'];
            } else if (!currentProfileData.ownedSkins.includes('default')) {
                currentProfileData.ownedSkins.push('default');
            }
            if (!currentProfileData.selectedSkinId || !SKINS[currentProfileData.selectedSkinId] || !currentProfileData.ownedSkins.includes(currentProfileData.selectedSkinId)) {
                currentProfileData.selectedSkinId = 'default';
            }
            if (!MAPS_CONFIG[currentProfileData.selectedMapId]) {
                currentProfileData.selectedMapId = 'classic';
            }
            currentMapId = currentProfileData.selectedMapId;
            
            // Special case for 'Lapis Yamz' as GUEST (10M)
            if (currentProfileData.username === 'Lapis Yamz' && !currentUser) { 
                currentProfileData.money = Math.max(currentProfileData.money, 10000000);
            }
            // For logged-in "Lapis Yamz", the money (1M) is handled in loginUser function.
            
            updateUIAfterAuthChange();
        }

        function loadGuestData() {
            const savedGuestData = localStorage.getItem(GUEST_PROFILE_KEY);
            const defaultGuestProfile = { 
                username: 'Guest', money: 0, ownedSkins: ['default'], 
                selectedSkinId: 'default', gamesPlayed: 0, wins: 0, losses: 0, 
                selectedMapId: 'classic' 
            };
            if (savedGuestData) {
                try {
                    const parsedData = JSON.parse(savedGuestData);
                    currentProfileData = {...defaultGuestProfile, ...parsedData};

                    if (currentProfileData.username !== 'Guest' && !Object.values(loadUserProfiles()).find(p => p.profileData.username === currentProfileData.username)) {
                       // If guest has a custom name that isn't a registered user, it's fine. If it IS a registered user's name, but they are guest, force to "Guest" to avoid confusion.
                       // This logic might need refinement based on desired behavior for guest name clashes. For now, allow custom guest names.
                    }
                } catch (e) {
                    console.error("Error parsing guest data, resetting.", e);
                    currentProfileData = {...defaultGuestProfile}; // Reset to a clean default
                }
            } else {
                 currentProfileData = {...defaultGuestProfile}; // Reset to a clean default
            }
        }


        function savePlayerData() {
            currentProfileData.selectedMapId = currentMapId; 

            if (currentUser) {
                const profiles = loadUserProfiles();
                if (profiles[currentUser]) {
                    profiles[currentUser].profileData = JSON.parse(JSON.stringify(currentProfileData)); 
                    saveUserProfiles(profiles);
                }
            } else { 
                localStorage.setItem(GUEST_PROFILE_KEY, JSON.stringify(currentProfileData));
            }
            updateMoneyDisplay();
            // updateUIAfterAuthChange(); // This can cause re-population loops if not careful. Call it more selectively.
        }

        function updateUIAfterAuthChange() {
            if (currentUser) {
                loggedInUserDisplay.textContent = currentProfileData.username;
                loginRegisterButton.style.display = 'none';
                logoutButton.style.display = 'inline-block';
                usernameInputProfile.value = currentProfileData.username;
                usernameInputProfile.readOnly = false; 
            } else {
                loggedInUserDisplay.textContent = currentProfileData.username; // Display current guest name
                loginRegisterButton.style.display = 'inline-block';
                logoutButton.style.display = 'none';
                usernameInputProfile.value = currentProfileData.username; 
                usernameInputProfile.readOnly = true; // Guest name cannot be changed here for now.
            }
            updateMoneyDisplay();
            populateSkinSelector(); 
            populateMapSelector(); 
            if (profileScreen.classList.contains('active')) {
                populateProfileScreen();
            }
            updateRCBClaimButtonState();
        }


        function populateLeaderboardScreen() {
            if (!leaderboardScreen.classList.contains('active')) return;
            
            const profilesToConsider = loadUserProfiles();
            const guestProfileString = localStorage.getItem(GUEST_PROFILE_KEY);
            let guestProfileData = null;
            if(guestProfileString) {
                try { guestProfileData = JSON.parse(guestProfileString); } catch(e) { console.warn("Corrupt guest data for leaderboard");}
            }

            const entries = Object.values(profilesToConsider).map(p => p.profileData).filter(p => p && typeof p.username === 'string'); 

            if (guestProfileData && guestProfileData.gamesPlayed > 0 && typeof guestProfileData.username === 'string') {
                const guestUsernameLower = guestProfileData.username.toLowerCase();
                // Only add guest if no registered user has the exact same name, OR if the current user IS that guest.
                const guestNameIsRegistered = entries.some(p => p.username.toLowerCase() === guestUsernameLower);
                
                if (!guestNameIsRegistered || (currentUser === null && currentProfileData.username.toLowerCase() === guestUsernameLower)) {
                     if (!entries.find(e => e.username === guestProfileData.username && e !== guestProfileData)) { 
                        entries.push(guestProfileData);
                     }
                }
            }


            const displayLeaderboard = (listElement, data, sortFn, valueFn) => {
                listElement.innerHTML = '';
                const validData = data.filter(entry => {
                    if (valueFn === 'money') return typeof (entry.money || 0) === 'number';
                    if (valueFn === 'wins') return typeof (entry.wins || 0) === 'number';
                    if (valueFn === 'skins') return entry.ownedSkins && typeof entry.ownedSkins.length === 'number';
                    return false;
                });

                const sortedData = [...validData].sort(sortFn).slice(0, MAX_LEADERBOARD_ENTRIES);

                if (sortedData.length === 0) {
                    listElement.innerHTML = '<li>No data yet. Play some games or register!</li>';
                    return;
                }
                sortedData.forEach(entry => {
                    const li = document.createElement('li');
                    const username = entry.username || 'Unknown'; 
                    const skinsCount = entry.ownedSkins ? entry.ownedSkins.length : 0;
                    
                    let displayValue = '';
                    if (valueFn === 'money') displayValue = `$${entry.money || 0}`;
                    else if (valueFn === 'wins') displayValue = `${entry.wins || 0} wins`;
                    else if (valueFn === 'skins') displayValue = `${skinsCount} skin${skinsCount !== 1 ? 's' : ''}`;

                    li.innerHTML = `<span class="username">${username}</span> <span class="score">${displayValue}</span>`;
                    listElement.appendChild(li);
                });
            };

            displayLeaderboard(leaderboardMoneyList, entries, (a, b) => (b.money || 0) - (a.money || 0), 'money');
            displayLeaderboard(leaderboardWinsList, entries, (a, b) => (b.wins || 0) - (a.wins || 0), 'wins');
            displayLeaderboard(leaderboardSkinsList, entries, (a, b) => (b.ownedSkins ? b.ownedSkins.length : 0) - (a.ownedSkins ? a.ownedSkins.length : 0), 'skins');
        }


        function updateGameStats(player1Won) {
            currentProfileData.gamesPlayed = (currentProfileData.gamesPlayed || 0) + 1;
            if (player1Won) {
                currentProfileData.wins = (currentProfileData.wins || 0) + 1;
            } else {
                currentProfileData.losses = (currentProfileData.losses || 0) + 1;
            }
            savePlayerData();
            updateUIAfterAuthChange(); // Refresh profile screen if open
        }

        function updateMoneyDisplay() {
            playerMoneyDisplay.textContent = `$${currentProfileData.money || 0}`;
        }

        function addMoney(amount) {
            currentProfileData.money = (currentProfileData.money || 0) + amount;
            savePlayerData();
            updateUIAfterAuthChange(); // Refresh UI
        }

        let audioCtx;
        let shootGain;
        let musicGainNode; 

        function initAudio() {
            if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                 if (!audioCtx) {
                    console.warn("Web Audio API not supported.");
                    musicToggleButton.disabled = true; 
                    return;
                }
                shootGain = audioCtx.createGain();
                shootGain.connect(audioCtx.destination);
                shootGain.gain.value = 0.06; 

                musicGainNode = audioCtx.createGain();
                musicGainNode.connect(audioCtx.destination);
                musicGainNode.gain.value = 0.15; 
                
                try {
                    const source = audioCtx.createMediaElementSource(menuMusic);
                    source.connect(musicGainNode);
                } catch (e) {
                    console.error("Error connecting media element source for music:", e);
                }
            }
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.warn("Audio context resume failed:", e));
            }
        }
        
        function tryPlayMusic() {
            if (!audioCtx) initAudio();
            if (menuMusic.paused && audioCtx && audioCtx.state === 'running' && menuMusic.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA) {
                menuMusic.play().then(() => {
                    musicPlaying = true;
                    musicToggleButton.textContent = "üéµ Mute";
                }).catch(e => {
                    console.warn("Music play failed:", e);
                    musicPlaying = false;
                    musicToggleButton.textContent = "üéµ Play Music";
                });
            } else if (audioCtx && audioCtx.state === 'suspended') {
                 audioCtx.resume().then(tryPlayMusic); 
            } else if (!menuMusic.paused) { 
                musicPlaying = true;
                musicToggleButton.textContent = "üéµ Mute";
            }
        }

        musicToggleButton.addEventListener('click', () => {
            if (!audioCtx) initAudio(); 
            if (!audioCtx) return; 

            if (musicPlaying) {
                menuMusic.pause();
                musicPlaying = false;
                musicToggleButton.textContent = "üéµ Play Music";
            } else {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume().then(() => { 
                        tryPlayMusic();
                    });
                } else {
                     tryPlayMusic();
                }
            }
        });
        
        function firstInteractionListener() {
            initAudio(); 
            tryPlayMusic(); 
            document.body.removeEventListener('click', firstInteractionListener);
            document.body.removeEventListener('touchstart', firstInteractionListener);
            document.body.removeEventListener('keydown', firstInteractionListener);
        }
        document.body.addEventListener('click', firstInteractionListener, { once: true });
        document.body.addEventListener('touchstart', firstInteractionListener, { once: true });
        document.body.addEventListener('keydown', firstInteractionListener, { once: true }); 


        function playShootSound(skinId = 'default') {
            if (!audioCtx || audioCtx.state === 'suspended') {
                initAudio();
                 if (!audioCtx || audioCtx.state === 'suspended') return;
            }
            try {
                const skinData = SKINS[skinId] || SKINS['default'];
                if (skinData.ability && skinData.ability.type === 'SHIELD_FIREBALL' && this.isAbilityActive && this.abilityEffect === 'fireball_next_shot') {
                    const now = audioCtx.currentTime;
                    const osc = audioCtx.createOscillator(); osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.25);
                    const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.7, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.connect(gain); gain.connect(shootGain); osc.start(now); osc.stop(now + 0.3);
                    const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseBuffer.length; i++) { output[i] = (Math.random() * 2 - 1) * 0.5; }
                    const noiseSource = audioCtx.createBufferSource(); noiseSource.buffer = noiseBuffer;
                    const bandpass = audioCtx.createBiquadFilter(); bandpass.type = 'bandpass'; bandpass.frequency.setValueAtTime(600, now); bandpass.Q.value = 1;
                    const noiseGain = audioCtx.createGain(); noiseGain.gain.setValueAtTime(0, now); noiseGain.gain.linearRampToValueAtTime(0.4, now + 0.05); noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    noiseSource.connect(bandpass); bandpass.connect(noiseGain); noiseGain.connect(shootGain);
                    noiseSource.start(now); noiseSource.stop(now + 0.3);
                } else if (skinId === 'golden_goliath') {
                    const now = audioCtx.currentTime;
                    const osc1 = audioCtx.createOscillator(); osc1.type = 'sawtooth'; osc1.frequency.setValueAtTime(120, now); osc1.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                    const gain1 = audioCtx.createGain(); gain1.gain.setValueAtTime(0.6, now); gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.20);
                    osc1.connect(gain1); gain1.connect(shootGain); osc1.start(now); osc1.stop(now + 0.20);
                    const noiseBuffer = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * 0.25), audioCtx.sampleRate);
                    const output = noiseBuffer.getChannelData(0); for (let i = 0; i < noiseBuffer.length; i++) { output[i] = (Math.random() * 2 - 1) * 0.4; }
                    const noiseSource = audioCtx.createBufferSource(); noiseSource.buffer = noiseBuffer;
                    const bandpass = audioCtx.createBiquadFilter(); bandpass.type = 'bandpass'; bandpass.frequency.setValueAtTime(300, now + 0.02); bandpass.frequency.linearRampToValueAtTime(1500, now + 0.22); bandpass.Q.value = 1.5;
                    const noiseGain = audioCtx.createGain(); noiseGain.gain.setValueAtTime(0.01, now); noiseGain.gain.linearRampToValueAtTime(0.3, now + 0.07); noiseGain.gain.linearRampToValueAtTime(0, now + 0.25);
                    noiseSource.connect(bandpass); bandpass.connect(noiseGain); noiseGain.connect(shootGain); noiseSource.start(now + 0.02); noiseSource.stop(now + 0.27);
                } else {
                    const oscillator = audioCtx.createOscillator(); oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(600, audioCtx.currentTime); oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
                    const gainNode = audioCtx.createGain(); gainNode.gain.setValueAtTime(1, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                    oscillator.connect(gainNode); gainNode.connect(shootGain); oscillator.start(); oscillator.stop(audioCtx.currentTime + 0.11);
                }
            } catch (e) { console.warn("Error playing shoot sound:", e); }
        }

        function normalizeAngle(angle) { angle = angle % (2 * Math.PI); if (angle < 0) angle += (2 * Math.PI); return angle; }
        function getShadedColor(hexColor, percent) { if (!hexColor || !hexColor.startsWith('#')) return '#808080'; let R = parseInt(hexColor.substring(1,3),16); let G = parseInt(hexColor.substring(3,5),16); let B = parseInt(hexColor.substring(5,7),16); R = parseInt(R * (100 + percent) / 100); G = parseInt(G * (100 + percent) / 100); B = parseInt(B * (100 + percent) / 100); R = Math.max(0, Math.min(255, R)); G = Math.max(0, Math.min(255, G)); B = Math.max(0, Math.min(255, B)); const RR = R.toString(16).padStart(2, '0'); const GG = G.toString(16).padStart(2, '0'); const BB = B.toString(16).padStart(2, '0'); return `#${RR}${GG}${BB}`; }


        class Tank { 
            constructor(id, x, y, isAI = false, skinId = 'default', aiDifficulty = 'NORMAL') {
                this.id = id; this.x = x; this.y = y; this.width = TANK_SIZE; this.height = TANK_SIZE;
                this.hullWidth = TANK_SIZE * 0.95; this.hullHeight = TANK_SIZE * 0.65;
                this.angle = (this.id === 'player1') ? Math.PI / 2 : -Math.PI / 2;
                this.turretAngle = this.angle; this.isAI = isAI; this.aiDifficulty = aiDifficulty;
                const skinDataToUse = SKINS[skinId] || SKINS['default']; this.skinId = skinId;
                this.color = skinDataToUse.color; this.bulletColor = skinDataToUse.bulletColor || '#222222';
                this.maxHealth = MAX_HEALTH_BASE * (skinDataToUse.healthMultiplier || 1);
                this.speed = BASE_TANK_SPEED * (skinDataToUse.speedMultiplier || 1);
                this.shootCooldownValue = SHOOT_COOLDOWN_BASE * (skinDataToUse.cooldownMultiplier || 1);
                this.bulletDamage = BASE_BULLET_DAMAGE * (skinDataToUse.damageMultiplier || 1);
                this.skinSpecial = skinDataToUse.special;
                this.healthRegenRate = (this.skinSpecial === 'powerup_duration_boost_regen' ? 0.2 / 60 : 0); 
                if ((this.id === 'player2' || this.id === 'player2_ai') && skinId === 'default') { this.color = SKINS['default'].p2Color; }
                this.health = this.maxHealth;
                if (currentMapId === 'vast_wasteland') { this.speed *= 1.20; }
                this.turnSpeed = TANK_TURN_SPEED; this.turretTurnSpeed = TURRET_TURN_SPEED; this.lastShotTime = 0;
                this.shielded = false; this.shieldTimer = 0; this.speedBoostActive = false; this.speedBoostTimer = 0;
                this.powerUpDurationMultiplier = 1; if (this.skinSpecial === 'powerup_duration_boost_regen' || this.skinSpecial === 'powerup_duration_boost') { this.powerUpDurationMultiplier = 1.30; }
                if (this.skinSpecial === 'starts_shielded_briefly') { this.shielded = true; this.shieldTimer = 6000; }
                if (this.isAI) { this.aiState = 'IDLE'; this.aiTarget = null; this.aiMoveCooldown = 0; this.aiLastPosition = { x: this.x, y: this.y }; this.aiStuckTimer = 0; this.AI_STUCK_THRESHOLD = 1500; this.AI_MIN_MOVE_DIST_FOR_STUCK_CHECK = 0.01; this.aiAimInaccuracyFactor = 0.45; this.aiShootingAngleTolerance = 0.5; this.aiCurrentAimOffset = 0; this.aiNextAimAdjustTimer = 0; this.aiHesitationFactor = 0.25; this.aiPostActionReactionTime = 300; this.aiGeneralReactionTimer = 0; this.aiTargetLostTimer = 0; this.AI_TARGET_LOST_PATROL_THRESHOLD = 4000; this.aiEvadeTimer = 0; this.aiIsDodgingBullet = false; this.currentDodgeAngle = 0; }
                this.hasMovedThisFrame = false;

                this.ability = skinDataToUse.ability ? {...skinDataToUse.ability} : null; 
                this.lastAbilityUseTime = 0;
                this.isAbilityActive = false;
                this.abilityDurationTimer = 0;
                this.abilityEffect = null; 
                this.originalTurretTurnSpeed = this.turretTurnSpeed;


                this.healthBarContainer = document.createElement('div'); this.healthBarContainer.className = 'health-bar-container';
                this.healthBarDiv = document.createElement('div'); this.healthBarDiv.className = 'health-bar'; this.healthBarContainer.appendChild(this.healthBarDiv);
                this.shieldIndicatorDiv = document.createElement('div'); this.shieldIndicatorDiv.className = 'shield-indicator'; this.shieldIndicatorDiv.style.display = 'none'; this.healthBarContainer.appendChild(this.shieldIndicatorDiv);
                uiLayer.appendChild(this.healthBarContainer); this.updateHealthBar(); this.updateHealthBarPosition();
                this.updateSkillButtonDisplay();
            }
            update(normalizedDeltaTime, rawDeltaTime_ms) { 
                if (this.healthRegenRate > 0 && this.health < this.maxHealth) { this.health += this.healthRegenRate * normalizedDeltaTime; if (this.health > this.maxHealth) this.health = this.maxHealth; this.updateHealthBar(); } 
                this.updatePowerUps(rawDeltaTime_ms); 
                this.updateAbility(rawDeltaTime_ms);
                this.updateSkillButtonDisplay(); 
            }
            draw() { ctx.save(); const skinData = SKINS[this.skinId] || SKINS['default']; let isPremiumSkin = skinData.price >= 1000 || this.skinId === 'golden_goliath' || this.skinId === 'phantom'; if (isPremiumSkin && this.skinId !== 'golden_goliath') { let glowColor = 'rgba(255,255,255,0.7)'; if (this.skinId === 'phantom') glowColor = 'rgba(180, 80, 255, 0.7)'; else if (skinData.bulletColor) { const hex = skinData.bulletColor.replace('#', ''); if (hex.length === 6) { const r = parseInt(hex.substring(0,2), 16); const g = parseInt(hex.substring(2,4), 16); const b = parseInt(hex.substring(4,6), 16); if (r > 150 || g > 150 || b > 150) { glowColor = skinData.bulletColor.startsWith('rgba') ? skinData.bulletColor : skinData.bulletColor + 'b3'; } } } ctx.shadowColor = glowColor; ctx.shadowBlur = 12 + Math.sin(Date.now() / 250) * 4; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; } else if (this.skinId === 'golden_goliath') { ctx.shadowColor = 'rgba(255, 215, 0, 0.6)'; ctx.shadowBlur = 15 + Math.sin(Date.now() / 200) * 5; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; } ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); const bodyBaseColor = (this.skinId === 'golden_goliath') ? SKINS.golden_goliath.color : this.color; const trackColor = getShadedColor(bodyBaseColor, -40); const upperHullColor = bodyBaseColor; const detailColor = getShadedColor(bodyBaseColor, -20); const trackHeightActual = this.height * 0.4; const hullHeightActual = this.height * 0.6; const trackOffsetY = hullHeightActual / 2; ctx.fillStyle = trackColor; ctx.fillRect(-this.width / 2, trackOffsetY - trackHeightActual / 2, this.width, trackHeightActual); ctx.strokeStyle = getShadedColor(trackColor, -20); ctx.lineWidth = 2; const numTreads = 5; for (let i = 0; i <= numTreads; i++) { const xPos = -this.width / 2 + (i / numTreads) * this.width; ctx.beginPath(); ctx.moveTo(xPos, trackOffsetY - trackHeightActual / 2); ctx.lineTo(xPos, trackOffsetY + trackHeightActual / 2); ctx.stroke(); } ctx.fillStyle = upperHullColor; ctx.fillRect(-this.hullWidth / 2, -hullHeightActual / 2, this.hullWidth, hullHeightActual); if (this.skinId === 'golden_goliath') { ctx.strokeStyle = '#FFFACD'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(-this.hullWidth / 2, -hullHeightActual / 2); ctx.lineTo(this.hullWidth / 2, -hullHeightActual / 2); ctx.lineTo(this.hullWidth / 2, hullHeightActual / 2 - trackHeightActual*0.1); ctx.stroke(); } else { ctx.strokeStyle = detailColor; ctx.lineWidth = 1.5; ctx.strokeRect(-this.hullWidth / 2, -hullHeightActual / 2, this.hullWidth, hullHeightActual); } ctx.fillStyle = detailColor; ctx.beginPath(); ctx.arc(0, -hullHeightActual * 0.1, TANK_SIZE * 0.1, 0, Math.PI * 2); ctx.fill(); ctx.restore(); ctx.save(); ctx.translate(this.x, this.y); const turretRingColor = getShadedColor(bodyBaseColor, this.skinId === 'golden_goliath' ? -30 : -25); const turretRingRadius = TANK_SIZE * 0.22; ctx.fillStyle = turretRingColor; ctx.beginPath(); ctx.arc(0, 0, turretRingRadius, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = getShadedColor(turretRingColor, -15); ctx.lineWidth = 1; ctx.stroke(); ctx.rotate(this.turretAngle); const turretBaseActualColor = (this.skinId === 'golden_goliath') ? getShadedColor(bodyBaseColor, -5) : getShadedColor(bodyBaseColor, -10); ctx.fillStyle = turretBaseActualColor; ctx.fillRect(0, -TURRET_WIDTH / 2, TURRET_LENGTH, TURRET_WIDTH); if (this.skinId === 'golden_goliath') { ctx.strokeStyle = '#FFEEAA'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -TURRET_WIDTH/2); ctx.lineTo(TURRET_LENGTH, -TURRET_WIDTH/2); ctx.stroke(); } const muzzleColor = getShadedColor(turretBaseActualColor, -15); const muzzleWidth = TURRET_WIDTH * 1.3; const muzzleLength = TURRET_LENGTH * 0.15; ctx.fillStyle = muzzleColor; ctx.fillRect(TURRET_LENGTH, -muzzleWidth / 2, muzzleLength, muzzleWidth); ctx.restore(); if (this.skinId === 'golden_goliath' && this.hasMovedThisFrame) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); const flameLengthBase = TANK_SIZE * 0.45; const flameWidthBase = TANK_SIZE * 0.3; const pulse = Math.sin(Date.now() / 70) * 0.20 + 0.80; let flameLength = flameLengthBase * pulse; let flameWidth = flameWidthBase * pulse; if (this.speedBoostActive) { flameLength *= 1.6; flameWidth *= 1.4; } const flameOffsetX = -this.hullWidth / 2 - flameLength / 2 + 3; ctx.globalAlpha = 0.6 + Math.random() * 0.3; ctx.fillStyle = `rgba(255, 80, 0, ${ctx.globalAlpha})`; ctx.beginPath(); ctx.moveTo(flameOffsetX, -flameWidth / 2.5); ctx.bezierCurveTo(flameOffsetX - flameLength * 0.6, -flameWidth / 3, flameOffsetX - flameLength * 0.8, 0, flameOffsetX - flameLength, 0); ctx.bezierCurveTo(flameOffsetX - flameLength * 0.8, flameWidth / 3, flameOffsetX - flameLength * 0.6, flameWidth / 2.5, flameOffsetX, flameWidth / 2.5); ctx.closePath(); ctx.fill(); flameLength *= 0.55; flameWidth *= 0.55; ctx.globalAlpha = 0.75 + Math.random() * 0.2; ctx.fillStyle = `rgba(255, 200, 80, ${ctx.globalAlpha})`; ctx.beginPath(); ctx.moveTo(flameOffsetX, -flameWidth / 2.5); ctx.bezierCurveTo(flameOffsetX - flameLength * 0.6, -flameWidth / 3, flameOffsetX - flameLength * 0.8, 0, flameOffsetX - flameLength, 0); ctx.bezierCurveTo(flameOffsetX - flameLength * 0.8, flameWidth / 3, flameOffsetX - flameLength * 0.6, flameWidth / 2.5, flameOffsetX, flameWidth / 2.5); ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1.0; ctx.restore(); } ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.restore(); if (this.shielded) { ctx.save(); ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.2; ctx.translate(this.x, this.y); ctx.strokeStyle = 'deepskyblue'; ctx.lineWidth = 4; ctx.shadowColor = 'rgba(0, 191, 255, 0.8)'; ctx.shadowBlur = 10 + Math.sin(Date.now() / 150) * 5; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; ctx.beginPath(); ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 8, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); } this.updateHealthBarPosition(); }
            updateHealthBarPosition() { const barX = (this.x - this.width / 2); const barY = (this.y - this.height / 2 - 15 - (this.height * 0.1)); this.healthBarContainer.style.left = barX + 'px'; this.healthBarContainer.style.top = barY + 'px'; }
            updateHealthBar() { const healthPercentage = (this.health / this.maxHealth) * 100; this.healthBarDiv.style.width = healthPercentage + '%'; if (healthPercentage <= 0) this.healthBarDiv.style.backgroundColor = 'black'; else if (healthPercentage < 30) this.healthBarDiv.style.backgroundColor = 'red'; else if (healthPercentage < 60) this.healthBarDiv.style.backgroundColor = 'orange'; else this.healthBarDiv.style.backgroundColor = 'limegreen'; this.shieldIndicatorDiv.style.display = this.shielded ? 'block' : 'none'; }
            move(direction) { const currentSpeed = this.speed * (this.speedBoostActive ? (this.ability && this.ability.type === 'HEAL_SPEED' && this.isAbilityActive ? this.ability.speedBoostMultiplier : 1.7) : 1); const prevX = this.x; const prevY = this.y; const hitBoxWidth = this.width * 0.9; const hitBoxHeight = this.height * 0.9; const newXUnchecked = this.x + direction * currentSpeed * Math.cos(this.angle); const newYUnchecked = this.y + direction * currentSpeed * Math.sin(this.angle); this.x = newXUnchecked; if (this.checkCollision(this.x, prevY, hitBoxWidth, hitBoxHeight) || this.checkBoundaryCollisionX()) { this.x = prevX; } this.y = newYUnchecked; if (this.checkCollision(prevX, this.y, hitBoxWidth, hitBoxHeight) || this.checkBoundaryCollisionY()) { this.y = prevY; } if(this.x !== prevX && this.y !== prevY && this.checkCollision(this.x, this.y, hitBoxWidth, hitBoxHeight)){ this.x = prevX; this.y = prevY; } if (direction !== 0 && (this.x !== prevX || this.y !== prevY)) { this.hasMovedThisFrame = true; } }
            checkBoundaryCollisionX() { return (this.x - this.width / 2 < 0 || this.x + this.width / 2 > G_MAP_WIDTH); }
            checkBoundaryCollisionY() { return (this.y - this.height / 2 < 0 || this.y + this.height / 2 > G_MAP_HEIGHT); }
            rotateBody(direction) { this.angle += direction * this.turnSpeed; if (direction !== 0) this.hasMovedThisFrame = true; }
            rotateTurret(direction) { this.turretAngle += direction * this.turretTurnSpeed; }
            setTurretAngle(targetAngle) { let current = (this.turretAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI); let target = (targetAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI); let diff = target - current; if (diff > Math.PI) diff -= 2 * Math.PI; if (diff < -Math.PI) diff += 2 * Math.PI; if (Math.abs(diff) < this.turretTurnSpeed * 1.1) { this.turretAngle = targetAngle; } else { this.turretAngle += Math.sign(diff) * this.turretTurnSpeed; } }
            shoot() { 
                const currentTime = Date.now(); 
                if (currentTime - this.lastShotTime > this.shootCooldownValue) { 
                    const muzzleLength = TURRET_LENGTH * 0.15; 
                    const bulletStartX = this.x + (TURRET_LENGTH + muzzleLength) * Math.cos(this.turretAngle); 
                    const bulletStartY = this.y + (TURRET_LENGTH + muzzleLength) * Math.sin(this.turretAngle); 
                    
                    let currentBulletDamage = this.bulletDamage;
                    let bulletType = 'normal';

                    if (this.ability && this.ability.type === 'SHIELD_FIREBALL' && this.isAbilityActive && this.abilityEffect === 'fireball_next_shot') {
                        currentBulletDamage *= this.ability.fireballDamageMultiplier;
                        bulletType = 'fireball';
                        this.abilityEffect = null; 
                    }
                    
                    bullets.push(new Bullet(bulletStartX, bulletStartY, this.turretAngle, this, currentBulletDamage, this.bulletColor, bulletType)); 
                    this.lastShotTime = currentTime; 
                    playShootSound.call(this, this.skinId); 
                    return true; 
                } return false; 
            }
            takeDamage(amount) { if (this.shielded) return; this.health -= amount; this.updateHealthBar(); if (this.health <= 0) { this.health = 0; this.destroy(); } else if (this.isAI && this.aiDifficulty === "FREESTYLE" && this.aiEvadeTimer <= 0) { this.aiState = "EVADING"; this.aiEvadeTimer = 300 + Math.random() * 300; } }
            destroy() { this.updateHealthBar(); const p1Wins = (this === player2); const p2Wins = (this === player1); if (p1Wins) { let message = "Player 1 Wins!"; if (gameMode === 'vsCPU') { let reward = 0; switch(currentAiDifficulty) { case 'EASY': reward = 5; break; case 'NORMAL': reward = 10; break; case 'HARD': reward = 20; break; case 'FREESTYLE': reward = 30; break; } addMoney(reward); message += ` You earned $${reward}!`; } updateGameStats(true); endGame(message); } else if (p2Wins) { updateGameStats(false); endGame(gameMode === 'vsCPU' ? `${currentAiDifficulty} AI Wins!` : "Player 2 Wins!"); } }
            checkCollision(checkX, checkY, colWidth = this.width, colHeight = this.height) { const tankRect = { x: checkX - colWidth / 2, y: checkY - colHeight / 2, width: colWidth, height: colHeight }; for (const obs of obstacles) { if (rectIntersect(tankRect, obs)) return true; } const otherTank = (this === player1 && player2) ? player2 : (this === player2 && player1) ? player1 : null; if(otherTank && otherTank.health > 0) { const otherTankRect = { x: otherTank.x - otherTank.width / 2, y: otherTank.y - otherTank.height / 2, width: otherTank.width, height: otherTank.height }; if (rectIntersect(tankRect, otherTankRect)) return true; } return false; }
            applyPowerUp(type) { const duration = POWERUP_DURATION_BASE * this.powerUpDurationMultiplier; if (type === 'shield') { this.shielded = true; this.shieldTimer = duration; this.shieldIndicatorDiv.style.display = 'block'; } else if (type === 'speed') { this.speedBoostActive = true; this.speedBoostTimer = duration; } else if (type === 'health') { this.health = Math.min(this.maxHealth, this.health + (MAX_HEALTH_BASE * 0.4)); this.updateHealthBar(); } }
            updatePowerUps(rawDeltaTime_ms) { if (this.shielded) { this.shieldTimer -= rawDeltaTime_ms; if (this.shieldTimer <= 0) { this.shielded = false; this.shieldTimer = 0; this.shieldIndicatorDiv.style.display = 'none'; } } if (this.speedBoostActive) { this.speedBoostTimer -= rawDeltaTime_ms; if (this.speedBoostTimer <= 0) { this.speedBoostActive = false; this.speedBoostTimer = 0; } } }
            
            canUseAbility() {
                if (!this.ability) return false;
                return Date.now() - this.lastAbilityUseTime >= this.ability.cooldown;
            }
            activateAbility() {
                if (!this.canUseAbility()) return;
                this.lastAbilityUseTime = Date.now();
                this.isAbilityActive = true;

                switch(this.ability.type) {
                    case 'HEAL_SPEED': 
                        this.health = Math.min(this.maxHealth, this.health + this.ability.healAmount);
                        this.updateHealthBar();
                        this.speedBoostActive = true; 
                        this.speedBoostTimer = this.ability.speedBoostDuration; 
                        this.abilityDurationTimer = this.ability.speedBoostDuration; 
                        break;
                    case 'SHIELD_FIREBALL': 
                        this.shielded = true;
                        this.shieldTimer = this.ability.shieldDuration;
                        this.abilityEffect = 'fireball_next_shot'; 
                        this.abilityDurationTimer = this.ability.shieldDuration; 
                        break;
                    case 'QUICK_AIM': 
                        this.originalTurretTurnSpeed = this.turretTurnSpeed;
                        this.turretTurnSpeed *= 3; 
                        this.abilityDurationTimer = this.ability.duration;
                        break;
                }
                this.updateSkillButtonDisplay();
            }
            updateAbility(rawDeltaTime_ms) {
                if (this.isAbilityActive) {
                    this.abilityDurationTimer -= rawDeltaTime_ms;
                    if (this.abilityDurationTimer <= 0) {
                        this.isAbilityActive = false;
                        this.abilityDurationTimer = 0;
                        if (this.ability.type === 'QUICK_AIM') {
                            this.turretTurnSpeed = this.originalTurretTurnSpeed;
                        }
                        this.abilityEffect = null;
                    }
                }
            }
            updateSkillButtonDisplay() {
                let skillButtonElem;
                if (this.id === 'player1') skillButtonElem = skillButtonP1;
                else if (this.id === 'player2') skillButtonElem = skillButtonP2;
                else return; 

                const cooldownTextElem = skillButtonElem.querySelector('.cooldown-text');

                if (!this.ability) {
                    if (this.id === 'player1') skillButtonContainerP1.style.display = 'none';
                    if (this.id === 'player2') skillButtonContainerP2.style.display = 'none';
                    return;
                }
                
                if (this.id === 'player1') skillButtonContainerP1.style.display = 'flex';
                if (this.id === 'player2') skillButtonContainerP2.style.display = 'flex';


                if (this.canUseAbility() && !this.isAbilityActive) {
                    skillButtonElem.classList.remove('on-cooldown');
                    skillButtonElem.disabled = false;
                    cooldownTextElem.textContent = "";
                    skillButtonElem.childNodes[0].nodeValue = this.ability.name.toUpperCase() + " "; 
                } else {
                    skillButtonElem.classList.add('on-cooldown');
                    skillButtonElem.disabled = true;
                    let remainingCooldown = 0;
                    if (this.isAbilityActive) {
                         remainingCooldown = Math.ceil(this.abilityDurationTimer / 1000);
                         skillButtonElem.childNodes[0].nodeValue = "ACTIVE ";
                    } else {
                         remainingCooldown = Math.ceil((this.ability.cooldown - (Date.now() - this.lastAbilityUseTime)) / 1000);
                         skillButtonElem.childNodes[0].nodeValue = this.ability.name.toUpperCase() + " ";
                    }
                    cooldownTextElem.textContent = remainingCooldown > 0 ? `${remainingCooldown}s` : "RDY";
                     if (remainingCooldown <=0 && !this.isAbilityActive) { 
                        skillButtonElem.classList.remove('on-cooldown');
                        skillButtonElem.disabled = false;
                        cooldownTextElem.textContent = "";
                    }
                }
            }


            findClosestIncomingBullet(allBullets) { let closestBullet = null; let minDistance = Infinity; for (const bullet of allBullets) { if (bullet.owner === this) continue; const dist = Math.hypot(this.x - bullet.x, this.y - bullet.y); if (dist < minDistance) { const dx = this.x - bullet.x; const dy = this.y - bullet.y; const dotProduct = dx * Math.cos(bullet.angle) + dy * Math.sin(bullet.angle); if (dotProduct > 0) { minDistance = dist; closestBullet = bullet; } } } return closestBullet; }
            setAIDifficultyParameters() { switch(this.aiDifficulty) { case 'EASY': this.aiAimInaccuracyFactor = 0.8; this.aiShootingAngleTolerance = 0.8; this.aiHesitationFactor = 0.6; this.aiPostActionReactionTime = 500; this.turretTurnSpeed = TURRET_TURN_SPEED * 0.7; break; case 'NORMAL': this.aiAimInaccuracyFactor = 0.4; this.aiShootingAngleTolerance = 0.45; this.aiHesitationFactor = 0.2; this.aiPostActionReactionTime = 250; this.turretTurnSpeed = TURRET_TURN_SPEED * 0.9; break; case 'HARD': this.aiAimInaccuracyFactor = 0.1; this.aiShootingAngleTolerance = 0.15; this.aiHesitationFactor = 0.03; this.aiPostActionReactionTime = 120; this.turretTurnSpeed = TURRET_TURN_SPEED * 1.1; break; case 'FREESTYLE': this.aiAimInaccuracyFactor = 0.005; this.aiShootingAngleTolerance = 0.03; this.aiHesitationFactor = 0; this.aiPostActionReactionTime = 25; this.AI_STUCK_THRESHOLD = 700; this.turretTurnSpeed = TURRET_TURN_SPEED * 1.3; break; } }
            aiAttemptShoot(targetAngle, targetIsShielded) { if (this.aiGeneralReactionTimer > 0) return; if (targetIsShielded && Math.random() < (this.aiDifficulty === 'EASY' ? 0.95 : (this.aiDifficulty === 'NORMAL' ? 0.8 : 0.6)) ) return; let turretNormalized = normalizeAngle(this.turretAngle); let targetNormalized = normalizeAngle(targetAngle); let diff = targetNormalized - turretNormalized; if (diff > Math.PI) diff -= 2 * Math.PI; if (diff < -Math.PI) diff += 2 * Math.PI; if (Math.abs(diff) < this.aiShootingAngleTolerance) { if (Math.random() > this.aiHesitationFactor) this.shoot(); this.aiGeneralReactionTimer = this.aiPostActionReactionTime + Math.random() * (this.aiDifficulty === 'EASY' ? 350 : (this.aiDifficulty === "FREESTYLE" ? 40 : 180) ); } }
            updateAI(deltaTime, targetTank) { if (!this.isAI || !targetTank || targetTank.health <= 0 || this.health <= 0) return; this.setAIDifficultyParameters(); this.aiTarget = targetTank; this.aiMoveCooldown -= deltaTime; if (this.aiEvadeTimer > 0) this.aiEvadeTimer -= deltaTime; if (this.aiGeneralReactionTimer > 0) this.aiGeneralReactionTimer -= deltaTime; this.aiNextAimAdjustTimer -= deltaTime; const distMovedSqr = (this.x - this.aiLastPosition.x)**2 + (this.y - this.aiLastPosition.y)**2; if (distMovedSqr < this.AI_MIN_MOVE_DIST_FOR_STUCK_CHECK) { this.aiStuckTimer += deltaTime; } else { this.aiStuckTimer = 0; } this.aiLastPosition = { x: this.x, y: this.y }; if (this.aiStuckTimer > this.AI_STUCK_THRESHOLD) { this.angle = normalizeAngle(this.angle + (Math.random() - 0.5) * Math.PI * 1.5); this.move(Math.random() < 0.6 ? -0.8 : 0.8); this.aiState = 'IDLE'; this.aiStuckTimer = 0; this.aiMoveCooldown = 200 + Math.random() * 200; this.aiTargetLostTimer = 0; return; } if (this.aiDifficulty === "FREESTYLE") { this.aiCurrentAimOffset = (Math.random() - 0.5) * 0.01; } else if (this.aiNextAimAdjustTimer <= 0) { this.aiCurrentAimOffset = (Math.random() - 0.5) * 2 * this.aiAimInaccuracyFactor; this.aiNextAimAdjustTimer = 500 + Math.random() * (this.aiDifficulty === 'EASY' ? 900 : 600); } const trueAngleToTarget = Math.atan2(targetTank.y - this.y, targetTank.x - this.x); let effectiveAimAngle = trueAngleToTarget + this.aiCurrentAimOffset; if (this.aiDifficulty === "FREESTYLE" && targetTank.speed > 0.01 && targetTank.hasMovedThisFrame) { const distToTargetForPred = Math.hypot(targetTank.x - this.x, targetTank.y - this.y); const timeToBulletHit = distToTargetForPred / BULLET_SPEED_BASE; const targetCurrentSpeedValue = targetTank.speed * (targetTank.speedBoostActive ? 1.7 : 1); const predictedTargetX = targetTank.x + Math.cos(targetTank.angle) * targetCurrentSpeedValue * timeToBulletHit; const predictedTargetY = targetTank.y + Math.sin(targetTank.angle) * targetCurrentSpeedValue * timeToBulletHit; effectiveAimAngle = Math.atan2(predictedTargetY - this.y, predictedTargetX - this.x) + this.aiCurrentAimOffset; } const distanceToTarget = Math.hypot(this.x - targetTank.x, this.y - targetTank.y); const canSee = this.canSeeTarget(targetTank); let closestPowerUp = null; let minDistToPowerUp = Infinity; if (canSee) this.aiTargetLostTimer = 0; else this.aiTargetLostTimer += deltaTime; if (this.aiDifficulty === "FREESTYLE" && this.aiEvadeTimer <= 0 && this.aiGeneralReactionTimer <= 0) { let incomingBullet = this.findClosestIncomingBullet(bullets); if (incomingBullet) { const B_DIST_THRESHOLD = this.width * (this.aiDifficulty === "FREESTYLE" ? 6 : 4.5); const B_ANGLE_THRESHOLD = Math.PI / (this.aiDifficulty === "FREESTYLE" ? 3.0 : 3.8); const distToBullet = Math.hypot(this.x - incomingBullet.x, this.y - incomingBullet.y); if (distToBullet < B_DIST_THRESHOLD) { const angleFromBulletToTank = Math.atan2(this.y - incomingBullet.y, this.x - incomingBullet.x); let angleDiff = Math.abs(normalizeAngle(incomingBullet.angle - angleFromBulletToTank)); if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff; if (angleDiff < B_ANGLE_THRESHOLD) { this.aiState = "EVADING"; this.aiEvadeTimer = (this.aiDifficulty === "FREESTYLE" ? 200 : 280) + Math.random() * 120; this.currentDodgeAngle = normalizeAngle(incomingBullet.angle + (Math.random() < 0.5 ? Math.PI / 1.8 : -Math.PI / 1.8)); this.aiIsDodgingBullet = true; this.aiMoveCooldown = 40; } } } } const seekPowerUpChance = this.aiDifficulty === 'EASY' ? 0.15 : (this.aiDifficulty === 'NORMAL' ? 0.35 : 0.75); if (this.health < this.maxHealth * (this.aiDifficulty === 'EASY' ? 0.9 : (this.aiDifficulty === "FREESTYLE" ? 0.85 : 0.75)) || (!this.shielded && Math.random() < seekPowerUpChance)) { powerUps.forEach(p => { if (p.active) { const dist = Math.hypot(this.x - p.x, this.y - p.y); if (dist < minDistToPowerUp) { minDistToPowerUp = dist; closestPowerUp = p; } } }); } if (this.aiState === "EVADING" && this.aiEvadeTimer > 0) { /* Stay in evading */ } else if (this.aiTargetLostTimer > this.AI_TARGET_LOST_PATROL_THRESHOLD && this.aiDifficulty !== 'EASY') { this.aiState = 'PATROLLING'; } else if (closestPowerUp && minDistToPowerUp < G_MAP_WIDTH / (this.aiDifficulty === 'EASY' ? 5.5 : (this.aiDifficulty === "FREESTYLE" ? 2.8 : 3.2)) && (this.health < this.maxHealth * (this.aiDifficulty === 'EASY' ? 0.85 : (this.aiDifficulty === "FREESTYLE" ? 0.75 : 0.65)) || (closestPowerUp.type === 'shield' && !this.shielded && Math.random() < (this.aiDifficulty === 'EASY' ? 0.25 : (this.aiDifficulty === "FREESTYLE" ? 0.85 : 0.65))))) { this.aiState = 'SEEKING_POWERUP'; } else if (canSee && distanceToTarget < this.width * (this.aiDifficulty === 'FREESTYLE' ? 7.5 : 5.5) ) { this.aiState = 'ATTACKING_CLOSE'; } else if (canSee && distanceToTarget < G_MAP_WIDTH / (this.aiDifficulty === 'FREESTYLE' ? 1.2 : 1.8)) { this.aiState = 'ATTACKING_RANGED'; } else if (distanceToTarget > G_MAP_WIDTH / 1.2 && this.aiDifficulty !== 'EASY') { this.aiState = 'SEEKING_PLAYER'; } else if (!canSee && this.aiMoveCooldown <=0 && this.aiDifficulty !== 'EASY' && this.aiState !== 'PATROLLING') { this.aiState = 'REPOSITIONING'; } else if (this.aiMoveCooldown <=0 && this.aiState !== 'PATROLLING' && this.aiState !== "EVADING") { this.aiState = 'IDLE'; } if (this.aiState === "EVADING" && this.aiEvadeTimer > 0) { this.setTurretAngle(effectiveAimAngle); if (this.aiMoveCooldown <= 0) { let moveDir = 1; if (this.aiIsDodgingBullet) { this.angle = this.currentDodgeAngle; } else { this.angle = normalizeAngle(trueAngleToTarget + Math.PI + (Math.random() - 0.5) * Math.PI/1.8); } if (!this.isPathClear(this.angle, this.speed * 1.6, targetTank)) { if (!this.isPathClear(this.angle, -this.speed * 1.6, targetTank)) { this.aiSmartTurn(this.angle, targetTank); if(this.isPathClear(this.angle, this.speed * 0.6, targetTank)) this.move(0.6); } else { moveDir = -1; this.move(moveDir * 1.1); } } else { this.move(moveDir * 1.4); } this.aiIsDodgingBullet = false; this.aiMoveCooldown = 80 + Math.random() * 80; } if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); return; } switch(this.aiState) { case 'PATROLLING': this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.25); if (this.aiMoveCooldown <= 0) { this.aiSmartTurn(this.angle + (Math.random() -0.7) * Math.PI / 2.2, targetTank); this.move(0.55 + Math.random()*0.25); this.aiMoveCooldown = Math.random() * 1700 + 900; } if (canSee) { this.aiTargetLostTimer = 0; this.aiState = 'ATTACKING_RANGED'; } break; case 'SEEKING_POWERUP': const angleToPowerUp = Math.atan2(closestPowerUp.y - this.y, closestPowerUp.x - this.x); this.setTurretAngle(canSee ? effectiveAimAngle : angleToPowerUp); if (!this.isPathClearToPoint(closestPowerUp.x, closestPowerUp.y, targetTank)) { this.aiSmartTurn(angleToPowerUp, targetTank); if(this.isPathClear(this.angle, this.speed * 0.85, targetTank)) this.move(0.55); } else { this.angle = angleToPowerUp; this.move(1.05); } if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); break; case 'ATTACKING_CLOSE': this.setTurretAngle(effectiveAimAngle); this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); if (this.aiMoveCooldown <= 0) { let strafeAngle = normalizeAngle(trueAngleToTarget + (Math.random() < 0.5 ? Math.PI/2.1 : -Math.PI/2.1)); if (this.aiDifficulty === "FREESTYLE" && distanceToTarget < this.width * 2.5) { strafeAngle = normalizeAngle(trueAngleToTarget + Math.PI); } if(this.isPathClear(strafeAngle, this.width*1.6, targetTank)){ this.angle = strafeAngle; this.move(0.75 + Math.random()*0.25); } else { this.aiSmartTurn(strafeAngle, targetTank); if(this.isPathClear(this.angle, this.speed*0.85, targetTank)) this.move(0.55 + Math.random()*0.25); } this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 900 : (this.aiDifficulty === "FREESTYLE" ? 200 : 600)) + (this.aiDifficulty === 'EASY' ? 450 : (this.aiDifficulty === "FREESTYLE" ? 80 : 250)); } break; case 'ATTACKING_RANGED': this.setTurretAngle(effectiveAimAngle); this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); if (this.aiMoveCooldown <= 0) { if (this.aiDifficulty === "FREESTYLE") { if (Math.random() < 0.92) { let moveAngleOffset = (Math.random() - 0.5) * Math.PI / 1.7; if (Math.random() < 0.38) { moveAngleOffset = (distanceToTarget > G_MAP_WIDTH / 2.3) ? 0 : Math.PI; } const intendedMoveAngle = normalizeAngle(trueAngleToTarget + moveAngleOffset); if (this.isPathClear(intendedMoveAngle, this.speed * 2.1, targetTank)) { this.angle = intendedMoveAngle; this.move(0.65 + Math.random() * 0.35); } else { this.aiSmartTurn(trueAngleToTarget, targetTank); if (this.isPathClear(this.angle, this.speed * 1.1, targetTank)) this.move(0.35); } } } else if (Math.random() < (this.aiDifficulty === 'EASY' ? 0.15 : 0.35)) { this.aiSmartTurn(trueAngleToTarget + (Math.random()-0.5) * Math.PI / 2.8, targetTank); if(this.isPathClear(this.angle, this.speed * 0.55, targetTank)) this.move(0.25 + Math.random()*0.25); } this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 1100 : (this.aiDifficulty === "FREESTYLE" ? 280 : 800)) + (this.aiDifficulty === 'EASY' ? 650 : (this.aiDifficulty === "FREESTYLE" ? 130 : 450)); } break; case 'SEEKING_PLAYER': this.setTurretAngle(effectiveAimAngle); if (!this.isPathClearToPoint(targetTank.x, targetTank.y, targetTank, this.width*2.8)) { this.aiSmartTurn(trueAngleToTarget, targetTank); if(this.isPathClear(this.angle, this.speed * 0.85, targetTank)) this.move(0.65 + Math.random()*0.25); } else { this.angle = trueAngleToTarget; this.move(0.95 + Math.random()*0.25); } if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); break; case 'REPOSITIONING': this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.4 ); if (this.aiMoveCooldown <= 0) { this.aiSmartTurn(this.angle + (Math.random() - 0.5) * Math.PI / 1.9, targetTank); if(this.isPathClear(this.angle, this.speed * 0.85, targetTank)) this.move(0.75 + Math.random()*0.35); this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 800 : (this.aiDifficulty === "FREESTYLE" ? 200 : 450)) + (this.aiDifficulty === 'EASY' ? 350 : (this.aiDifficulty === "FREESTYLE" ? 70 : 180)); } break; case 'IDLE': default: this.setTurretAngle(this.turretAngle + (Math.random()-0.5)*0.2); if (this.aiMoveCooldown <= 0) { if (Math.random() < (this.aiDifficulty === 'EASY' ? 0.35 : (this.aiDifficulty === "FREESTYLE" ? 0.8 : 0.6))) { this.aiSmartTurn(this.angle + (Math.random() - 0.5) * Math.PI / (this.aiDifficulty === "FREESTYLE" ? 1.1 : 1.7), targetTank); if(this.isPathClear(this.angle, this.speed * 0.65, targetTank)) this.move(0.45 + Math.random() * (this.aiDifficulty === "FREESTYLE" ? 0.55 : 0.25)); } this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 1700 : (this.aiDifficulty === "FREESTYLE" ? 350 : 1200)) + (this.aiDifficulty === 'EASY' ? 900 : (this.aiDifficulty === "FREESTYLE" ? 180 : 600)); } break; } if(this.aiMoveCooldown <= 0 && this.aiState !== 'EVADING') { this.aiSmartTurn(this.angle + (Math.random() - 0.5) * 0.35, targetTank); if (Math.random() < 0.25 && this.isPathClear(this.angle, this.speed * 0.55, targetTank)) this.move(0.35); this.aiMoveCooldown = 180 + Math.random() * 180; } }
            aiSmartTurn(desiredAngle, targetTankToAvoid = null) { let bestTurn = 0; let maxClearDistance = 0; const anglesToTest = [0, Math.PI / 6, -Math.PI / 6, Math.PI / 3, -Math.PI / 3, Math.PI / 2, -Math.PI / 2, 2*Math.PI/3, -2*Math.PI/3, Math.PI*0.9]; for (const offset of anglesToTest) { const testAngle = normalizeAngle(desiredAngle + offset); let currentPathClearDistance = 0; for (let d = this.width * 0.6; d <= this.width * 4.5; d += this.width * 0.6) { if (this.isPathClear(testAngle, d, targetTankToAvoid)) { currentPathClearDistance = d; } else { break; } } if (currentPathClearDistance > maxClearDistance) { maxClearDistance = currentPathClearDistance; bestTurn = testAngle; } } if (maxClearDistance > this.width * 0.6) { this.angle = bestTurn; } else { this.angle = normalizeAngle(desiredAngle + (Math.random() < 0.5 ? Math.PI * 0.8 : -Math.PI * 0.8) + (Math.random() - 0.5) * 0.6); } }
            isPathClear(angle, distance, otherTankToAvoid = null) { const checkFeelerCount = 3; const feelerOffsetDist = this.width / 3.3; const cosAngle = Math.cos(angle); const sinAngle = Math.sin(angle); const cosPerp = Math.cos(angle + Math.PI / 2); const sinPerp = Math.sin(angle + Math.PI / 2); for (let i = 0; i < checkFeelerCount; i++) { let offsetX = 0; let offsetY = 0; if (i === 1) { offsetX = feelerOffsetDist * cosPerp; offsetY = feelerOffsetDist * sinPerp; } else if (i === 2) { offsetX = -feelerOffsetDist * cosPerp; offsetY = -feelerOffsetDist * sinPerp; } const projectedRectCenterX = this.x + offsetX + distance * cosAngle; const projectedRectCenterY = this.y + offsetY + distance * sinAngle; const projectedRect = { x: projectedRectCenterX - this.width / 3.8, y: projectedRectCenterY - this.height / 3.8, width: this.width / 1.9, height: this.height / 1.9 }; if (projectedRect.x < 0 || projectedRect.x + projectedRect.width > G_MAP_WIDTH || projectedRect.y < 0 || projectedRect.y + projectedRect.height > G_MAP_HEIGHT) { return false; } for (const obs of obstacles) { if (rectIntersect(projectedRect, obs)) return false; } if (otherTankToAvoid && otherTankToAvoid.health > 0 && otherTankToAvoid !== this) { const otherTankHitbox = { x: otherTankToAvoid.x - otherTankToAvoid.width / 2, y: otherTankToAvoid.y - otherTankToAvoid.height / 2, width: otherTankToAvoid.width, height: otherTankToAvoid.height }; if (rectIntersect(projectedRect, otherTankHitbox)) return false; } } return true; }
            isPathClearToPoint(targetX, targetY, otherTankToAvoid = null, maxDist = G_MAP_WIDTH * 1.5) { const dx = targetX - this.x; const dy = targetY - this.y; const distToTarget = Math.hypot(dx, dy); if (distToTarget === 0) return true; if (maxDist > 0 && distToTarget > maxDist) return false; const angleToTarget = Math.atan2(dy, dx); const checkDist = Math.max(0, distToTarget - (this.width / 1.8) - (otherTankToAvoid ? otherTankToAvoid.width / 1.8 : 0)); return this.isPathClear(angleToTarget, checkDist, otherTankToAvoid); }
            canSeeTarget(target) { if (!target || target.health <= 0) return false; return this.isPathClearToPoint(target.x, target.y, target); }
        }
        class Bullet { 
            constructor(x, y, angle, owner, damage = BASE_BULLET_DAMAGE, color = '#222222', type = 'normal') { 
                this.x = x; this.y = y; this.angle = angle; this.speed = BULLET_SPEED_BASE; 
                this.size = BULLET_SIZE; this.owner = owner; this.damage = damage; 
                this.color = color; this.type = type;
                if (this.type === 'fireball') {
                    this.speed *= 0.85; 
                    this.size *= 2.2;
                }
            }
            draw() { 
                ctx.save(); 
                if (this.type === 'fireball') {
                    const pulse = 0.8 + Math.abs(Math.sin(Date.now() / 150)) * 0.4;
                    const currentSize = this.size * pulse;
                    ctx.translate(this.x, this.y);
                    ctx.beginPath();
                    ctx.arc(0, 0, currentSize * 0.7, 0, Math.PI * 2);
                    const gradGlow = ctx.createRadialGradient(0, 0, currentSize * 0.2, 0, 0, currentSize * 0.7);
                    gradGlow.addColorStop(0, 'rgba(255, 100, 0, 0.6)');
                    gradGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = gradGlow;
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, 0, currentSize * 0.4, 0, Math.PI * 2);
                    const gradCore = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.4);
                    gradCore.addColorStop(0, 'rgba(255, 220, 180, 1)');
                    gradCore.addColorStop(0.5, 'rgba(255, 150, 50, 1)');
                    gradCore.addColorStop(1, 'rgba(200, 50, 0, 0.8)');
                    ctx.fillStyle = gradCore;
                    ctx.shadowColor = 'rgba(255,100,0,0.7)';
                    ctx.shadowBlur = 10 + Math.sin(Date.now() / 80) * 4;
                    ctx.fill();
                } else if (this.owner && this.owner.skinId === 'golden_goliath') { 
                    const missileVisualLength = BULLET_SIZE * 4.0; const missileVisualWidth = BULLET_SIZE * 1.5; const glowPulse = Math.sin(Date.now() / 120) * 5; ctx.shadowColor = 'rgba(255, 120, 0, 0.9)'; ctx.shadowBlur = 12 + glowPulse; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; ctx.translate(this.x, this.y); ctx.rotate(this.angle); const gradient = ctx.createLinearGradient(-missileVisualLength / 2, 0, missileVisualLength / 2, 0); gradient.addColorStop(0, 'rgba(255, 69, 0, 0.8)'); gradient.addColorStop(0.3, 'rgba(255, 140, 0, 0.9)'); gradient.addColorStop(0.7, 'rgba(255, 215, 0, 1)'); gradient.addColorStop(1, 'rgba(255, 255, 200, 1)'); ctx.fillStyle = gradient; ctx.beginPath(); ctx.moveTo(missileVisualLength / 2, 0); ctx.lineTo(-missileVisualLength / 2 + missileVisualWidth / 2, -missileVisualWidth / 2); ctx.quadraticCurveTo(-missileVisualLength / 2, 0, -missileVisualLength / 2 + missileVisualWidth / 2, missileVisualWidth / 2); ctx.lineTo(missileVisualLength / 2, 0); ctx.fill(); ctx.fillStyle = 'rgba(200, 50, 0, 0.85)'; const finBase = -missileVisualLength / 2.5; const finLength = missileVisualWidth * 0.7; const finWidth = missileVisualWidth * 0.4; ctx.beginPath(); ctx.moveTo(finBase, -missileVisualWidth / 3); ctx.lineTo(finBase - finLength, -missileVisualWidth / 3 - finWidth); ctx.lineTo(finBase - finLength * 0.7, -missileVisualWidth / 3); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(finBase, missileVisualWidth / 3); ctx.lineTo(finBase - finLength, missileVisualWidth / 3 + finWidth); ctx.lineTo(finBase - finLength * 0.7, missileVisualWidth / 3); ctx.closePath(); ctx.fill(); 
                } else { 
                    const ownerSkin = (this.owner && SKINS[this.owner.skinId]) ? SKINS[this.owner.skinId] : SKINS['default']; let shouldGlow = false; let glowCol = this.color; if (ownerSkin.price >= 1000 || ['phantom', 'sharpshooter'].includes(this.owner.skinId)) { shouldGlow = true; if (this.owner.skinId === 'phantom') glowCol = 'rgba(200,100,255,0.9)'; else if (this.owner.skinId === 'sharpshooter') glowCol = 'rgba(0,220,220,0.9)'; else if (this.color) glowCol = this.color.startsWith('rgba') ? this.color : (this.color.length === 7 ? this.color + 'b3' : this.color); } if (shouldGlow) { ctx.shadowColor = glowCol; ctx.shadowBlur = 8 + Math.sin(Date.now() / 100) * 3; } ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2); ctx.fill(); if (!shouldGlow) { let trailColor = this.color; if (trailColor.startsWith('#') && trailColor.length === 7) { trailColor = trailColor + '4D'; } else if (trailColor.startsWith('rgb(')) { trailColor = trailColor.replace('rgb(', 'rgba(').replace(')', ', 0.3)'); } ctx.fillStyle = trailColor; ctx.beginPath(); ctx.arc(this.x - Math.cos(this.angle) * this.speed * 0.2, this.y - Math.sin(this.angle) * this.speed * 0.2, this.size / 2.8, 0, Math.PI * 2); ctx.fill(); } 
                } 
                ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; 
                ctx.restore(); 
            }
            update() { this.x += this.speed * Math.cos(this.angle); this.y += this.speed * Math.sin(this.angle); }
        }
        class Obstacle { constructor(x, y, width, height, color = '#7a5230') { this.x = x; this.y = y; this.width = width; this.height = height; this.color = color; this.darkerColor = getShadedColor(color, -20); } draw() { ctx.fillStyle = this.darkerColor; ctx.fillRect(this.x + 3, this.y + 3, this.width, this.height); ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; ctx.strokeRect(this.x, this.y, this.width, this.height); } }
        class PowerUp { constructor(x, y, type) { this.x = x; this.y = y; this.radius = POWERUP_SIZE / 2; this.type = type; this.active = true; this.spawnTime = Date.now(); this.lifeTime = 18000; } draw() { if (!this.active) return; ctx.save(); ctx.translate(this.x, this.y); const pulseFactor = 0.8 + Math.abs(Math.sin(Date.now() / 300)) * 0.4; const currentRadius = this.radius * pulseFactor; ctx.beginPath(); ctx.arc(0, 0, currentRadius, 0, Math.PI * 2); let fillColor, strokeColor, letter; if (this.type === 'shield') { fillColor = 'rgba(0, 191, 255, 0.7)'; strokeColor = 'rgba(0, 121, 205, 1)'; letter = 'S'; } else if (this.type === 'speed') { fillColor = 'rgba(255, 215, 0, 0.7)'; strokeColor = 'rgba(205, 165, 0, 1)'; letter = 'F'; } else if (this.type === 'health') { fillColor = 'rgba(50, 205, 50, 0.7)'; strokeColor = 'rgba(0, 155, 0, 1)'; letter = 'H'; } ctx.fillStyle = fillColor; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = 2.5; ctx.stroke(); ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.font = `bold ${this.radius*1.1}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(letter, 0, 1); ctx.restore(); } update() { if (Date.now() - this.spawnTime > this.lifeTime && this.active) { this.active = false; } } }


        function switchScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
                gameArea.style.display = 'none';
                if (screenId === 'menuScreen' && musicPlaying === false && menuMusic.paused) { 
                   tryPlayMusic();
                }
            } else {
                document.getElementById('menuScreen').classList.add('active');
                 gameArea.style.display = 'none';
            }
            const activeScreenContent = document.querySelector('.screen.active .screen-content-wrapper');
            if (activeScreenContent) {
                activeScreenContent.scrollTop = 0;
            }
            requestAnimationFrame(rescaleGame);
        }

        function initGame() {
            const selectedMapConfig = MAPS_CONFIG[currentMapId];
            G_MAP_WIDTH = selectedMapConfig.width;
            G_MAP_HEIGHT = selectedMapConfig.height;

            canvas.width = G_MAP_WIDTH;
            canvas.height = G_MAP_HEIGHT;
            gameContainer.style.width = G_MAP_WIDTH + 'px';
            gameContainer.style.height = G_MAP_HEIGHT + 'px';

            bullets.length = 0;
            powerUps.length = 0;
            lastPowerUpSpawnTime = Date.now();
            while (uiLayer.firstChild) uiLayer.removeChild(uiLayer.firstChild);

            const p1SkinId = currentProfileData.selectedSkinId || 'default';
            const p1Spawn = selectedMapConfig.playerSpawns[0];
            player1 = new Tank('player1', typeof p1Spawn.x === 'function' ? p1Spawn.x() : p1Spawn.x, typeof p1Spawn.y === 'function' ? p1Spawn.y() : p1Spawn.y, false, p1SkinId);
            player1.angle = typeof p1Spawn.angle === 'function' ? p1Spawn.angle() : p1Spawn.angle;
            player1.turretAngle = player1.angle;


            const p2Spawn = selectedMapConfig.playerSpawns[1];
            const p2SkinId = (gameMode === 'twoPlayer' ? 'default' : 'default'); 
            if (gameMode === 'vsCPU') {
                player2 = new Tank('player2_ai', typeof p2Spawn.x === 'function' ? p2Spawn.x() : p2Spawn.x, typeof p2Spawn.y === 'function' ? p2Spawn.y() : p2Spawn.y, true, p2SkinId, currentAiDifficulty);
            } else if (gameMode === 'twoPlayer') {
                player2 = new Tank('player2', typeof p2Spawn.x === 'function' ? p2Spawn.x() : p2Spawn.x, typeof p2Spawn.y === 'function' ? p2Spawn.y() : p2Spawn.y, false, p2SkinId);
            }
            if (player2) {
                player2.angle = typeof p2Spawn.angle === 'function' ? p2Spawn.angle() : p2Spawn.angle;
                player2.turretAngle = player2.angle;
            }
            
            initObstacles();
            spawnInitialPowerUps(Math.floor( (G_MAP_WIDTH * G_MAP_HEIGHT) / (1200*800) * 3) + 1 );

            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            gameArea.style.display = 'block';
            gameRunning = true;
            if (menuMusic && musicPlaying) menuMusic.pause(); 
            setupMobileControls();

            rescaleGame();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = performance.now();
            gameLoop();
        }


        function initObstacles() { obstacles.length = 0; const mapObsConfig = MAPS_CONFIG[currentMapId].obstacles; mapObsConfig.forEach(obsData => { const x = typeof obsData.x === 'function' ? obsData.x() : obsData.x; const y = typeof obsData.y === 'function' ? obsData.y() : obsData.y; const w = typeof obsData.w === 'function' ? obsData.w() : obsData.w; const h = typeof obsData.h === 'function' ? obsData.h() : obsData.h; obstacles.push(new Obstacle(x, y, w, h, obsData.color || '#7a5230')); }); }
        function spawnPowerUp() { if (powerUps.filter(p => p.active).length >= Math.floor( (G_MAP_WIDTH*G_MAP_HEIGHT) / (1200*800) * 4) + 2 ) return; let validPosition = false; let x, y, attempts = 0; const types = ['shield', 'speed', 'health', 'health', 'speed']; const type = types[Math.floor(Math.random() * types.length)]; while (!validPosition && attempts < 50) { x = Math.random() * (G_MAP_WIDTH - POWERUP_SIZE * 3) + POWERUP_SIZE * 1.5; y = Math.random() * (G_MAP_HEIGHT - POWERUP_SIZE * 3) + POWERUP_SIZE * 1.5; validPosition = true; const powerUpRect = { x: x - POWERUP_SIZE, y: y - POWERUP_SIZE, width: POWERUP_SIZE*2, height: POWERUP_SIZE*2 }; for (const obs of obstacles) if (rectIntersect(powerUpRect, obs)) { validPosition = false; break; } for (const pup of powerUps) if (pup.active && Math.hypot(x-pup.x, y-pup.y) < POWERUP_SIZE * 4) { validPosition = false; break; } if (player1 && Math.hypot(x - player1.x, y - player1.y) < player1.width * 3) { validPosition = false; } if (player2 && Math.hypot(x - player2.x, y - player2.y) < player2.width * 3) { validPosition = false; } attempts++; } if (validPosition) powerUps.push(new PowerUp(x, y, type)); }
        function spawnInitialPowerUps(count) { for(let i = 0; i < count; i++) spawnPowerUp(); }

        let lastTime = 0;
        function update(currentTime) {
            if (!gameRunning) return;
            const deltaTime_ms = (currentTime - lastTime) || (1000/60); 
            lastTime = currentTime;
            const normalizedDeltaTime = deltaTime_ms / (1000/60); 

            if (player1 && player1.health > 0) {
                player1.hasMovedThisFrame = false; 
                if (isTouch) { 
                    if (p1JoystickMoveState.active && (p1JoystickMoveState.joyX !== 0 || p1JoystickMoveState.joyY !== 0)) {
                        player1.angle = Math.atan2(p1JoystickMoveState.joyY, p1JoystickMoveState.joyX);
                        player1.move(1);
                    }
                    if (p1JoystickAimState.active && (p1JoystickAimState.joyX !== 0 || p1JoystickAimState.joyY !== 0)) {
                        player1.turretAngle = Math.atan2(p1JoystickAimState.joyY, p1JoystickAimState.joyX);
                        if (Math.hypot(p1JoystickAimState.joyX, p1JoystickAimState.joyY) > AIM_JOYSTICK_SHOOT_THRESHOLD) {
                            player1.shoot();
                        }
                    }
                } else { 
                    if (keys['w'] || keys['W']) player1.move(1); 
                    if (keys['s'] || keys['S']) player1.move(-1); 
                    if (keys['a'] || keys['A']) player1.rotateBody(-1); 
                    if (keys['d'] || keys['D']) player1.rotateBody(1); 
                    if (keys['q'] || keys['Q']) player1.rotateTurret(-1); 
                    if (keys['e'] || keys['E']) player1.rotateTurret(1);
                    if (keys[' ']) player1.shoot();
                    if (keys['Shift']) { 
                        player1.activateAbility();
                        keys['Shift'] = false; 
                    }
                }
                player1.update(normalizedDeltaTime, deltaTime_ms); 
            }
            if (player2 && player2.health > 0) {
                player2.hasMovedThisFrame = false; 
                if (gameMode === 'twoPlayer') {
                     if (isTouch) { 
                        if (p2JoystickMoveState.active && (p2JoystickMoveState.joyX !== 0 || p2JoystickMoveState.joyY !== 0)) {
                            player2.angle = Math.atan2(p2JoystickMoveState.joyY, p2JoystickMoveState.joyX);
                            player2.move(1);
                        }
                        if (p2JoystickAimState.active && (p2JoystickAimState.joyX !== 0 || p2JoystickAimState.joyY !== 0)) {
                            player2.turretAngle = Math.atan2(p2JoystickAimState.joyY, p2JoystickAimState.joyX);
                            if (Math.hypot(p2JoystickAimState.joyX, p2JoystickAimState.joyY) > AIM_JOYSTICK_SHOOT_THRESHOLD) {
                                player2.shoot();
                            }
                        }
                    } else { 
                        if (keys['ArrowUp']) player2.move(1); 
                        if (keys['ArrowDown']) player2.move(-1); 
                        if (keys['ArrowLeft']) player2.rotateBody(-1); 
                        if (keys['ArrowRight']) player2.rotateBody(1); 
                        if (keys[','] || keys['<']) player2.rotateTurret(-1); 
                        if (keys['.'] || keys['>']) player2.rotateTurret(1);
                        if (keys['Enter']) player2.shoot();
                        if (keys['ShiftRight'] || keys['ControlRight'] || keys['Numpad0']) { 
                           player2.activateAbility();
                           keys['ShiftRight'] = false; keys['ControlRight'] = false; keys['Numpad0'] = false; 
                        }
                    }
                } else if (gameMode === 'vsCPU' && player1 && player1.health > 0) { 
                    player2.updateAI(deltaTime_ms, player1); 
                }
                player2.update(normalizedDeltaTime, deltaTime_ms); 
            }

            for (let i = bullets.length - 1; i >= 0; i--) { const bullet = bullets[i]; bullet.update(); if (bullet.x < -BULLET_SIZE * 3 || bullet.x > G_MAP_WIDTH + BULLET_SIZE * 3 || bullet.y < -BULLET_SIZE * 3 || bullet.y > G_MAP_HEIGHT + BULLET_SIZE * 3) { bullets.splice(i, 1); continue; } let hit = false; for (const obs of obstacles) if (pointInRect({x: bullet.x, y: bullet.y}, obs)) { bullets.splice(i, 1); hit = true; break; } if (hit) continue; const targets = []; if (player1 && player1.health > 0) targets.push(player1); if (player2 && player2.health > 0) targets.push(player2); for (const tank of targets) { if (bullet.owner !== tank) { const dist = Math.hypot(bullet.x - tank.x, bullet.y - tank.y); if (dist < tank.width / 2 + bullet.size / 2) { tank.takeDamage(bullet.damage); bullets.splice(i, 1); hit = true; break; } } } if (hit) continue; }
            const activeTanks = []; if (player1 && player1.health > 0) activeTanks.push(player1); if (player2 && player2.health > 0) activeTanks.push(player2); for (let i = powerUps.length - 1; i >= 0; i--) { const pu = powerUps[i]; pu.update(); if (!pu.active) { powerUps.splice(i, 1); continue; } for (const tank of activeTanks) { const dist = Math.hypot(tank.x - pu.x, tank.y - pu.y); if (dist < tank.width / 2 + pu.radius) { tank.applyPowerUp(pu.type); pu.active = false; break; } } }
            if (Date.now() - lastPowerUpSpawnTime > POWERUP_SPAWN_INTERVAL) { spawnPowerUp(); lastPowerUpSpawnTime = Date.now(); }
        }
        function draw() { 
            ctx.fillStyle = MAPS_CONFIG[currentMapId].bgColor || '#bfa870'; ctx.fillRect(0, 0, G_MAP_WIDTH, G_MAP_HEIGHT);
            obstacles.forEach(obs => obs.draw()); powerUps.forEach(pu => pu.draw());
            if (player1 && player1.health > 0) player1.draw(); if (player2 && player2.health > 0) player2.draw();
            bullets.forEach(bullet => bullet.draw());
        }
        function gameLoop(currentTime) {
            if (!gameRunning) return; animationFrameId = requestAnimationFrame(gameLoop);
            update(currentTime); draw();
        }
        function endGame(message) {
            gameRunning = false; messageText.textContent = message;
            switchScreen('messageScreen');
            hideAllMobileControls();
            if (menuMusic && !musicPlaying && menuMusic.paused) tryPlayMusic(); 
        }
        function rectIntersect(r1, r2) { return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y); }
        function pointInRect(point, rect) { return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height; }

        window.addEventListener('keydown', (e) => { keys[e.key] = true; keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key] = false; keys[e.code] = false; });

        let isTouch = false;
        
        function isTouchDevice() { return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)); }

        function setupMobileControls() { 
            isTouch = isTouchDevice(); 
            hideAllMobileControls(); 
            if (isTouch && gameRunning) {
                if (gameMode === 'twoPlayer') { 
                    joystickContainerP1Move.style.display = 'block';
                    joystickContainerP1Aim.style.display = 'block';
                    if (player1 && player1.ability) skillButtonContainerP1.style.display = 'flex'; else skillButtonContainerP1.style.display = 'none';

                    joystickContainerP2Move.style.top = '20px'; joystickContainerP2Move.style.bottom = 'auto'; joystickContainerP2Move.style.left = '20px'; joystickContainerP2Move.style.right = 'auto';
                    joystickContainerP2Move.style.display = 'block';

                    joystickContainerP2Aim.style.top = '20px'; joystickContainerP2Aim.style.bottom = 'auto'; joystickContainerP2Aim.style.right = '20px'; joystickContainerP2Aim.style.left = 'auto';
                    joystickContainerP2Aim.style.display = 'block';
                    
                    if (player2 && player2.ability) {
                        skillButtonContainerP2.style.top = '140px'; 
                        skillButtonContainerP2.style.bottom = 'auto';
                        skillButtonContainerP2.style.right = '35px'; 
                        skillButtonContainerP2.style.left = 'auto';
                        skillButtonContainerP2.style.display = 'flex';
                    } else {
                        skillButtonContainerP2.style.display = 'none';
                    }

                } else if (gameMode === 'vsCPU') { 
                    joystickContainerP1Move.style.display = 'block';
                    joystickContainerP1Aim.style.display = 'block';
                    if (player1 && player1.ability) skillButtonContainerP1.style.display = 'flex'; else skillButtonContainerP1.style.display = 'none';

                    joystickContainerP2Move.style.display = 'none';
                    joystickContainerP2Aim.style.display = 'none';
                    skillButtonContainerP2.style.display = 'none';
                }
                if (joystickContainerP1Move.style.display === 'block' && joystickContainerP1Move.offsetWidth > 0) { p1JoystickMoveState.radius = joystickContainerP1Move.offsetWidth / 2; p1JoystickMoveState.handleRadius = joystickHandleP1Move.offsetWidth / 2; }
                if (joystickContainerP1Aim.style.display === 'block' && joystickContainerP1Aim.offsetWidth > 0) { p1JoystickAimState.radius = joystickContainerP1Aim.offsetWidth / 2; p1JoystickAimState.handleRadius = joystickHandleP1Aim.offsetWidth / 2; }
                if (joystickContainerP2Move.style.display === 'block' && joystickContainerP2Move.offsetWidth > 0) { p2JoystickMoveState.radius = joystickContainerP2Move.offsetWidth / 2; p2JoystickMoveState.handleRadius = joystickHandleP2Move.offsetWidth / 2; }
                if (joystickContainerP2Aim.style.display === 'block' && joystickContainerP2Aim.offsetWidth > 0) { p2JoystickAimState.radius = joystickContainerP2Aim.offsetWidth / 2; p2JoystickAimState.handleRadius = joystickHandleP2Aim.offsetWidth / 2; }
            }
        }
        function hideAllMobileControls() { 
            joystickContainerP1Move.style.display = 'none'; joystickContainerP1Aim.style.display = 'none'; skillButtonContainerP1.style.display = 'none';
            joystickContainerP2Move.style.display = 'none'; joystickContainerP2Aim.style.display = 'none'; skillButtonContainerP2.style.display = 'none';
        }

        const p1JoystickMoveState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };
        const p1JoystickAimState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };
        const p2JoystickMoveState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };
        const p2JoystickAimState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };

        function newJoystickInit(joystickCont, joystickHandle, stateObj) { if (!joystickCont || !joystickHandle) return; stateObj.radius = parseFloat(getComputedStyle(joystickCont).width) / 2 || 60; stateObj.handleRadius = parseFloat(getComputedStyle(joystickHandle).width) / 2 || 30; joystickHandle.style.left = '50%'; joystickHandle.style.top = '50%'; joystickHandle.style.transform = 'translate(-50%, -50%)'; joystickCont.addEventListener('touchstart', (e) => { e.preventDefault(); if (stateObj.active) return; if (joystickCont.offsetWidth > 0) { stateObj.radius = joystickCont.offsetWidth / 2; stateObj.handleRadius = joystickHandle.offsetWidth / 2; } const touch = e.changedTouches[0]; stateObj.active = true; stateObj.identifier = touch.identifier; newUpdateJoystickPosition(touch, joystickCont, joystickHandle, stateObj); }, { passive: false }); }
        function newUpdateJoystickPosition(touch, joystickCont, joystickHandle, stateObj) { if (!joystickCont || !joystickHandle) return; const rect = joystickCont.getBoundingClientRect(); let currentX = touch.clientX - rect.left; let currentY = touch.clientY - rect.top; let deltaX = currentX - stateObj.radius; let deltaY = currentY - stateObj.radius; const distance = Math.hypot(deltaX, deltaY); const maxDist = stateObj.radius - stateObj.handleRadius; if (maxDist <= 0) return; if (distance > maxDist) { deltaX = (deltaX / distance) * maxDist; deltaY = (deltaY / distance) * maxDist; } joystickHandle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`; stateObj.joyX = maxDist ? deltaX / maxDist : 0; stateObj.joyY = maxDist ? deltaY / maxDist : 0; }
        function newResetJoystick(joystickHandle, stateObj) { if (!joystickHandle) return; stateObj.active = false; stateObj.identifier = null; joystickHandle.style.transform = 'translate(-50%, -50%)'; stateObj.joyX = 0; stateObj.joyY = 0; }

        window.addEventListener('touchmove', (e) => {
            if (!gameRunning || !isTouch) return; e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i];
                if (p1JoystickMoveState.active && touch.identifier === p1JoystickMoveState.identifier) newUpdateJoystickPosition(touch, joystickContainerP1Move, joystickHandleP1Move, p1JoystickMoveState);
                if (p1JoystickAimState.active && touch.identifier === p1JoystickAimState.identifier) newUpdateJoystickPosition(touch, joystickContainerP1Aim, joystickHandleP1Aim, p1JoystickAimState);
                if (p2JoystickMoveState.active && touch.identifier === p2JoystickMoveState.identifier) newUpdateJoystickPosition(touch, joystickContainerP2Move, joystickHandleP2Move, p2JoystickMoveState);
                if (p2JoystickAimState.active && touch.identifier === p2JoystickAimState.identifier) newUpdateJoystickPosition(touch, joystickContainerP2Aim, joystickHandleP2Aim, p2JoystickAimState);
            }
        }, { passive: false });
        window.addEventListener('touchend', (e) => {
            if (!gameRunning || !isTouch) return;
            for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i];
                if (p1JoystickMoveState.active && touch.identifier === p1JoystickMoveState.identifier) newResetJoystick(joystickHandleP1Move, p1JoystickMoveState);
                if (p1JoystickAimState.active && touch.identifier === p1JoystickAimState.identifier) newResetJoystick(joystickHandleP1Aim, p1JoystickAimState);
                if (p2JoystickMoveState.active && touch.identifier === p2JoystickMoveState.identifier) newResetJoystick(joystickHandleP2Move, p2JoystickMoveState);
                if (p2JoystickAimState.active && touch.identifier === p2JoystickAimState.identifier) newResetJoystick(joystickHandleP2Aim, p2JoystickAimState);
            }
        }, { passive: false });

        function setupSkillButton(skillButtonElem, playerInstanceProvider) {
            if (!skillButtonElem) return;
            skillButtonElem.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const player = playerInstanceProvider();
                if (player && player.health > 0) {
                    player.activateAbility();
                }
            }, { passive: false });
        }


        function drawMiniTankPreview(canvasEl, skinId) {
            const skin = SKINS[skinId]; if (!skin || !canvasEl) return;
            const c = canvasEl.getContext('2d'); const w = canvasEl.width; const h = canvasEl.height;
            c.clearRect(0, 0, w, h); c.fillStyle = '#556'; c.fillRect(0,0,w,h);
            const miniTankSize = Math.min(w, h) * 0.7; const miniTurretLength = miniTankSize * 0.7; const miniTurretWidth = miniTankSize * 0.2;
            c.save(); c.translate(w / 2, h / 2);
            c.fillStyle = skin.color; c.fillRect(-miniTankSize / 2, -miniTankSize / 2.5, miniTankSize, miniTankSize / 1.25); 
            c.fillStyle = getShadedColor(skin.color, -20); c.fillRect(0, -miniTurretWidth / 2, miniTurretLength, miniTurretWidth); 
            c.beginPath(); c.arc(0,0, miniTankSize * 0.2, 0, Math.PI*2); c.fill();
            c.restore();
        }


        function populateShop() {
            shopItemsContainer.innerHTML = '';
            Object.keys(SKINS).forEach(skinId => {
                if (skinId === 'default') return;
                const skin = SKINS[skinId];
                const itemDiv = document.createElement('div'); itemDiv.className = 'shopItem';
                if (skin.price >= 500) itemDiv.classList.add('expensive-skin-glow');
                const previewCanvas = document.createElement('canvas'); previewCanvas.className = 'skin-preview-canvas'; previewCanvas.width = 80; previewCanvas.height = 60; 
                const nameH3 = document.createElement('h3'); nameH3.textContent = skin.name;
                const bulletPreview = document.createElement('span'); bulletPreview.className = 'bullet-color-preview'; bulletPreview.style.backgroundColor = skin.bulletColor; nameH3.appendChild(bulletPreview);
                const descP = document.createElement('p'); descP.innerHTML = skin.description; 
                if (skin.ability) {
                    descP.innerHTML += `<br><strong style="color:#FFD700;">Skill: ${skin.ability.name}</strong>`;
                }
                const priceP = document.createElement('p'); priceP.className = 'price'; priceP.textContent = `Price: $${skin.price}`;
                const buyButton = document.createElement('button'); buyButton.className = 'buySkinButton baseButton';
                if (currentProfileData.ownedSkins.includes(skinId)) { buyButton.textContent = 'Owned'; buyButton.disabled = true; }
                else if (currentProfileData.money < skin.price) { buyButton.textContent = 'Too Expensive'; buyButton.disabled = true; }
                else { buyButton.textContent = 'Buy'; buyButton.onclick = () => buySkin(skinId); }
                itemDiv.appendChild(previewCanvas); itemDiv.appendChild(nameH3); itemDiv.appendChild(descP); itemDiv.appendChild(priceP); itemDiv.appendChild(buyButton);
                shopItemsContainer.appendChild(itemDiv);
                drawMiniTankPreview(previewCanvas, skinId); 
            });
        }
        function buySkin(skinId) {
            const skin = SKINS[skinId];
            if (skin && !currentProfileData.ownedSkins.includes(skinId) && currentProfileData.money >= skin.price) {
                currentProfileData.money -= skin.price; currentProfileData.ownedSkins.push(skinId);
                savePlayerData();
                populateShop();
                updateUIAfterAuthChange(); // This will re-populate skin selector
            }
        }
        function populateSkinSelector() {
            skinSelector.innerHTML = '';
            if (currentProfileData.ownedSkins && Array.isArray(currentProfileData.ownedSkins)) {
                currentProfileData.ownedSkins.forEach(skinId => { 
                    const skin = SKINS[skinId]; 
                    if (skin) { 
                        const option = document.createElement('option'); 
                        option.value = skinId; 
                        option.textContent = skin.name; 
                        if (skinId === currentProfileData.selectedSkinId) option.selected = true; 
                        skinSelector.appendChild(option); 
                    } 
                });
            }
        }
        skinSelector.addEventListener('change', (e) => { currentProfileData.selectedSkinId = e.target.value; savePlayerData(); });

        function populateMapSelector() {
            if (!mapSelectorMenu) return; 
            mapSelectorMenu.innerHTML = '';
            Object.keys(MAPS_CONFIG).forEach(mapId => { 
                const option = document.createElement('option'); 
                option.value = mapId; 
                option.textContent = MAPS_CONFIG[mapId].name; 
                if (mapId === currentMapId) option.selected = true; 
                mapSelectorMenu.appendChild(option); 
            }); 
        }
        if (mapSelectorMenu) { mapSelectorMenu.addEventListener('change', (e) => { currentMapId = e.target.value; savePlayerData(); }); }


        function populateProfileScreen() {
            if (!profileScreen.classList.contains('active')) return;
            usernameInputProfile.value = currentProfileData.username || "Guest";
            usernameInputProfile.readOnly = !currentUser; 
            profileMoney.textContent = `$${currentProfileData.money || 0}`;
            profileGamesPlayed.textContent = currentProfileData.gamesPlayed || 0;
            profileWins.textContent = currentProfileData.wins || 0;
            profileLosses.textContent = currentProfileData.losses || 0;
            ownedSkinsList.innerHTML = '';
            (currentProfileData.ownedSkins || ['default']).forEach(skinId => {
                const skin = SKINS[skinId]; if (skin) { const li = document.createElement('li'); const skinColorDot = document.createElement('span'); skinColorDot.style.display = 'inline-block'; skinColorDot.style.width = '12px'; skinColorDot.style.height = '12px'; skinColorDot.style.borderRadius = '50%'; skinColorDot.style.backgroundColor = skin.color; skinColorDot.style.marginRight = '10px'; skinColorDot.style.border = '1px solid rgba(255,255,255,0.4)'; li.appendChild(skinColorDot); const skinNameSpan = document.createElement('span'); skinNameSpan.textContent = skin.name; li.appendChild(skinNameSpan); ownedSkinsList.appendChild(li); }
            });
        }
        usernameInputProfile.addEventListener('change', (e) => {
            if (currentUser) { 
                const newUsername = e.target.value.trim();
                if (newUsername.length >= 3 && newUsername !== currentProfileData.username) {
                    // Check if new username already exists (optional, but good practice)
                    const profiles = loadUserProfiles();
                    if (Object.keys(profiles).some(existingUser => existingUser.toLowerCase() === newUsername.toLowerCase() && existingUser !== currentUser)) {
                        alert("That username is already taken by another registered user. Please choose a different one.");
                        e.target.value = currentProfileData.username; // Revert
                        return;
                    }

                    currentProfileData.username = newUsername;
                    // Update username in the main profiles object if it's the key
                    if (profiles[currentUser]) {
                        const oldProfileData = profiles[currentUser];
                        delete profiles[currentUser]; // Remove old entry if username is the key
                        currentUser = newUsername; // Update currentUser to the new name
                        profiles[currentUser] = oldProfileData; // Add back with new key
                        profiles[currentUser].profileData.username = newUsername; // Ensure inner username matches
                        localStorage.setItem(LOGGED_IN_USER_KEY, currentUser); // Update persisted key
                        saveUserProfiles(profiles);
                    }
                    savePlayerData(); // Save currentProfileData modifications
                    loggedInUserDisplay.textContent = newUsername; 
                    updateUIAfterAuthChange(); // Refresh other UI parts
                } else if (newUsername.length < 3) {
                    alert("Username too short (min 3 characters). Reverting.");
                    e.target.value = currentProfileData.username; 
                } else if (newUsername === currentProfileData.username) {
                    // No change, do nothing
                }
            }
        });


        function rescaleGame() { const availableWidth = window.innerWidth; const availableHeight = window.innerHeight; const scaleX = availableWidth / G_MAP_WIDTH; const scaleY = availableHeight / G_MAP_HEIGHT; G_SCALE = Math.min(scaleX, scaleY, 1); if (gameArea.style.display === 'block') { gameArea.style.transformOrigin = 'top left'; gameArea.style.transform = `scale(${G_SCALE})`; const scaledWidth = G_MAP_WIDTH * G_SCALE; const scaledHeight = G_MAP_HEIGHT * G_SCALE; gameArea.style.width = G_MAP_WIDTH + 'px'; gameArea.style.height = G_MAP_HEIGHT + 'px'; gameArea.style.position = 'absolute'; gameArea.style.left = `${Math.max(0, (availableWidth - scaledWidth) / 2)}px`; gameArea.style.top = `${Math.max(0, (availableHeight - scaledHeight) / 2)}px`; if (gameRunning) { if (player1) player1.updateHealthBarPosition(); if (player2) player2.updateHealthBarPosition(); } } else { gameArea.style.transform = `scale(1)`; gameArea.style.position = 'relative'; gameArea.style.left = 'auto'; gameArea.style.top = 'auto'; } if (isTouch && gameRunning) { setupMobileControls(); } fullscreenButtonMenu.textContent = document.fullscreenElement ? "‚ÜîÔ∏è Exit Fullscreen" : "‚ÜîÔ∏è Enter Fullscreen"; }
        
        function updateRCBClaimButtonState() {
            const rcbClaimed = localStorage.getItem(RCB_CLAIMED_KEY) === 'true';
            const sniperSkinOwned = currentProfileData.ownedSkins.includes('sharpshooter');
            if (rcbClaimed || sniperSkinOwned) {
                rcbClaimButton.textContent = 'Sniper Skin Claimed!';
                rcbClaimButton.disabled = true;
            } else {
                rcbClaimButton.textContent = 'Claim Sniper Skin';
                rcbClaimButton.disabled = false;
            }
        }
        rcbClaimButton.addEventListener('click', () => {
            if (!currentProfileData.ownedSkins.includes('sharpshooter')) {
                currentProfileData.ownedSkins.push('sharpshooter');
                if (currentProfileData.ownedSkins.length <= 2) {
                    currentProfileData.selectedSkinId = 'sharpshooter';
                }
                savePlayerData(); 
                alert('Sniper Model S skin claimed!');
            }
            localStorage.setItem(RCB_CLAIMED_KEY, 'true');
            updateRCBClaimButtonState();
            updateUIAfterAuthChange(); // To refresh skin selector
        });

        function updateCollabTimer() {
            let endTime = localStorage.getItem(COLLAB_EVENT_END_TIME_KEY);
            const twoDaysInMs = 2 * 24 * 60 * 60 * 1000;

            if (!endTime || parseInt(endTime, 10) < Date.now() - twoDaysInMs) { 
                endTime = Date.now() + twoDaysInMs;
                localStorage.setItem(COLLAB_EVENT_END_TIME_KEY, endTime.toString());
            } else {
                endTime = parseInt(endTime, 10);
            }

            const now = Date.now();
            const timeLeft = endTime - now;

            if (timeLeft <= 0) {
                collabTimerDisplay.textContent = "Event Active Now!";
                return;
            }

            const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

            collabTimerDisplay.textContent = `${days}d ${hours}h ${minutes}m ${seconds}s`;
        }
        let collabTimerIntervalId; 

        window.addEventListener('load', () => {
            loadPlayerData(); 
            switchScreen('menuScreen');
            isTouch = isTouchDevice();
            if(isTouch) {
                newJoystickInit(joystickContainerP1Move, joystickHandleP1Move, p1JoystickMoveState);
                newJoystickInit(joystickContainerP1Aim, joystickHandleP1Aim, p1JoystickAimState);
                newJoystickInit(joystickContainerP2Move, joystickHandleP2Move, p2JoystickMoveState);
                newJoystickInit(joystickContainerP2Aim, joystickHandleP2Aim, p2JoystickAimState);
                setupSkillButton(skillButtonP1, () => player1);
                setupSkillButton(skillButtonP2, () => player2);
            }
            hideAllMobileControls();
            updateRCBClaimButtonState(); 
            updateCollabTimer(); 
            collabTimerIntervalId = setInterval(updateCollabTimer, 1000); 


            const initialMapConf = MAPS_CONFIG[currentMapId];
            canvas.width = initialMapConf.width; canvas.height = initialMapConf.height;
            ctx.fillStyle = initialMapConf.bgColor ||'#2c2c2c'; ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center";
            ctx.fillText("Tank Battle by Lapis Yamz", canvas.width/2, canvas.height/2 - 20);
            ctx.font = "20px Arial"; ctx.fillText("Loading...", canvas.width/2, canvas.height/2 + 20);
            initAudio();
            tryPlayMusic();

        });

        window.addEventListener('resize', rescaleGame);
        document.addEventListener('fullscreenchange', rescaleGame);

        function toggleFullScreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`); }); } else { if (document.exitFullscreen) document.exitFullscreen(); } }
        
        fullscreenButtonMenu.addEventListener('click', toggleFullScreen);
        vsCPUButton.addEventListener('click', () => { gameMode = 'vsCPU'; switchScreen('difficultyScreen'); });
        twoPlayerButton.addEventListener('click', () => { gameMode = 'twoPlayer'; initGame(); });
        
        shopButtonMenu.addEventListener('click', () => { populateShop(); switchScreen('shopScreen'); });
        profileButtonMenu.addEventListener('click', () => { populateProfileScreen(); switchScreen('profileScreen'); });
        leaderboardButtonMenu.addEventListener('click', () => { populateLeaderboardScreen(); switchScreen('leaderboardScreen'); });
        eventsButtonMenu.addEventListener('click', () => { updateRCBClaimButtonState(); updateCollabTimer(); switchScreen('eventScreen'); }); 
        howToPlayButton.addEventListener('click', () => switchScreen('howToPlayScreen'));

        document.querySelectorAll('.difficultyButton').forEach(button => { button.addEventListener('click', (e) => { currentAiDifficulty = e.target.dataset.difficulty; initGame(); }); });
        
        backToMenuFromEvent.addEventListener('click', () => switchScreen('menuScreen')); 
        backToMenuFromHowToPlay.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromDifficulty.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromShop.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromProfile.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromLeaderboard.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromLogin.addEventListener('click', () => { loginErrorMessage.style.display = 'none'; switchScreen('menuScreen'); });
        backToMenuFromRegister.addEventListener('click', () => { registerErrorMessage.style.display = 'none'; switchScreen('menuScreen');});

        playAgainButton.addEventListener('click', () => { initGame(); });
        backToMenuButton.addEventListener('click', () => { switchScreen('menuScreen'); gameRunning = false; hideAllMobileControls(); });

        loginRegisterButton.addEventListener('click', () => { loginErrorMessage.style.display = 'none'; switchScreen('loginScreen');});
        logoutButton.addEventListener('click', () => {
            logoutUser();
            switchScreen('menuScreen'); 
        });

        switchToRegisterLink.addEventListener('click', () => { loginErrorMessage.style.display = 'none'; registerErrorMessage.style.display = 'none'; switchScreen('registerScreen');});
        switchToLoginLink.addEventListener('click', () => { loginErrorMessage.style.display = 'none'; registerErrorMessage.style.display = 'none'; switchScreen('loginScreen');});

        loginSubmitButton.addEventListener('click', () => {
            const username = loginUsernameInput.value.trim();
            const password = loginPasswordInput.value;
            loginErrorMessage.style.display = 'none';
            if (!username || !password) {
                loginErrorMessage.textContent = "Username and password required.";
                loginErrorMessage.style.display = 'block';
                return;
            }
            const result = loginUser(username, password);
            if (result.success) {
                switchScreen('menuScreen');
                loginUsernameInput.value = ''; loginPasswordInput.value = '';
            } else {
                loginErrorMessage.textContent = result.message;
                loginErrorMessage.style.display = 'block';
            }
        });

        registerSubmitButton.addEventListener('click', () => {
            const username = registerUsernameInput.value.trim();
            const password = registerPasswordInput.value;
            registerErrorMessage.style.display = 'none';
             if (!username || !password) {
                registerErrorMessage.textContent = "Username and password required.";
                registerErrorMessage.style.display = 'block';
                return;
            }
            const result = registerUser(username, password);
            if (result.success) {
                alert(result.message); 
                switchScreen('loginScreen');
                registerUsernameInput.value = ''; registerPasswordInput.value = '';
            } else {
                registerErrorMessage.textContent = result.message;
                registerErrorMessage.style.display = 'block';
            }
        });

    </script>
</body>
</html>