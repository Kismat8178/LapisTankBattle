
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LapisTankBattle X Niwan - V5.0.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #1c1c1c;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        /* --- LOADING SCREEN STYLES --- */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, #2c3e50 0%, #111 100%);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            transition: opacity 0.8s ease-in-out;
        }

        #loadingScreen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #loadingScreen .loading-title {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: clamp(2em, 7vw, 4em);
            text-shadow: 0 0 15px rgba(0, 191, 255, 0.8), 0 0 5px rgba(255,255,255,0.5);
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        #loadingCanvas {
            width: 80%;
            max-width: 300px;
            height: 150px;
            border-radius: 10px;
            background-color: rgba(0,0,0,0.2);
            border: 1px solid rgba(0, 191, 255, 0.3);
            margin-bottom: 20px;
        }

        #progressBarContainer {
            width: 80%;
            max-width: 400px;
            height: 20px;
            border: 2px solid #00BFFF;
            border-radius: 10px;
            background-color: rgba(0,0,0,0.3);
            margin-top: 20px;
            overflow: hidden;
        }

        #progressBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00BFFF, #1E90FF);
            border-radius: 8px;
            transition: width 0.3s ease-out;
        }

        #loadingStatus {
            margin-top: 15px;
            font-size: clamp(1em, 3vw, 1.3em);
            color: #ccc;
            letter-spacing: 1px;
        }

        #tapToContinueButton {
            display: none;
            margin-top: 40px;
            padding: 15px 30px;
            font-size: 1.5em;
            font-family: 'Orbitron', sans-serif;
            color: white;
            background: linear-gradient(145deg, #FF9800, #F57C00);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 5px 0 #E65100, 0 8px 20px rgba(0,0,0,0.4);
            animation: pulseButton 2s infinite;
        }

        @keyframes pulseButton {
            0% { transform: scale(1); box-shadow: 0 5px 0 #E65100, 0 8px 20px rgba(0,0,0,0.4); }
            50% { transform: scale(1.05); box-shadow: 0 7px 0 #E65100, 0 12px 25px rgba(255, 152, 0, 0.4); }
            100% { transform: scale(1); box-shadow: 0 5px 0 #E65100, 0 8px 20px rgba(0,0,0,0.4); }
        }


        /* --- GAME AREA & UI --- */
        #gameArea {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            display: none;
            background-color: #333;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            transition: transform 0.1s linear;
        }
        canvas {
            display: block;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        #uiLayer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        #targetingOverlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none; /* Hidden by default */
            cursor: crosshair;
            z-index: 150;
        }
        /* [MODIFICATION] Phase Shift Overlay */
        #phaseShiftOverlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-color: rgba(0, 100, 200, 0.25);
            display: none;
            z-index: 140;
            pointer-events: none;
            backdrop-filter: blur(2px);
        }

        .health-bar-container {
            position: absolute;
            width: 50px; 
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .health-bar-wrapper, .energy-bar-wrapper {
            width: 100%;
            height: 8px;
            background-color: rgba(85, 85, 85, 0.7);
            border: 1px solid #222;
            border-radius: 2px;
            box-sizing: border-box;
            overflow: hidden;
        }
        .health-bar, .energy-bar {
            height: 100%;
            border-radius: 1px;
            transition: width 0.2s ease-out;
        }
        .health-bar {
            background-color: limegreen;
        }
        .energy-bar-wrapper {
             display: none; /* Hidden by default */
        }
        .energy-bar {
            background: linear-gradient(90deg, #8A2BE2, #9932CC); /* Blue-Violet to Dark Orchid */
        }

        .shield-indicator, .immortal-indicator {
            position: absolute;
            width: 10px; height: 10px;
            border-radius: 50%;
            border: 1px solid #fff;
            top: -12px; left: 50%;
            transform: translateX(-50%);
        }
        .shield-indicator { background-color: deepskyblue; }
        .immortal-indicator {
            background-color: gold;
            width: 12px; height: 12px;
            border: 2px solid #fff;
            box-shadow: 0 0 8px gold;
            top: -14px;
            left: calc(50% + 15px);
        }
        .flag-icon {
            position: absolute;
            font-size: 32px;
            text-shadow: 1px 1px 3px black;
            transition: all 0.2s ease-out;
        }
        #ctfScoreUI {
            position: absolute;
            top: 10px; left: 50%;
            transform: translateX(-50%);
            display: none;
            background-color: rgba(0,0,0,0.6);
            padding: 8px 20px;
            border-radius: 10px;
            font-size: clamp(1.2em, 4vw, 1.8em);
            font-weight: bold; color: white;
            z-index: 50;
            border: 1px solid rgba(255,255,255,0.2);
            text-shadow: 1px 1px 2px black;
        }
        #ctfTeam1Score { color: #87CEFA; }
        #ctfTeam2Score { color: #F08080; }


        /* --- JOYSTICKS & SKILL BUTTONS --- */
        .joystick-container-base {
            position: fixed;
            width: 120px; height: 120px;
            background-color: rgba(120, 120, 120, 0.35);
            border-radius: 50%;
            display: none; z-index: 100;
            user-select: none;
            -webkit-user-select: none;
            border: 2px solid rgba(255,255,255,0.15);
        }
        .joystick-handle-base {
            position: absolute;
            width: 60px; height: 60px;
            background-color: rgba(200, 200, 200, 0.65);
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.25);
        }
        #joystickContainerP1Move { bottom: 20px; left: 20px; }
        #joystickContainerP1Aim { bottom: 20px; right: 20px; }
        #joystickContainerP2Move { top: 20px; left: 20px; }
        #joystickContainerP2Aim { top: 20px; right: 20px; }
        .skill-button-container-base {
            position: fixed;
            display: none;
            z-index: 100;
        }
        .skill-button-base {
            width: 70px; height: 70px;
            background-color: rgba(150, 50, 255, 0.6);
            color: white;
            border: 2px solid rgba(120, 30, 220, 0.8);
            border-radius: 50%;
            font-size: 11px; font-weight: bold;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            box-shadow: 0 0 12px rgba(150, 50, 255, 0.4);
            transition: all 0.1s ease-out;
            padding: 5px; box-sizing: border-box;
            text-align: center; line-height: 1.1;
        }
        .skill-button-base.on-cooldown {
            background-color: rgba(100, 100, 100, 0.7);
            color: #aaa;
            border-color: rgba(80,80,80,0.8);
            cursor: not-allowed;
        }
        .skill-button-base.energy-ready { /* Style for when energy is full */
            background-color: #8A2BE2; /* BlueViolet */
            box-shadow: 0 0 15px #DA70D6, 0 0 25px #8A2BE2;
            animation: pulseButton 1.5s infinite;
        }
        .skill-button-base .skill-name-text { display: block; font-size: 0.9em; }
        .skill-button-base .charges-text { font-size: 0.8em; color: #ffdd77; }
        .skill-button-base .cooldown-text { font-size: 14px; font-weight: bold; }
        #skillButtonContainerP1 { bottom: 140px; right: 35px; }
        #skillButtonContainerP2 { top: 140px; right: 35px; }


        /* --- GENERIC SCREEN STYLES --- */
        .screen {
            display: none; position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,10,10,0.92);
            z-index: 200; padding: 0;
            box-sizing: border-box; text-align: center;
            color: #fff;
        }
        .screen.active {
            display: flex; flex-direction: column;
            align-items: center;
        }
        .screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2.2em, 7vw, 3.8em);
            margin-bottom: 15px; margin-top: 10px;
            color: #00BFFF; text-shadow: 2px 2px 2px #0000CD;
        }
        .screen p {
             margin-bottom: 20px; font-size: clamp(0.9em, 3vw, 1.2em); color: #ccc;
        }
        .screen-content-wrapper {
            padding: 20px; padding-top: 10px;
            box-sizing: border-box; width: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: flex-start;
            overflow-y: auto; flex-grow: 1;
            -webkit-overflow-scrolling: touch;
        }

        /* --- NEW MENU SCREEN STYLES --- */
        #menuScreen {
            justify-content: flex-start;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiPjxkZWZzPjxyYWRpYWxHcmFkaWVudCBpZD0iZ3JhZGllbnQiIGN4PSI1MCUiIGN5PSI1MCUiIHI9IjgwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzJjM2U1MDsiLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiMxNjE2MjUiLz48L3JhZGlhbEdyYWRpZW50PjwvZGVmcz48cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI2dyYWRpZW50KSIgLz48L3N2Zz4=');
            background-size: cover;
        }
        .menu-top-bar {
            width: 100%; padding: 10px 15px;
            box-sizing: border-box; display: flex;
            justify-content: space-between; align-items: center;
            background-color: rgba(0,0,0,0.5);
            flex-shrink: 0;
        }
        /* Style for top bar buttons */
        .menu-top-bar button { 
            padding: 8px 12px; font-size: clamp(0.8em, 2vw, 1em); margin-left: 8px; 
            background: linear-gradient(145deg, #444, #222);
            color: #ddd;
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .menu-top-bar button:hover {
            background: linear-gradient(145deg, #555, #333);
            color: white;
            border-color: #777;
        }
        #loggedInUserDisplay { font-size: clamp(0.9em, 2.5vw, 1.1em); color: #FFD700; }
        
        .menu-content-grid {
            display: grid;
            grid-template-areas: "title" "modes" "preview" "secondary" "social";
            grid-template-rows: auto auto 1fr auto auto;
            gap: clamp(10px, 2vh, 20px);
            width: 100%;
            height: 100%;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        @media (min-width: 800px) {
            .menu-content-grid {
                grid-template-areas: 
                    "preview title"
                    "preview modes"
                    "secondary modes"
                    "social social";
                grid-template-columns: 1fr 1.5fr;
                grid-template-rows: auto 1fr auto auto;
                align-items: center;
            }
        }

        #skinPreviewContainer { 
            grid-area: preview; 
            display: flex; flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0,0,0,0.3);
            border: 1px solid rgba(0, 191, 255, 0.4);
            border-radius: 15px;
            padding: 20px;
        }
        #skinPreviewContainer h2 {
            margin: 0 0 10px 0;
            font-family: 'Orbitron', sans-serif;
            color: #FFD700;
            text-shadow: 0 0 5px #FFD700;
        }
        #menuSkinPreviewCanvas {
            width: 100%;
            max-width: 240px;
            height: 180px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
            border: 1px solid rgba(0, 191, 255, 0.2);
            margin-bottom: 15px;
        }
        #skinSelector {
            padding: 10px 15px;
            font-size: clamp(1em, 3vw, 1.3em);
            border-radius: 6px;
            background-color: #334;
            color: white;
            border: 1px solid #557;
            width: 100%;
            max-width: 240px;
        }

        .game-title-main { 
            grid-area: title;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: clamp(2.2em, 7vw, 4.2em);
            color: #fff;
            text-align: center;
            text-shadow: 0 0 8px #ffcc00, 0 0 15px #ff00de, 0 0 25px #00c3ff;
            animation: glowTitle 2s ease-in-out infinite alternate;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M50 0 L61.8 38.2 L100 38.2 L69.1 61.8 L80.9 100 L50 76.4 L19.1 100 L30.9 61.8 L0 38.2 L38.2 38.2 Z" fill="rgba(255,223,0,0.1)"/></svg>') no-repeat center center;
            background-size: contain;
            padding: 20px 0;
        }
        @keyframes glowTitle {
            from { text-shadow: 0 0 8px #ffcc00, 0 0 15px #ff00de, 0 0 25px #00c3ff; }
            to { text-shadow: 0 0 15px #ffcc00, 0 0 25px #ff00de, 0 0 40px #00c3ff; }
        }

        .main-buttons-container { 
            grid-area: modes;
            display: flex; flex-direction: column;
            align-items: center;
            gap: clamp(15px, 3vh, 25px);
        }
        .main-buttons-container .baseButton {
             width: clamp(280px, 70vw, 400px);
             padding: clamp(15px, 3.5vw, 22px) 0 !important;
             font-size: clamp(1.4em, 5vw, 2em) !important;
             font-family: 'Orbitron', sans-serif;
             border-radius: 12px;
        }
        .ctfButton { background: linear-gradient(145deg, #9C27B0, #6A1B9A); box-shadow: 0 5px 0 #4A148C, 0 8px 15px rgba(0,0,0,0.3); }
        .ctfButton:hover { background: linear-gradient(145deg, #AB47BC, #7B1FA2); transform: translateY(-2px); box-shadow: 0 7px 0 #4A148C, 0 10px 20px rgba(0,0,0,0.2);}
        .ctfButton:active { background: linear-gradient(145deg, #8E24AA, #6A1B9A); transform: translateY(2px); box-shadow: 0 2px 0 #4A148C, 0 5px 10px rgba(0,0,0,0.4);}

        .secondary-buttons-container { 
            grid-area: secondary;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        .secondary-buttons-container .baseButton {
            width: auto;
            min-width: 140px;
            padding: 12px 20px !important;
            font-size: clamp(1em, 3vw, 1.2em) !important;
        }
        .shop-button-new {
            background: linear-gradient(145deg, #03A9F4, #0288D1) !important;
            box-shadow: 0 5px 0 #0277BD !important;
        }
        .shop-button-new:hover { background: linear-gradient(145deg, #29B6F6, #039BE5) !important; }

        .social-links-container {
            grid-area: social;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            margin-top: 15px;
        }
        .social-link {
            display: inline-block;
            color: white;
            text-decoration: none;
            transition: transform 0.2s ease;
        }
        .social-link:hover { transform: scale(1.1); }
        .social-link svg {
            width: 40px; height: 40px;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.5));
        }
        
        /* Buff/Nerf Indicators and Tooltips */
        .buff-nerf-indicator {
            display: inline-block;
            margin-left: 8px;
            cursor: help;
            position: relative;
        }
        .buff-nerf-indicator .tooltip-text {
            visibility: hidden;
            width: 220px;
            background-color: #111;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px 12px;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position above the indicator */
            left: 50%;
            margin-left: -110px; /* Center the tooltip */
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #555;
            font-size: 0.8em;
            line-height: 1.4;
        }
        .buff-nerf-indicator:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }


        /* --- OTHER SCREEN & SHOP STYLES --- */
        #shopItemsContainer { display: flex; flex-wrap: wrap; justify-content: center; gap: 18px; max-height: 70vh; overflow-y: auto; padding: 15px; width: 95%; max-width: 900px; background-color: rgba(20,20,30,0.05); border-radius: 10px; border: 1px solid rgba(100,100,150,0.15); margin-bottom: 15px; }
        .shopItem { background-color: rgba(30,30,50,0.85); border: 1px solid #445; border-radius: 10px; padding: 15px; width: clamp(200px, 28vw, 260px); text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.6); transition: all 0.2s ease; display: flex; flex-direction: column; align-items: center; }
        .shopItem:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(0,0,0,0.5); }
        .shopItem.expensive-skin-glow { box-shadow: 0 0 18px gold, 0 0 30px #FFFF99, 0 5px 15px rgba(0,0,0,0.5); border: 1px solid gold; }
        .shopItem.expensive-skin-glow:hover { transform: translateY(-5px); box-shadow: 0 0 25px gold, 0 0 40px #FFFF99, 0 8px 25px rgba(0,0,0,0.4); }
        /* [NEW] Lapis skin glow */
        .shopItem.lapis-skin-glow {
            border: 1px solid #DA70D6;
            box-shadow: 0 0 12px #9400D3, 0 0 20px #00BFFF, 0 0 30px #FFFFFF, 0 5px 15px rgba(0,0,0,0.7);
        }
        .shopItem.lapis-skin-glow:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px #9400D3, 0 0 30px #00BFFF, 0 0 45px #FFFFFF, 0 8px 25px rgba(0,0,0,0.5);
        }
        .shopItem.event-skin-glow { box-shadow: 0 0 15px #ff4081, 0 0 25px #1976D2, 0 5px 15px rgba(0,0,0,0.5); border: 1px solid #ffcc00; }
        .shopItem.event-skin-glow:hover { transform: translateY(-5px); box-shadow: 0 0 22px #ff4081, 0 0 32px #1976D2, 0 8px 25px rgba(0,0,0,0.4); }
        .shopItem h3 { margin-top: 0; margin-bottom: 8px; color: #FFD700; font-size: clamp(1.1em, 2.8vw, 1.4em);}
        .shopItem p { font-size: clamp(0.8em, 2.3vw, 1em); margin-bottom: 8px; color: #bbb;}
        .shopItem .price { font-weight: bold; color: #8BC34A; font-size: clamp(0.9em, 2.5vw, 1.1em); }
        .shopItem .owned { color: #4CAF50; font-weight: bold; font-size: clamp(0.9em, 2.5vw, 1.1em); }
        .buySkinButton { background: linear-gradient(145deg, #2196F3, #1976D2); box-shadow: 0 4px 0 #1565C0; font-size: clamp(0.9em, 3vw, 1.3em); padding: 8px 18px; min-width: 130px; margin-top: auto; }
        .buySkinButton:disabled { background: #546E7A; color: #CFD8DC; box-shadow: 0 4px #37474F; cursor: not-allowed; }
        .skin-preview-canvas { width: 80px; height: 60px; margin-bottom: 10px; border: 1px solid #557; background-color: #445; border-radius: 5px; }
        .bullet-color-preview { width: 15px; height: 15px; border-radius: 50%; display: inline-block; margin-left: 8px; border: 1px solid rgba(255,255,255,0.7); vertical-align: middle; }
        #profileScreen .profile-info { background-color: rgba(30,30,50,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; width: 90%; max-width: 500px; border: 1px solid rgba(100,100,150,0.2); }
        #profileScreen label { display: block; margin-top: 10px; font-size: 1.1em; color: #FFC107; }
        #profileScreen #usernameInputProfile { padding: 8px; margin-top: 5px; border-radius: 5px; border: 1px solid #557; background-color: #334; color: white; font-size: 1em; width: 80%; }
        #profileScreen .stat { margin: 8px 0; font-size: 1.2em; }
        #profileScreen .stat-label { color: #B0C4DE; }
        #profileScreen .stat-value { color: #87CEFA; font-weight: bold; }
        #profileScreen #ownedSkinsList { list-style: none; padding: 0; margin-top: 10px;}
        #profileScreen #ownedSkinsList li { background-color: rgba(100,100,150,0.15); margin: 5px 0; padding: 8px 12px; border-radius: 4px; display: flex; align-items: center; }
        #messageScreen { z-index: 300; }
        .game-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: clamp(1em, 3vw, 1.5em); color: #bbb; opacity: 0.7; text-shadow: 1px 1px #000; pointer-events: none; }
        #otherGameLinkContainer { position: fixed; bottom: 0px; width: 100%; text-align: center; font-size: 0.7em; z-index: 500; color: #aaa; padding: 3px 0; background-color: rgba(0,0,0,0.5); }
        #otherGameLinkContainer a { color: #87CEFA; text-decoration: none; }
        #otherGameLinkContainer a:hover { text-decoration: underline; }
        #howToPlayScreen .instructions, #infoScreen .info-content { margin-top: 20px; font-size: clamp(0.9em, 2.8vw, 1.2em); text-align: left; max-width: 90%; color: #ccc; padding: 20px; background-color: rgba(30,30,50,0.2); border-radius: 8px; }
        #howToPlayScreen .instructions p, #infoScreen .info-content p { margin: 10px 0; line-height: 1.5; }
        #howToPlayScreen .instructions strong, #infoScreen .info-content strong { color: #87CEFA; }
        #loginScreen .form-container, #registerScreen .form-container { background-color: rgba(30,30,50,0.1); padding: 25px; border-radius: 10px; margin-bottom: 20px; width: 90%; max-width: 400px; border: 1px solid rgba(100,100,150,0.2); }
        #loginScreen p, #registerScreen p { font-size: clamp(0.9em, 2.8vw, 1.1em); }
        #loginScreen .switch-form-link, #registerScreen .switch-form-link { color: #87CEFA; cursor: pointer; text-decoration: underline; margin-top: 15px; display: inline-block; }
        .error-message { color: #ff6b6b; margin-top: -10px; margin-bottom: 10px; font-size: 0.9em; }
        #mapSelectorScreen .map-selection-button { display: block; width: clamp(250px, 60vw, 380px); margin: 10px auto; padding: 15px 20px; font-size: 1.2em; background: linear-gradient(145deg, #4CAF50, #388E3C); color: white; border: none; border-radius: 8px; box-shadow: 0 4px 0 #2E7D32; cursor: pointer; }
        #mapSelectorScreen .map-selection-button:hover { background: linear-gradient(145deg, #66BB6A, #43A047); }
        .baseButton { padding: clamp(12px, 3vw, 18px) clamp(25px, 5vw, 35px); font-size: clamp(1.1em, 4vw, 1.6em); margin: 0; cursor: pointer; color: white; border: none; border-radius: 8px; transition: all 0.2s ease-in-out; text-align: center; font-weight: bold; letter-spacing: 0.5px; }
        .menuButton { background: linear-gradient(145deg, #2196F3, #1976D2); box-shadow: 0 5px 0 #1565C0, 0 8px 15px rgba(0,0,0,0.3); }
        .menuButton:hover { background: linear-gradient(145deg, #42A5F5, #1E88E5); transform: translateY(-2px); box-shadow: 0 7px 0 #1565C0, 0 10px 20px rgba(0,0,0,0.2);}
        .menuButton:active { background: linear-gradient(145deg, #1976D2, #1565C0); transform: translateY(2px); box-shadow: 0 2px 0 #1565C0, 0 5px 10px rgba(0,0,0,0.4); }
        .tdmButton { background: linear-gradient(145deg, #E53935, #B71C1C); box-shadow: 0 5px 0 #7F0000, 0 8px 15px rgba(0,0,0,0.3); }
        .tdmButton:hover { background: linear-gradient(145deg, #EF5350, #C62828); transform: translateY(-2px); box-shadow: 0 7px 0 #7F0000, 0 10px 20px rgba(0,0,0,0.2);}
        .tdmButton:active { background: linear-gradient(145deg, #D32F2F, #B71C1C); transform: translateY(2px); box-shadow: 0 2px 0 #7F0000, 0 5px 10px rgba(0,0,0,0.4);}
        .backButton { background: linear-gradient(145deg, #f44336, #d32f2f); box-shadow: 0 5px 0 #b71c1c; margin-top: 25px; }
        .backButton:hover { background: linear-gradient(145deg, #ef5350, #e53935); transform: translateY(-2px); box-shadow: 0 7px 0 #b71c1c; }
        .difficultyButton { background: linear-gradient(145deg, #ff9800, #f57c00); box-shadow: 0 5px 0 #e65100; }
        .difficultyButton:hover { background: linear-gradient(145deg, #ffa726, #fb8c00);transform: translateY(-2px); }
    </style>
</head>
<body>

    <div id="loadingScreen">
        <h1 class="loading-title">LapisTankBattle X Niwan</h1>
        <canvas id="loadingCanvas" width="300" height="150" data-preview-id="loading_preview"></canvas>
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
        <p id="loadingStatus">Initializing Game Systems...</p>
        <button id="tapToContinueButton">Tap to Start</button>
    </div>
    
    <audio id="backgroundMusic" src="your-music-file.mp3" loop></audio>

    <div id="playerMoneyDisplay">$0</div>

    <div id="menuScreen" class="screen">
        <div class="menu-top-bar">
            <div>
                <span id="loggedInUserDisplay">Guest</span>
                <button id="loginRegisterButton">Login/Register</button>
                <button id="logoutButton" style="display:none;">Logout</button>
            </div>
            <div>
                 <button id="musicToggleButton">🎵 Mute</button>
                <button id="fullscreenButtonMenu">↔️ Fullscreen</button>
            </div>
        </div>

        <div class="menu-content-grid">
            <div id="skinPreviewContainer">
                <h2>Equipped Skin</h2>
                <canvas id="menuSkinPreviewCanvas" width="240" height="180" data-preview-id="menu_preview"></canvas>
                <select id="skinSelector"></select>
            </div>

            <h1 class="game-title-main">LAPIS TANK BATTLE<br>X<br>NIWAN</h1>

            <div class="main-buttons-container">
                <button class="baseButton menuButton" id="newVsCPUButton">VS COMPUTER</button>
                <button class="baseButton menuButton" id="newTwoPlayerButton">LOCAL MULTI</button>
                <button class="baseButton tdmButton" id="newTdmButton">TEAM DEATHMATCH</button>
                <button class="baseButton ctfButton" id="newCtfButton">CAPTURE THE FLAG</button>
            </div>

            <div class="secondary-buttons-container">
                <button class="baseButton shop-button-new" id="newShopButton">🛍️ Shop</button>
                <button class="baseButton menuButton" id="newProfileButton">👤 Profile</button>
                <button class="baseButton menuButton" id="newHowToPlayButton">❓ How to Play</button>
                <button class="baseButton menuButton" id="newEventButton">📅 Event</button>
                <button class="baseButton menuButton" id="newInfoButton">ℹ️ Info</button>
                <a href="mailto:kgiri8178@gmail.com" class="baseButton menuButton" style="text-decoration:none; display:inline-flex; align-items:center; justify-content:center; min-width:140px;">📧 Contact</a>
            </div>
            
            <div class="social-links-container">
                <a href="https://www.youtube.com/@gamingwithkismat8178" target="_blank" class="social-link" aria-label="YouTube Channel">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M21.582,6.186c-0.23-0.86-0.908-1.538-1.768-1.768C18.267,4,12,4,12,4S5.733,4,4.186,4.418 c-0.86,0.23-1.538,0.908-1.768,1.768C2,7.733,2,12,2,12s0,4.267,0.418,5.814c0.23,0.86,0.908,1.538,1.768,1.768 C5.733,20,12,20,12,20s6.267,0,7.814-0.418c0.861-0.23,1.538-0.908,1.768-1.768C22,16.267,22,12,22,12S22,7.733,21.582,6.186z M10,15.464V8.536L16,12L10,15.464z"></path></svg>
                </a>
                <a href="https://kismat8178.github.io/LapisYamCricket/" target="_blank" class="social-link" aria-label="Other Game: Lapis Yam Cricket">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12,2C6.486,2,2,6.486,2,12s4.486,10,10,10c5.514,0,10-4.486,10-10S17.514,2,12,2z M12,20c-4.411,0-8-3.589-8-8 s3.589-8,8-8s8,3.589,8,8S16.411,20,12,20z"></path><path d="M13 7L11 7 11 11 7 11 7 13 11 13 11 17 13 17 13 13 17 13 17 11 13 11z"></path></svg>
                </a>
            </div>
        </div>
    </div>

    <div id="infoScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Game Information</h1>
            <div class="info-content">
                <p><strong>Owner/Creator:</strong> Lapis Yamz</p>
                <p><strong>Game Assisted By:</strong> Roshan Paudel, Krish Thakuri</p>
                <hr style="border-color: rgba(100,100,200,0.2); margin: 15px 0;">
                <p>This game is a passion project, combining classic tank battle mechanics with modern features and special collaborations. We hope you enjoy playing it as much as we enjoyed making it!</p>
                <p>For any inquiries or feedback, please use the 'Contact Us' button on the main menu.</p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromInfo">Back to Menu</button>
        </div>
    </div>


    <div id="eventScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>🎉 Special Events 🎉</h1>
            <div style="background-color: rgba(40,40,60,0.6); padding: 25px; border-radius: 10px; margin: 20px; width: 90%; max-width: 500px; border: 1px solid rgba(120,120,220,0.4);">
                 <h3>No Active Events</h3>
                 <p>Previous collaboration and special events have ended.</p>
                 <p>Limited-time event skins may now be available in the shop!</p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromEvent">Back to Menu</button>
        </div>
    </div>

    <div id="loginScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Login</h1>
            <div class="form-container">
                <p id="loginErrorMessage" class="error-message" style="display:none;"></p>
                <input type="text" id="loginUsername" placeholder="Username" autocomplete="username">
                <input type="password" id="loginPassword" placeholder="Password" autocomplete="current-password">
                <button class="baseButton menuButton" id="loginSubmitButton" style="margin-top:15px;">Login</button>
                <p>Don't have an account? <span id="switchToRegisterLink" class="switch-form-link">Register here</span></p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromLogin">Back to Menu</button>
        </div>
    </div>

    <div id="registerScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Register</h1>
            <div class="form-container">
                <p id="registerErrorMessage" class="error-message" style="display:none;"></p>
                <input type="text" id="registerUsername" placeholder="Username (min 3 chars)" autocomplete="username">
                <input type="password" id="registerPassword" placeholder="Password (min 4 chars)" autocomplete="new-password">
                <button class="baseButton menuButton" id="registerSubmitButton" style="margin-top:15px;">Register</button>
                <p>Already have an account? <span id="switchToLoginLink" class="switch-form-link">Login here</span></p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromRegister">Back to Menu</button>
        </div>
    </div>

    <div id="howToPlayScreen" class="screen">
        <div class="screen-content-wrapper">
             <h1>How to Play</h1>
             <div class="instructions">
                <p><strong>Player 1 (Keyboard):</strong></p>
                <p>&nbsp;&nbsp;WASD: Move Tank</p>
                <p>&nbsp;&nbsp;Arrow Keys (← → ↑ ↓): Aim Turret</p>
                <p>&nbsp;&nbsp;Spacebar: Shoot</p>
                <p>&nbsp;&nbsp;Left Shift: Use Active Skill</p>
                <br>
                <p><strong>Player 2 (Keyboard):</strong></p>
                <p>&nbsp;&nbsp;IJKL: Move Tank</p>
                <p>&nbsp;&nbsp;U / O: Rotate Turret</p>
                <p>&nbsp;&nbsp;H: Shoot</p>
                <p>&nbsp;&nbsp;Right Shift: Use Active Skill</p>
                <br>
                <p><strong>Mobile Controls:</strong></p>
                <p>&nbsp;&nbsp;Bottom-Left Joystick: Move Tank</p>
                <p>&nbsp;&nbsp;Bottom-Right Joystick: Aim Turret & Shoot</p>
                <p>&nbsp;&nbsp;Skill Button (Above Aim Joystick): Use Active Skill</p>
                 <br>
                <p><strong>Custom Targeting:</strong></p>
                <p>&nbsp;&nbsp;Some skills (like Iron Hook, Gloo Wall, Void Collapse) require you to aim on the map. Tap or click where you want to use the skill.</p>
            </div>
            <button class="backButton baseButton" id="backToMenuFromHowToPlay">Back to Menu</button>
        </div>
    </div>

    <div id="mapSelectorScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Select Map</h1>
            <div id="mapSelectionButtonsContainer">
                <!-- Map buttons will be populated here by JavaScript -->
            </div>
            <button class="backButton baseButton" id="backToMenuFromMapSelector">Back to Menu</button>
        </div>
    </div>


    <div id="difficultyScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Select AI Difficulty</h1>
            <button class="baseButton difficultyButton" data-difficulty="EASY">Easy ($5 Reward)</button>
            <button class="baseButton difficultyButton" data-difficulty="NORMAL">Normal ($10 Reward)</button>
            <button class="baseButton difficultyButton" data-difficulty="HARD">Hard ($20 Reward)</button>
            <button class="baseButton difficultyButton" data-difficulty="FREESTYLE">Freestyle ($30 Reward)</button>
            <button class="backButton baseButton" id="backToMenuFromDifficulty">Back to Menu</button>
        </div>
    </div>

    <div id="shopScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Tank Skin Shop</h1>
            <div id="shopItemsContainer">
                <!-- Shop items will be populated here by JavaScript -->
            </div>
            <button class="backButton baseButton" id="backToMenuFromShop">Back to Menu</button>
        </div>
    </div>

    <div id="profileScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Player Profile</h1>
            <div class="profile-info">
                <div>
                    <label for="usernameInputProfile">Username:</label>
                    <input type="text" id="usernameInputProfile" placeholder="Enter your name" readonly>
                </div>
                <p class="stat"><span class="stat-label">Money:</span> <span id="profileMoney" class="stat-value">$0</span></p>
                <p class="stat"><span class="stat-label">Games Played:</span> <span id="profileGamesPlayed" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">Wins:</span> <span id="profileWins" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">Losses:</span> <span id="profileLosses" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">Hard AI Wins:</span> <span id="profileHardAIWins" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">Freestyle AI Wins:</span> <span id="profileFreestyleAIWins" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">CTF Wins:</span> <span id="profileCtfWins" class="stat-value">0</span></p>
                <div>
                    <h3 style="color: #FFC107; margin-top: 15px;">Owned Skins:</h3>
                    <ul id="ownedSkinsList"></ul>
                </div>
            </div>
            <button class="backButton baseButton" id="backToMenuFromProfile">Back to Menu</button>
            <p style="font-size: 0.8em; color: #777; margin-top: 15px;">Profile data is saved locally in your browser.</p>
        </div>
    </div>

    <div id="gameArea">
        <div id="ctfScoreUI"><span id="ctfTeam1Score">0</span> - <span id="ctfTeam2Score">0</span></div>
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div id="uiLayer"></div>
            <!-- [MODIFICATION] Generic targeting overlay -->
            <div id="targetingOverlay"></div>
            <!-- [MODIFICATION] Phase shift visual effect overlay -->
            <div id="phaseShiftOverlay"></div>
        </div>
        <div class="game-title">Tank Battle by Lapis Yamz</div>
    </div>

    <!-- Player 1 Controls -->
    <div id="joystickContainerP1Move" class="joystick-container-base">
        <div id="joystickHandleP1Move" class="joystick-handle-base"></div>
    </div>
    <div id="joystickContainerP1Aim" class="joystick-container-base">
        <div id="joystickHandleP1Aim" class="joystick-handle-base"></div>
    </div>
    <div id="skillButtonContainerP1" class="skill-button-container-base">
        <button id="skillButtonP1" class="skill-button-base">
            <span class="skill-name-text">SKILL</span>
            <span class="charges-text"></span>
            <span class="cooldown-text"></span>
        </button>
    </div>

    <!-- Player 2 Controls -->
    <div id="joystickContainerP2Move" class="joystick-container-base">
        <div id="joystickHandleP2Move" class="joystick-handle-base"></div>
    </div>
    <div id="joystickContainerP2Aim" class="joystick-container-base">
        <div id="joystickHandleP2Aim" class="joystick-handle-base"></div>
    </div>
     <div id="skillButtonContainerP2" class="skill-button-container-base">
        <button id="skillButtonP2" class="skill-button-base">
            <span class="skill-name-text">SKILL</span>
            <span class="charges-text"></span>
            <span class="cooldown-text"></span>
        </button>
    </div>


    <div id="messageScreen" class="screen">
        <div class="screen-content-wrapper">
            <div id="messageText" style="font-size: clamp(1.8em, 6vw, 2.8em); color: white; margin-bottom: 20px;">Game Over!</div>
            <button class="baseButton menuButton" id="playAgainButton">Play Again (Same Mode)</button>
            <button class="backButton baseButton" id="backToMenuButton">Back to Menu</button>
        </div>
    </div>

    <div id="otherGameLinkContainer">
        Try our other game: <a href="https://kismat8178.github.io/LapisYamCricket/" target="_blank">LapisYamCricket</a> |
        My YouTube: <a href="https://www.youtube.com/@gamingwithkismat8178" target="_blank">@gamingwithkismat8178</a>
    </div>

    <script>
        // --- Anti Code-Theft (Simple deterrent) ---
        document.addEventListener('contextmenu', event => event.preventDefault());
        document.onkeydown = function (e) {
            if (e.keyCode == 123) { // F12
                return false;
            }
            if (e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) {
                return false;
            }
            if (e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) {
                return false;
            }
            if (e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) {
                return false;
            }
            if (e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) {
                return false;
            }
        };

        const gameArea = document.getElementById('gameArea');
        const canvas = document.getElementById('gameCanvas');
        let ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('uiLayer');
        const targetingOverlay = document.getElementById('targetingOverlay');
        const phaseShiftOverlay = document.getElementById('phaseShiftOverlay');
        const gameContainer = document.getElementById('gameContainer');

        const ctfScoreUI = document.getElementById('ctfScoreUI');
        const ctfTeam1ScoreDisplay = document.getElementById('ctfTeam1Score');
        const ctfTeam2ScoreDisplay = document.getElementById('ctfTeam2Score');
        
        const joystickContainerP1Move = document.getElementById('joystickContainerP1Move');
        const joystickHandleP1Move = document.getElementById('joystickHandleP1Move');
        const joystickContainerP1Aim = document.getElementById('joystickContainerP1Aim');
        const joystickHandleP1Aim = document.getElementById('joystickHandleP1Aim');
        const skillButtonContainerP1 = document.getElementById('skillButtonContainerP1');
        const skillButtonP1 = document.getElementById('skillButtonP1');

        const joystickContainerP2Move = document.getElementById('joystickContainerP2Move');
        const joystickHandleP2Move = document.getElementById('joystickHandleP2Move');
        const joystickContainerP2Aim = document.getElementById('joystickContainerP2Aim');
        const joystickHandleP2Aim = document.getElementById('joystickHandleP2Aim');
        const skillButtonContainerP2 = document.getElementById('skillButtonContainerP2');
        const skillButtonP2 = document.getElementById('skillButtonP2');


        const menuScreen = document.getElementById('menuScreen');
        const eventScreen = document.getElementById('eventScreen');
        const infoScreen = document.getElementById('infoScreen');
        const loginScreen = document.getElementById('loginScreen');
        const registerScreen = document.getElementById('registerScreen');
        const howToPlayScreen = document.getElementById('howToPlayScreen');
        const mapSelectorScreen = document.getElementById('mapSelectorScreen');
        const difficultyScreen = document.getElementById('difficultyScreen');
        const shopScreen = document.getElementById('shopScreen');
        const profileScreen = document.getElementById('profileScreen');
        const messageScreen = document.getElementById('messageScreen');
        
        const newVsCPUButton = document.getElementById('newVsCPUButton');
        const newTwoPlayerButton = document.getElementById('newTwoPlayerButton');
        const newTdmButton = document.getElementById('newTdmButton');
        const newCtfButton = document.getElementById('newCtfButton');
        const newShopButton = document.getElementById('newShopButton');
        const newProfileButton = document.getElementById('newProfileButton');
        const newHowToPlayButton = document.getElementById('newHowToPlayButton');
        const newEventButton = document.getElementById('newEventButton');
        const newInfoButton = document.getElementById('newInfoButton');
        
        const fullscreenButtonMenu = document.getElementById('fullscreenButtonMenu');
        const musicToggleButton = document.getElementById('musicToggleButton');
        const backgroundMusic = document.getElementById('backgroundMusic');
        
        const loginRegisterButton = document.getElementById('loginRegisterButton');
        const logoutButton = document.getElementById('logoutButton');
        const loggedInUserDisplay = document.getElementById('loggedInUserDisplay');
        const loginUsernameInput = document.getElementById('loginUsername');
        const loginPasswordInput = document.getElementById('loginPassword');
        const loginSubmitButton = document.getElementById('loginSubmitButton');
        const switchToRegisterLink = document.getElementById('switchToRegisterLink');
        const loginErrorMessage = document.getElementById('loginErrorMessage');
        const registerUsernameInput = document.getElementById('registerUsername');
        const registerPasswordInput = document.getElementById('registerPassword');
        const registerSubmitButton = document.getElementById('registerSubmitButton');
        const switchToLoginLink = document.getElementById('switchToLoginLink');
        const registerErrorMessage = document.getElementById('registerErrorMessage');
        const backToMenuFromLogin = document.getElementById('backToMenuFromLogin');
        const backToMenuFromRegister = document.getElementById('backToMenuFromRegister');

        const backToMenuFromEvent = document.getElementById('backToMenuFromEvent');
        const backToMenuFromInfo = document.getElementById('backToMenuFromInfo');
        const backToMenuFromHowToPlay = document.getElementById('backToMenuFromHowToPlay');
        const backToMenuFromMapSelector = document.getElementById('backToMenuFromMapSelector');
        const backToMenuFromDifficulty = document.getElementById('backToMenuFromDifficulty');
        const backToMenuFromShop = document.getElementById('backToMenuFromShop');
        const backToMenuFromProfile = document.getElementById('backToMenuFromProfile');

        const messageText = document.getElementById('messageText');
        const playAgainButton = document.getElementById('playAgainButton');
        const backToMenuButton = document.getElementById('backToMenuButton');

        const playerMoneyDisplay = document.getElementById('playerMoneyDisplay');
        const shopItemsContainer = document.getElementById('shopItemsContainer');
        const skinSelector = document.getElementById('skinSelector');
        
        const usernameInputProfile = document.getElementById('usernameInputProfile');
        const profileMoney = document.getElementById('profileMoney');
        const profileGamesPlayed = document.getElementById('profileGamesPlayed');
        const profileWins = document.getElementById('profileWins');
        const profileLosses = document.getElementById('profileLosses');
        const profileHardAIWins = document.getElementById('profileHardAIWins');
        const profileFreestyleAIWins = document.getElementById('profileFreestyleAIWins');
        const profileCtfWins = document.getElementById('profileCtfWins');
        const ownedSkinsList = document.getElementById('ownedSkinsList');

        let gameMode = null;
        let tempSelectedMapId = null;
        let currentAiDifficulty = 'NORMAL';
        let gameRunning = false;
        let animationFrameId;
        // [MODIFICATION] More detailed game states for custom targeting
        let gameState = 'MENU'; // MENU, PLAYING, AWAITING_HOOK_TARGET, AWAITING_GLOO_WALL_PLACEMENT, AWAITING_VORTEX_PLACEMENT
        
        let ctfScores = { 1: 0, 2: 0 };
        const CTF_SCORE_LIMIT = 3;
        const TDM_SCORE_LIMIT = 10;
        let team1Score = 0; team2Score = 0;


        let G_MAP_WIDTH = 1200;
        let G_MAP_HEIGHT = 800;
        let camera = { x: 0, y: 0 };
        const particles = [];

        const TANK_SIZE_BASE = 40;
        const TANK_SIZE = TANK_SIZE_BASE;
        const TURRET_LENGTH = TANK_SIZE * 0.9;
        const TURRET_WIDTH = TANK_SIZE * 0.25;
        const BULLET_SPEED_BASE = 8;
        const BULLET_SIZE = 6;
        const BASE_TANK_SPEED = 2;
        const TANK_TURN_SPEED = 0.05;
        const TURRET_TURN_SPEED = 0.07;
        const MAX_HEALTH_BASE = 100;
        const SHOOT_COOLDOWN_BASE = 600; //ms
        const BASE_BULLET_DAMAGE = 12;
        const POWERUP_SIZE = 25;
        const POWERUP_DURATION_BASE = 10000; //ms
        const POWERUP_SPAWN_INTERVAL = 12000; //ms
        const AIM_JOYSTICK_SHOOT_THRESHOLD = 0.85;

        let allTanks = [];
        let player1, player2;
        const bullets = [];
        const hooks = []; // [NEW] For Bruiser's ability
        const obstacles = [];
        const powerUps = [];
        const activeEffects = []; 
        const temporaryObstacles = [];
        let flags = [];
        let lastPowerUpSpawnTime = 0;

        const keys = {};
        let G_SCALE = 1;
        let mousePos = { x: 0, y: 0 };

        const GUEST_PROFILE_KEY = 'tankBattleGuestProfile_v5.0';
        const USER_PROFILES_KEY = 'tankBattleUserProfiles_v5.0';
        const LOGGED_IN_USER_KEY = 'tankBattleLoggedInUser_v5.0';

        let currentUser = null;
        const getDefaultProfile = () => ({
            username: 'Guest',
            money: 0,
            ownedSkins: ['default'],
            selectedSkinId: 'default',
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            tdmWins: 0,
            ctfWins: 0,
            hardAIWins: 0,
            freestyleAIWins: 0,
            selectedMapId: 'classic'
        });
        let currentProfileData = getDefaultProfile();

        // [MODIFICATION] SKINS object updated with all reworks and the new Lapis skin.
        const SKINS = {
            'default': {
                name: 'Default Mark I', price: 0, color: '#337ab7', bulletColor: '#222222',
                description: "The tried and true classic.",
                p2Color: '#d9534f',
                ability: null
            },
            'scout': {
                name: 'Light Scout X2', price: 75, color: '#90EE90', bulletColor: '#7FFF00',
                description: "Faster movement & fire rate, lighter armor.",
                healthMultiplier: 0.85, speedMultiplier: 1.25, cooldownMultiplier: 0.92,
                ability: null
            },
            'bruiser': { // [REWORK] Bruiser now has Iron Hook
                name: 'Heavy Bruiser T7', price: 150, color: '#B22222', bulletColor: '#FF4500',
                description: "Heavy armor. Its Iron Hook stuns and pulls enemies towards you.",
                healthMultiplier: 1.30, speedMultiplier: 0.80, damageMultiplier: 1.0, // Damage is now on the hook
                ability: { type: 'HOOK_SHOT', name: 'Iron Hook', cooldown: 14000, damage: 25, range: 650, stunDuration: 1500 },
                buffs: ["New Skill: Iron Hook. Pulls, stuns and damages an enemy with custom targeting."]
            },
            'sharpshooter': { // [REWORK] Sniper now has Phase Shift
                name: 'Sniper Model S', price: 300, color: '#00CED1', bulletColor: '#00FFFF',
                description: "Activate Phase Shift to gain a burst of speed and walk through walls and tanks. Disabled in CTF.",
                healthMultiplier: 0.9, damageMultiplier: 0.85, // Damage nerfed
                ability: { type: 'PHASE_WALK', name: 'Phase Shift', cooldown: 18000, duration: 4000, speedMultiplier: 1.6 },
                nerfs: ["Skill completely reworked. No longer a long-range shot.", "Base damage reduced."],
                buffs: ["New Skill: Phase Shift. Gain high speed and pass through obstacles for a short time."]
            },
            'phantom': { // [REWORK] Phantom now has targeted wall placement
                name: 'Phantom Stealth', price: 550, color: '#6A0DAD', bulletColor: '#DA70D6',
                description: "Creates a temporary energy wall to block projectiles and enemies. Use the skill then tap to place.",
                healthMultiplier: 0.95, speedMultiplier: 1.20, damageMultiplier: 1.15, cooldownMultiplier: 0.88,
                ability: { type: 'TARGETED_GLOO_WALL', name: 'Gloo Wall', cooldown: 12000, wallDuration: 30000, wallHealth: 3 },
                buffs: ["Gloo Wall is now placed with custom targeting for tactical advantage."]
            },
             'niwan_tank': { // [REWORK] Niwan now charges by moving
                name: "Niwan's Tank", price: 700,
                color: '#1a1a1a', bulletColor: '#E0E0E0',
                p2Color: '#2f2f2f',
                description: "Charges energy by moving, then unleashes a devastating Void Form that damages nearby enemies.",
                ability: { type: 'ENERGY_BALL', name: 'Void Form', duration: 5000, maxEnergy: 100, damagePerSecond: 25, areaOfEffect: 150, chargeRate: 0.15 },
                bulletType: 'petal', movementEffect: 'white_trail', customDraw: true,
                buffs: ["Skill now charges by moving instead of taking/dealing damage, making it more reliable."]
            },
            'golden_goliath': {
                name: 'Golden Goliath', price: 1200, color: '#B8860B', bulletColor: '#FF8C00',
                description: "The ultimate tank. Aegis creates a powerful team healing aura and grants self-speed.",
                healthMultiplier: 1.5, speedMultiplier: 1.15, damageMultiplier: 1.25, cooldownMultiplier: 0.80,
                special: 'powerup_duration_boost_regen',
                ability: { type: 'AEGIS_FIELD', name: 'Aegis', cooldown: 35000, duration: 8000, speedBoostMultiplier: 1.4, selfHealRate: 1.5, teamHealRate: 8.0, fieldRadius: 180 },
                buffs: ["Team heal effect is now much stronger and has a clear visual indicator."]
            },
            'heart_collab': {
                name: "Nathania's Tank", price: 1000,
                color: '#D32F2F', bulletColor: '#9400D3',
                p2Color: '#C00000',
                description: "Shoots loving hearts. Its Phase Dash allows for rapid repositioning. (Nerfed in CTF)",
                healthMultiplier: 1.05, speedMultiplier: 1.0, damageMultiplier: 1.0, cooldownMultiplier: 1.0,
                bulletType: 'heart',
                ability: { type: 'MULTI_DASH', name: 'Phase Dash', cooldown: 20000, maxCharges: 5, tdmMaxCharges: 2 },
                movementEffect: 'pink_trail',
                customDraw: true,
                nerfs: ["In Capture the Flag mode, Phase Dash is limited to 1 charge to prevent unfair flag captures."],
                buffs: ["Complete visual redesign: improved model, glowing effects, and new sounds."]
            },
            'soccer_collab': {
                name: "Liam's Tank", price: 1000,
                color: '#1976D2', bulletColor: '#FFFFFF',
                p2Color: '#005C9E',
                description: "Shoots soccer balls. Its Unyielding skill makes it immortal and grants lifesteal.",
                healthMultiplier: 1.1, speedMultiplier: 0.95, damageMultiplier: 1.05, cooldownMultiplier: 1.0,
                bulletType: 'soccerball',
                ability: { type: 'IMMORTAL_RAGE', name: 'Unyielding', cooldown: 29000, duration: 5000, lifestealPercentage: 0.50 },
                movementEffect: 'blue_trail',
                customDraw: true
            },
            'rcb_champion': {
                name: 'RCB Champion', price: 0,
                color: '#AA0000', secondaryColor: '#101010', bulletColor: '#FFD700',
                p2Color: '#880000',
                description: "RCB themed! Its Frontline Shield reflects incoming enemy projectiles.",
                healthMultiplier: 1.0, speedMultiplier: 1.0, damageMultiplier: 1.0, cooldownMultiplier: 1.0,
                ability: { type: 'REFLECT_SHIELD', name: 'Frontline Shield', cooldown: 16000, duration: 10000 },
                buffs: ["New reflective shield ability. Skill duration increased to 10s, cooldown set to 16s."]
            },
            'lapis': { // [NEW] The new Lapis skin
                name: 'Lapis Celestial', price: 20000,
                color: '#483D8B', bulletColor: '#FFFFFF',
                p2Color: '#2c2552',
                description: "A divine weapon. Unleash a black hole with Void Collapse to trap and destroy enemies.",
                healthMultiplier: 1.2, speedMultiplier: 1.1, damageMultiplier: 1.15,
                bulletType: 'shuriken',
                ability: { type: 'VORTEX_ULTIMATE', name: 'Void Collapse', cooldown: 25000, duration: 3500, radius: 250, damagePerSecond: 35, pullStrength: 2.5 },
                movementEffect: 'purple_black_trail',
                customDraw: true,
                buffs: ["New Ultimate: Void Collapse. Creates a gravity well that pulls and damages enemies with custom targeting."]
            }
        };

        const MAPS_CONFIG = {
            classic: {
                name: "Classic Arena", width: 1200, height: 800, bgColor: '#a08860',
                playerSpawns: [
                    { x: 150, y: 450, angle: Math.PI / 2, team: 1 }, // Team 1
                    { x: 1050, y: 350, angle: -Math.PI / 2, team: 2 }, // Team 2
                    { x: 200, y: 150, angle: Math.PI / 4, team: 1 },
                    { x: 1000, y: 650, angle: -3*Math.PI / 4, team: 2 },
                    { x: 450, y: 100, angle: 0, team: 1 },
                    { x: 750, y: 700, angle: Math.PI, team: 2 },
                    { x: 150, y: 650, angle: 3*Math.PI / 4, team: 1 },
                    { x: 1050, y: 150, angle: -Math.PI/4, team: 2 }
                ],
                obstacles: [ { x: 480, y: 200, w: 240, h: 80 }, { x: 480, y: 520, w: 240, h: 80 }, { x: 560,  y: 280, w: 80,  h: 240 }, { x: 100, y: 100, w: 120, h: 60 }, { x: 980, y: 100, w: 120, h: 60 }, { x: 100, y: 640, w: 120, h: 60 }, { x: 980, y: 640, w: 120, h: 60 }, { x: 300, y: 370, w: 60, h: 100, color: '#8c6c46' }, { x: 840, y: 330, w: 60, h: 100, color: '#8c6c46' }, { x: 750, y: 200, w: 100, h: 50 }, { x: 350, y: 550, w: 100, h: 50 } ],
            },
            urban_chaos: {
                name: "Urban Chaos", width: 1600, height: 1000, bgColor: '#909090',
                 playerSpawns: [
                    { x: 100, y: 100, angle: Math.PI / 4, team: 1 }, { x: 1500, y: 900, angle: -3 * Math.PI / 4, team: 2 },
                    { x: 100, y: 900, angle: -Math.PI/4, team: 1 }, { x: 1500, y: 100, angle: 3*Math.PI / 4, team: 2 },
                    { x: 500, y: 150, angle: 0, team: 1 }, { x: 1100, y: 850, angle: Math.PI, team: 2 },
                    { x: 150, y: 500, angle: Math.PI / 2, team: 1 }, { x: 1450, y: 500, angle: -Math.PI/2, team: 2 }
                ],
                obstacles: [ { x: 320, y: 200, w: 300, h: 60, color: '#585858' }, { x: 320, y: 300, w: 60, h: 200, color: '#585858' }, { x: 980, y: 740, w: 300, h: 60, color: '#505050' }, { x: 1220, y: 540, w: 60, h: 200, color: '#505050' }, { x: 650, y: 470, w: 300, h: 60, color: '#606060' }, { x: 770, y: 350, w: 60, h: 300, color: '#606060' }, { x: 150, y: 800, w: 250, h: 50, color: '#484848' }, { x: 1200, y: 150, w: 250, h: 50, color: '#484848' } ],
            },
            division: {
                name: "Division (CTF)", width: 1800, height: 900, bgColor: '#4a604a', isCTFMap: true,
                playerSpawns: [
                    { x: 150, y: 450, angle: 0, team: 1 }, { x: 1650, y: 450, angle: Math.PI, team: 2 },
                    { x: 150, y: 250, angle: 0, team: 1 }, { x: 1650, y: 650, angle: Math.PI, team: 2 },
                    { x: 150, y: 650, angle: 0, team: 1 }, { x: 1650, y: 250, angle: Math.PI, team: 2 }
                ],
                 obstacles: [ // Central river
                    { x: 875, y: 0, w: 50, h: 300, color: '#304560' }, { x: 875, y: 600, w: 50, h: 300, color: '#304560' }, // Team 1 Base
                    { x: 100, y: 100, w: 200, h: 50, color: '#607d8b' }, { x: 100, y: 750, w: 200, h: 50, color: '#607d8b' }, { x: 350, y: 300, w: 50, h: 300, color: '#546e7a' }, // Team 2 Base
                    { x: 1500, y: 100, w: 200, h: 50, color: '#607d8b' }, { x: 1500, y: 750, w: 200, h: 50, color: '#607d8b' }, { x: 1400, y: 300, w: 50, h: 300, color: '#546e7a' } ],
                flagSpawns: [{ x: 80, y: 450, team: 1 }, { x: 1720, y: 450, team: 2 }]
            }
        };
        let currentMapId = 'classic';

        function loadUserProfiles() {
            const savedProfiles = localStorage.getItem(USER_PROFILES_KEY);
            return savedProfiles ? JSON.parse(savedProfiles) : {};
        }

        function saveUserProfiles(profiles) {
            localStorage.setItem(USER_PROFILES_KEY, JSON.stringify(profiles));
        }

        function obfuscatePassword(pass) { return btoa(pass.split("").reverse().join("")); }

        function registerUser(username, password) {
            const profiles = loadUserProfiles();
            const existingUser = Object.keys(profiles).find(key => key.toLowerCase() === username.toLowerCase());
            if (existingUser) {
                return { success: false, message: "Username already exists." };
            }
            if (username.length < 3) return { success: false, message: "Username too short (min 3)." };
            if (password.length < 4) return { success: false, message: "Password too short (min 4)." };

            let newProfileData = getDefaultProfile();
            newProfileData.username = username;

            // [MODIFICATION] Owner Bonus updated
            if (username.toLowerCase() === 'lapis yamz') {
                newProfileData.money = 1000000;
                newProfileData.ownedSkins = Object.keys(SKINS);
            }

            profiles[username] = {
                hashedPassword: obfuscatePassword(password),
                profileData: newProfileData
            };
            saveUserProfiles(profiles);
            return { success: true, message: "Registration successful! Please login." };
        }

        function loginUser(username, password) {
            const profiles = loadUserProfiles();
            const actualUsername = Object.keys(profiles).find(key => key.toLowerCase() === username.toLowerCase());
            
            if (!actualUsername) {
                return { success: false, message: "Username not found." };
            }
            if (profiles[actualUsername].hashedPassword !== obfuscatePassword(password)) {
                return { success: false, message: "Incorrect password." };
            }
            
            // [MODIFICATION] Owner Bonus updated on login
            if (actualUsername.toLowerCase() === 'lapis yamz') {
                profiles[actualUsername].profileData.money = 1000000;
                profiles[actualUsername].profileData.ownedSkins = Object.keys(SKINS);
            }

            currentUser = actualUsername;
            localStorage.setItem(LOGGED_IN_USER_KEY, currentUser);
            loadPlayerData();
            
            savePlayerData();
            updateUIAfterAuthChange();
            return { success: true };
        }

        function logoutUser() {
            currentUser = null;
            localStorage.removeItem(LOGGED_IN_USER_KEY);
            loadPlayerData();
            updateUIAfterAuthChange();
        }


        function loadPlayerData() {
            const persistedUser = localStorage.getItem(LOGGED_IN_USER_KEY);
            if (persistedUser) {
                currentUser = persistedUser;
            }

            const defaultProfile = getDefaultProfile();

            if (currentUser) {
                const profiles = loadUserProfiles();
                if (profiles[currentUser] && profiles[currentUser].profileData) {
                    currentProfileData = { ...defaultProfile, ...profiles[currentUser].profileData, username: currentUser };
                } else {
                    console.warn("Logged in user profile data not found for", currentUser, "- logging out.");
                    logoutUser();
                    return;
                }
            } else {
                loadGuestData();
            }

            // Data integrity checks
            if (!currentProfileData.ownedSkins || !Array.isArray(currentProfileData.ownedSkins) || currentProfileData.ownedSkins.length === 0) {
                currentProfileData.ownedSkins = ['default'];
            } else if (!currentProfileData.ownedSkins.includes('default')) {
                currentProfileData.ownedSkins.push('default');
            }
            currentProfileData.ownedSkins = [...new Set(currentProfileData.ownedSkins)];
            currentProfileData.ownedSkins = currentProfileData.ownedSkins.filter(id => SKINS[id]);

            if (!currentProfileData.selectedSkinId || !SKINS[currentProfileData.selectedSkinId] || !currentProfileData.ownedSkins.includes(currentProfileData.selectedSkinId)) {
                currentProfileData.selectedSkinId = 'default';
            }
            if (!MAPS_CONFIG[currentProfileData.selectedMapId]) {
                currentProfileData.selectedMapId = 'classic';
            }
            currentMapId = currentProfileData.selectedMapId;

            updateUIAfterAuthChange();
        }

        function loadGuestData() {
            const savedGuestData = localStorage.getItem(GUEST_PROFILE_KEY);
            const defaultGuestProfile = getDefaultProfile();
            if (savedGuestData) {
                try {
                    const parsedData = JSON.parse(savedGuestData);
                    currentProfileData = {...defaultGuestProfile, ...parsedData};
                } catch (e) {
                    console.error("Error parsing guest data, resetting.", e);
                    currentProfileData = {...defaultGuestProfile};
                }
            } else {
                 currentProfileData = {...defaultGuestProfile};
            }
        }


        function savePlayerData() {
            currentProfileData.selectedMapId = currentMapId;

            if (currentUser) {
                const profiles = loadUserProfiles();
                if (profiles[currentUser]) {
                    profiles[currentUser].profileData = JSON.parse(JSON.stringify(currentProfileData));
                    saveUserProfiles(profiles);
                }
            } else {
                localStorage.setItem(GUEST_PROFILE_KEY, JSON.stringify(currentProfileData));
            }
            updateMoneyDisplay();
        }

        function updateUIAfterAuthChange() {
            if (currentUser) {
                loggedInUserDisplay.textContent = currentProfileData.username;
                loginRegisterButton.style.display = 'none';
                logoutButton.style.display = 'inline-block';
                usernameInputProfile.value = currentProfileData.username;
                usernameInputProfile.readOnly = false;
            } else {
                loggedInUserDisplay.textContent = currentProfileData.username;
                loginRegisterButton.style.display = 'inline-block';
                logoutButton.style.display = 'none';
                usernameInputProfile.value = currentProfileData.username;
                usernameInputProfile.readOnly = true;
            }
            updateMoneyDisplay();
            populateSkinSelector();
            updateMenuSkinPreview();
            if (profileScreen.classList.contains('active')) {
                populateProfileScreen();
            }
        }

        function updateGameStats(player1Won) {
            currentProfileData.gamesPlayed = (currentProfileData.gamesPlayed || 0) + 1;
            if (player1Won) {
                currentProfileData.wins = (currentProfileData.wins || 0) + 1;
                if(gameMode.startsWith('TDM')) currentProfileData.tdmWins = (currentProfileData.tdmWins || 0) + 1;
                if(gameMode === 'CTF') currentProfileData.ctfWins = (currentProfileData.ctfWins || 0) + 1;
                if (gameMode === 'vsCPU') {
                    if (currentAiDifficulty === 'HARD') {
                        currentProfileData.hardAIWins = (currentProfileData.hardAIWins || 0) + 1;
                    } else if (currentAiDifficulty === 'FREESTYLE') {
                        currentProfileData.freestyleAIWins = (currentProfileData.freestyleAIWins || 0) + 1;
                    }
                }
            } else {
                currentProfileData.losses = (currentProfileData.losses || 0) + 1;
            }
            savePlayerData();
            updateUIAfterAuthChange();
        }

        function updateMoneyDisplay() {
            playerMoneyDisplay.textContent = `$${currentProfileData.money || 0}`;
        }

        function addMoney(amount) {
            currentProfileData.money = (currentProfileData.money || 0) + amount;
            savePlayerData();
            updateUIAfterAuthChange();
        }

        let audioCtx;
        let shootGain;
        let musicPlaying = false;

        function initAudio() {
            if (audioCtx) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (!audioCtx) { console.warn("Web Audio API not supported."); musicToggleButton.disabled = true; return; }
                shootGain = audioCtx.createGain();
                shootGain.connect(audioCtx.destination);
                shootGain.gain.value = 0.1;
            } catch (e) {
                console.error("Error initializing Audio Context:", e);
                audioCtx = null;
            }
        }
        
        musicToggleButton.addEventListener('click', () => {
             if (backgroundMusic.paused) {
                backgroundMusic.play();
                musicToggleButton.textContent = "🎵 Mute";
            } else {
                backgroundMusic.pause();
                musicToggleButton.textContent = "🎵 Play";
            }
        });
        
        function firstInteractionListener() {
            initAudio();
            document.body.removeEventListener('click', firstInteractionListener);
            document.body.removeEventListener('touchstart', firstInteractionListener);
            document.body.removeEventListener('keydown', firstInteractionListener);
        }
        document.body.addEventListener('click', firstInteractionListener, { once: true });
        document.body.addEventListener('touchstart', firstInteractionListener, { once: true });
        document.body.addEventListener('keydown', firstInteractionListener, { once: true });

        function playShootSound(bulletType = 'default', skinId = 'default') {
            if (!audioCtx || audioCtx.state === 'suspended') {
                initAudio();
                 if (!audioCtx || audioCtx.state === 'suspended') return;
            }
            try {
                const now = audioCtx.currentTime;
                let osc, gain;

                if (skinId === 'heart_collab') {
                    osc = audioCtx.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(880, now); osc.frequency.exponentialRampToValueAtTime(440, now + 0.15);
                    gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.connect(gain); gain.connect(shootGain); osc.start(now); osc.stop(now + 0.2);
                    return;
                }
                 if (skinId === 'lapis') {
                    osc = audioCtx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(1500, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.05);
                    gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.connect(gain); gain.connect(shootGain); osc.start(now); osc.stop(now + 0.1);
                    return;
                }
                
                const skinData = SKINS[skinId] || SKINS['default'];
                if (skinId === 'golden_goliath') {
                    osc = audioCtx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(120, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                    gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.6, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.20);
                    osc.connect(gain); gain.connect(shootGain); osc.start(now); osc.stop(now + 0.20);
                } else if (skinId === 'bruiser') {
                    osc = audioCtx.createOscillator(); osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                    gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.9, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                    osc.connect(gain); gain.connect(shootGain); osc.start(); osc.stop(now + 0.16);
                } else if (skinId === 'scout') {
                    osc = audioCtx.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(900, now); osc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
                    gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.8, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                    osc.connect(gain); gain.connect(shootGain); osc.start(); osc.stop(now + 0.09);
                }
                else { // Default sound
                    osc = audioCtx.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                    gain = audioCtx.createGain(); gain.gain.setValueAtTime(1, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.connect(gain); gain.connect(shootGain); osc.start(); osc.stop(now + 0.11);
                }
            } catch (e) { console.warn("Error playing shoot sound:", e); }
        }

        function playAbilitySound(type) {
             if (!audioCtx || audioCtx.state === 'suspended') return;
             const now = audioCtx.currentTime;
             let osc, gain;
             if (type === 'AEGIS_FIELD') {
                osc = audioCtx.createOscillator(); osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
                gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                osc.connect(gain).connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.8);
             } else if (type === 'MULTI_DASH') {
                osc = audioCtx.createOscillator(); osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
                gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.25, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain).connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.15);
             } else if (type === 'REFLECT_SHIELD') {
                osc = audioCtx.createOscillator(); osc.type = 'square';
                osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(1000, now + 0.1);
                gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.connect(gain).connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.4);
             } else if (type === 'ENERGY_BALL') {
                osc = audioCtx.createOscillator(); osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, now); osc.frequency.exponentialRampToValueAtTime(400, now + 0.5);
                const distortion = audioCtx.createWaveShaper();
                distortion.curve = makeDistortionCurve(200);
                gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 1.2);
                osc.connect(distortion).connect(gain).connect(audioCtx.destination); osc.start(now); osc.stop(now + 1.2);
             } else if (type === 'TARGETED_GLOO_WALL') {
                osc = audioCtx.createOscillator(); osc.type = 'sine';
                osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(400, now + 0.1);
                osc.frequency.linearRampToValueAtTime(200, now + 0.4);
                gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.connect(gain).connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.5);
             } else if (type === 'PHASE_WALK') {
                osc = audioCtx.createOscillator(); osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.connect(gain).connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.5);
             } else if (type === 'HOOK_SHOT') {
                osc = audioCtx.createOscillator(); osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.2);
                gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.35, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.connect(gain).connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.2);
             } else if (type === 'VORTEX_ULTIMATE') {
                osc = audioCtx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(20, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.8);
                const distortion = audioCtx.createWaveShaper(); distortion.curve = makeDistortionCurve(400);
                gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.6, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                osc.connect(distortion).connect(gain).connect(audioCtx.destination); osc.start(now); osc.stop(now + 1.5);
             }
        }
        function makeDistortionCurve(amount) {
            let k = typeof amount === 'number' ? amount : 50, n_samples = 44100, curve = new Float32Array(n_samples), deg = Math.PI / 180, i = 0, x;
            for ( ; i < n_samples; ++i ) { x = i * 2 / n_samples - 1; curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) ); }
            return curve;
        }

        function normalizeAngle(angle) { angle = angle % (2 * Math.PI); if (angle < 0) angle += (2 * Math.PI); return angle; }
        function getShadedColor(hexColor, percent) { if (!hexColor || !hexColor.startsWith('#')) return '#808080'; let R = parseInt(hexColor.substring(1,3),16); let G = parseInt(hexColor.substring(3,5),16); let B = parseInt(hexColor.substring(5,7),16); R = parseInt(R * (100 + percent) / 100); G = parseInt(G * (100 + percent) / 100); B = parseInt(B * (100 + percent) / 100); R = Math.max(0, Math.min(255, R)); G = Math.max(0, Math.min(255, G)); B = Math.max(0, Math.min(255, B)); const RR = R.toString(16).padStart(2, '0'); const GG = G.toString(16).padStart(2, '0'); const BB = B.toString(16).padStart(2, '0'); return `#${RR}${GG}${BB}`; }

        class GlooWall {
            constructor(x, y, angle, owner) {
                this.owner = owner;
                this.angle = angle;
                const wallWidth = TANK_SIZE * 3.5;
                const wallThickness = TANK_SIZE * 0.4;
                
                this.x = x;
                this.y = y;
                this.width = wallWidth;
                this.height = wallThickness;

                const cosA = Math.cos(this.angle); const sinA = Math.sin(this.angle);
                const cosPerp = Math.cos(this.angle + Math.PI/2); const sinPerp = Math.sin(this.angle + Math.PI/2);
                this.p1 = { x: this.x + cosA*wallWidth/2 + cosPerp*wallThickness/2, y: this.y + sinA*wallWidth/2 + sinPerp*wallThickness/2 };
                this.p2 = { x: this.x - cosA*wallWidth/2 + cosPerp*wallThickness/2, y: this.y - sinA*wallWidth/2 + sinPerp*wallThickness/2 };
                this.p3 = { x: this.x - cosA*wallWidth/2 - cosPerp*wallThickness/2, y: this.y - sinA*wallWidth/2 - sinPerp*wallThickness/2 };
                this.p4 = { x: this.x + cosA*wallWidth/2 - cosPerp*wallThickness/2, y: this.y + sinA*wallWidth/2 - sinPerp*wallThickness/2 };

                this.startTime = Date.now();
                this.duration = SKINS.phantom.ability.wallDuration;
                this.health = SKINS.phantom.ability.wallHealth;
                this.active = true;
                this.id = 'gloo_' + this.startTime;
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.active = false;
                    for(let i=0; i<30; i++) {
                        particles.push({
                            x: this.x + (Math.random() - 0.5) * this.width,
                            y: this.y + (Math.random() - 0.5) * this.height,
                            vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                            size: Math.random() * 5 + 2,
                            life: 40 + Math.random() * 20,
                            color: `rgba(100, 20, 180, ${Math.random() * 0.5 + 0.3})`
                        });
                    }
                }
            }
            
            update() {
                if (Date.now() - this.startTime > this.duration) {
                    this.active = false;
                }
            }

            draw() {
                if (!this.active) return;
                
                const timeAlive = Date.now() - this.startTime;
                const alpha = Math.min(1, timeAlive / 500) * (0.6 + Math.sin(Date.now()/200)*0.05);
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = `rgba(150, 50, 255, ${alpha * 0.5})`;
                ctx.strokeStyle = `rgba(220, 180, 255, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = `rgba(150, 50, 255, ${alpha})`;
                ctx.shadowBlur = 15;

                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.restore();
            }
        }
        
        // [NEW] Hook class for Bruiser
        class Hook {
            constructor(startX, startY, angle, owner) {
                this.x = startX; this.y = startY;
                this.angle = angle; this.owner = owner;
                this.speed = 15;
                this.range = SKINS.bruiser.ability.range;
                this.distanceTraveled = 0;
                this.active = true;
                this.returning = false;
                this.hitTarget = null;
            }

            update() {
                if (!this.active) return;

                if (this.returning) {
                    if (this.hitTarget) {
                        const targetAngle = Math.atan2(this.owner.y - this.hitTarget.y, this.owner.x - this.hitTarget.x);
                        this.hitTarget.x += Math.cos(targetAngle) * this.speed;
                        this.hitTarget.y += Math.sin(targetAngle) * this.speed;
                    }
                    const angleToOwner = Math.atan2(this.owner.y - this.y, this.owner.x - this.x);
                    this.x += Math.cos(angleToOwner) * this.speed;
                    this.y += Math.sin(angleToOwner) * this.speed;
                    const distToOwner = Math.hypot(this.x - this.owner.x, this.y - this.owner.y);
                    if (distToOwner < this.owner.width / 2) {
                        this.active = false;
                        if(this.hitTarget) this.hitTarget.isBeingPulled = false;
                    }
                } else {
                    this.x += this.speed * Math.cos(this.angle);
                    this.y += this.speed * Math.sin(this.angle);
                    this.distanceTraveled += this.speed;

                    // Check for wall collision
                    if (this.x < 0 || this.x > G_MAP_WIDTH || this.y < 0 || this.y > G_MAP_HEIGHT) this.returning = true;
                    for (const obs of obstacles) if (pointInRect({x: this.x, y: this.y}, obs)) this.returning = true;
                    for (const tempObs of temporaryObstacles) if (tempObs.active && polygonPointIntersect(tempObs, {x: this.x, y: this.y})) this.returning = true;

                    // Check for target collision
                    for (const tank of allTanks) {
                        if (tank.health > 0 && tank !== this.owner && tank.team !== this.owner.team) {
                            const dist = Math.hypot(this.x - tank.x, this.y - tank.y);
                            if (dist < tank.width / 2) {
                                tank.takeDamage(SKINS.bruiser.ability.damage, this.owner.team);
                                tank.stun(SKINS.bruiser.ability.stunDuration);
                                tank.isBeingPulled = true;
                                this.hitTarget = tank;
                                this.returning = true;
                                break;
                            }
                        }
                    }

                    if (this.distanceTraveled >= this.range) this.returning = true;
                }
            }
            
            draw() {
                if(!this.active) return;
                ctx.save();
                // Draw chain
                ctx.beginPath();
                ctx.moveTo(this.owner.x, this.owner.y);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 5;
                ctx.stroke();
                // Draw hook
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/2);
                ctx.fillStyle = '#A9A9A9';
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 12, Math.PI * 0.8, Math.PI * 2.2);
                ctx.lineTo(0, -20);
                ctx.stroke();
                ctx.fill();
                ctx.restore();
            }
        }

        class Tank {
            constructor(id, x, y, angle, team, isAI = false, skinId = 'default', aiDifficulty = 'NORMAL', isPreview = false) {
                this.id = id; this.x = x; this.y = y; this.team = team; this.isAI = isAI; this.aiDifficulty = aiDifficulty; this.isPreview = isPreview;
                
                const skinDataToUse = JSON.parse(JSON.stringify(SKINS[skinId] || SKINS['default'])); 
                this.skinId = skinId;
                
                if (gameMode === 'CTF' && this.skinId === 'heart_collab') {
                    skinDataToUse.ability.maxCharges = 1;
                    skinDataToUse.ability.cooldown = 15000;
                }

                this.width = TANK_SIZE_BASE;
                this.height = TANK_SIZE_BASE;
                this.hullWidth = this.width * 0.95; this.hullHeight = this.height * 0.65;
                if (['heart_collab', 'soccer_collab', 'niwan_tank', 'lapis'].includes(skinId)) {
                    this.hullWidth = this.width * 0.8;
                    this.hullHeight = this.height * 0.9;
                }

                this.angle = angle;
                this.turretAngle = this.angle;
                this.color = skinDataToUse.color;
                if (this.team === 2 && skinDataToUse.p2Color) this.color = skinDataToUse.p2Color;
                if (this.team === 2 && skinId === 'default') this.color = SKINS['default'].p2Color;

                this.bulletColor = skinDataToUse.bulletColor || '#222222';
                this.bulletType = skinDataToUse.bulletType || 'normal';
                this.maxHealth = MAX_HEALTH_BASE * (skinDataToUse.healthMultiplier || 1);
                this.speed = BASE_TANK_SPEED * (skinDataToUse.speedMultiplier || 1);
                this.shootCooldownValue = SHOOT_COOLDOWN_BASE * (skinDataToUse.cooldownMultiplier || 1);
                this.originalShootCooldownValue = this.shootCooldownValue;
                this.bulletDamage = BASE_BULLET_DAMAGE * (skinDataToUse.damageMultiplier || 1);
                if(this.isAI) { this.bulletDamage *= 1.2; } // [MODIFICATION] AI damage increase
                this.skinSpecial = skinDataToUse.special;
                this.movementEffect = skinDataToUse.movementEffect;
                this.customDraw = skinDataToUse.customDraw || false;
                this.healthRegenRate = (this.skinSpecial === 'powerup_duration_boost_regen' ? 0.2 / 60 : 0);

                this.health = this.maxHealth;
                this.turnSpeed = TANK_TURN_SPEED; this.turretTurnSpeed = TURRET_TURN_SPEED; this.lastShotTime = 0;
                this.shielded = false; this.shieldTimer = 0;
                this.isImmortal = false; this.immortalTimer = 0;
                this.speedBoostActive = false; this.speedBoostTimer = 0;
                this.powerUpDurationMultiplier = 1; if (this.skinSpecial === 'powerup_duration_boost_regen' || this.skinSpecial === 'powerup_duration_boost') { this.powerUpDurationMultiplier = 1.30; }
                if (this.skinSpecial === 'starts_shielded_briefly') { this.shielded = true; this.shieldTimer = 6000; }
                if (this.isAI) { this.aiState = 'IDLE'; this.aiTarget = null; this.aiMoveCooldown = 0; this.aiLastPosition = { x: this.x, y: this.y }; this.aiStuckTimer = 0; this.AI_STUCK_THRESHOLD = 1500; this.AI_MIN_MOVE_DIST_FOR_STUCK_CHECK = 0.01; this.aiAimInaccuracyFactor = 0.45; this.aiShootingAngleTolerance = 0.5; this.aiCurrentAimOffset = 0; this.aiNextAimAdjustTimer = 0; this.aiHesitationFactor = 0.25; this.aiPostActionReactionTime = 300; this.aiGeneralReactionTimer = 0; this.aiTargetLostTimer = 0; this.AI_TARGET_LOST_PATROL_THRESHOLD = 4000; this.aiEvadeTimer = 0; this.aiIsDodgingBullet = false; this.currentDodgeAngle = 0; }
                this.hasMovedThisFrame = false;
                this.isStunned = false; this.stunTimer = 0;
                this.isBeingPulled = false; // [NEW] For Bruiser Hook
                this.isPhasing = false; // [NEW] For Sniper Phase Shift
                this.isEnergyBall = false;
                this.energyBallTimer = 0;
                this.reflectShieldPoints = null;
                this.hasFlag = null;

                this.ability = skinDataToUse.ability ? skinDataToUse.ability : null;
                if (this.ability) {
                     if (this.ability.type === 'MULTI_DASH') {
                        const isTeamMode = gameMode && (gameMode.startsWith('TDM') || gameMode === 'twoPlayer' || gameMode === 'CTF');
                        this.ability.maxCharges = isTeamMode && gameMode !== 'CTF' ? (this.ability.tdmMaxCharges || 2) : this.ability.maxCharges;
                        this.ability.currentCharges = this.ability.maxCharges;
                        this.ability.isChargeCooldown = false;
                    } else if (this.ability.type === 'ENERGY_BALL') {
                        this.energy = 0;
                    }
                }
                this.lastAbilityUseTime = 0;
                this.isAbilityActive = false;
                this.abilityDurationTimer = 0;
                this.abilityEffect = null;
                this.originalTurretTurnSpeed = this.turretTurnSpeed;

                if (!this.isPreview) {
                    this.healthBarContainer = document.createElement('div'); this.healthBarContainer.className = 'health-bar-container';
                    const healthWrapper = document.createElement('div'); healthWrapper.className = 'health-bar-wrapper';
                    this.healthBarDiv = document.createElement('div'); this.healthBarDiv.className = 'health-bar'; healthWrapper.appendChild(this.healthBarDiv);
                    this.healthBarContainer.appendChild(healthWrapper);
                    if (this.ability && this.ability.type === 'ENERGY_BALL') {
                        this.energyBarWrapper = document.createElement('div'); this.energyBarWrapper.className = 'energy-bar-wrapper';
                        this.energyBarDiv = document.createElement('div'); this.energyBarDiv.className = 'energy-bar'; this.energyBarWrapper.appendChild(this.energyBarDiv);
                        this.healthBarContainer.appendChild(this.energyBarWrapper);
                        this.updateEnergyBar();
                    }
                    this.shieldIndicatorDiv = document.createElement('div'); this.shieldIndicatorDiv.className = 'shield-indicator'; this.shieldIndicatorDiv.style.display = 'none'; this.healthBarContainer.appendChild(this.shieldIndicatorDiv);
                    this.immortalIndicatorDiv = document.createElement('div'); this.immortalIndicatorDiv.className = 'immortal-indicator'; this.immortalIndicatorDiv.style.display = 'none'; this.healthBarContainer.appendChild(this.immortalIndicatorDiv);
                    uiLayer.appendChild(this.healthBarContainer);
                    this.updateHealthBar(); 
                    this.updateHealthBarPosition();
                    this.updateSkillButtonDisplay();
                }
            }
            update(normalizedDeltaTime, rawDeltaTime_ms) {
                 if (gameState !== 'PLAYING' && this !== player1) return;
                 
                 if (this.isBeingPulled) return; // Don't allow movement while being pulled

                 if (this.isEnergyBall) { 
                    this.energyBallTimer -= rawDeltaTime_ms;
                    if (this.energyBallTimer <= 0) {
                        this.isEnergyBall = false;
                        this.isAbilityActive = false;
                    } else {
                        allTanks.forEach(tank => {
                            if (tank !== this && tank.team !== this.team && tank.health > 0) {
                                const dist = Math.hypot(this.x - tank.x, this.y - tank.y);
                                if (dist < this.ability.areaOfEffect) {
                                    tank.takeDamage(this.ability.damagePerSecond * (rawDeltaTime_ms / 1000), this.team);
                                }
                            }
                        });
                    }
                    return; 
                }
                if (this.isStunned) {
                    this.stunTimer -= rawDeltaTime_ms;
                    if (this.stunTimer <= 0) {
                        this.isStunned = false;
                        this.stunTimer = 0;
                    }
                    return;
                }
                if (this.healthRegenRate > 0 && this.health < this.maxHealth) { this.health += this.healthRegenRate * normalizedDeltaTime; if (this.health > this.maxHealth) this.health = this.maxHealth; this.updateHealthBar(); }
                this.updatePowerUps(rawDeltaTime_ms);
                this.updateAbility(rawDeltaTime_ms);
                this.updateSkillButtonDisplay();
            }
            draw() {
                if (this.isPhasing) {
                    ctx.save();
                    ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 150) * 0.2;
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 25;
                }

                if (this.hasFlag) {
                    const flag = flags.find(f => f.team === this.hasFlag);
                    if (flag) {
                        ctx.save();
                        ctx.font = '36px sans-serif';
                        ctx.globalAlpha = 0.8;
                        ctx.fillStyle = flag.color;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('🚩', this.x, this.y - this.height / 2 - 20);
                        ctx.restore();
                    }
                }

                if (this.isEnergyBall) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const pulse = 1 + Math.sin(Date.now() / 100) * 0.15;
                    ctx.fillStyle = `rgba(10, 5, 20, ${0.8 + Math.sin(Date.now() / 150) * 0.1})`;
                    ctx.strokeStyle = `rgba(138, 43, 226, ${0.7 + Math.sin(Date.now() / 200) * 0.3})`;
                    ctx.lineWidth = 4 * pulse;
                    ctx.shadowColor = '#8A2BE2';
                    ctx.shadowBlur = 25;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.8 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                    return;
                }
                if (this.isStunned) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 5;
                    ctx.font = 'bold 18px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('STUNNED', 0, -this.height / 2 - 25);
                    ctx.restore();
                }

                if (this.isAbilityActive && this.ability.type === 'AEGIS_FIELD') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const pulse = 1 + Math.sin(Date.now() / 150) * 0.1;
                    ctx.strokeStyle = `rgba(0, 191, 255, ${0.6 + Math.sin(Date.now() / 200) * 0.2})`;
                    ctx.fillStyle = `rgba(0, 191, 255, ${0.1 + Math.sin(Date.now() / 200) * 0.05})`;
                    ctx.lineWidth = 3 * pulse;
                    ctx.shadowColor = 'rgba(0, 191, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.8 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }

                if (this.customDraw) {
                    this.drawCustomSkin();
                } else {
                    this.drawStandardSkin();
                }

                if (this.isPhasing) {
                    ctx.restore();
                }
                
                if (this.skinId === 'rcb_champion' && this.isAbilityActive && this.reflectShieldPoints) {
                    ctx.save();
                    const pulse = 1 + Math.sin(Date.now() / 100) * 0.05;
                    ctx.fillStyle = `rgba(255, 215, 0, ${0.15 + Math.sin(Date.now() / 150) * 0.1})`;
                    ctx.strokeStyle = `rgba(255, 100, 0, ${0.8 + Math.sin(Date.now() / 200) * 0.2})`;
                    ctx.lineWidth = 5 * pulse;
                    ctx.shadowColor = 'gold';
                    ctx.shadowBlur = 20;

                    ctx.beginPath();
                    ctx.moveTo(this.reflectShieldPoints[0].x, this.reflectShieldPoints[0].y);
                    for (let i = 1; i < this.reflectShieldPoints.length; i++) {
                        ctx.lineTo(this.reflectShieldPoints[i].x, this.reflectShieldPoints[i].y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                }

                 if (this.hasMovedThisFrame && this.movementEffect) {
                    this.drawMovementTrail();
                }
            }
            drawStandardSkin() {
                ctx.save(); const skinData = SKINS[this.skinId] || SKINS['default']; let isPremiumSkin = skinData.price >= 1000 || this.skinId === 'golden_goliath' || this.skinId === 'phantom' || this.skinId === 'lapis'; if (isPremiumSkin && this.skinId !== 'golden_goliath') { let glowColor = 'rgba(255,255,255,0.7)'; if (this.skinId === 'phantom') glowColor = 'rgba(180, 80, 255, 0.7)'; else if (skinData.bulletColor) { const hex = skinData.bulletColor.replace('#', ''); if (hex.length === 6) { const r = parseInt(hex.substring(0,2), 16); const g = parseInt(hex.substring(2,4), 16); const b = parseInt(hex.substring(4,6), 16); if (r > 150 || g > 150 || b > 150) { glowColor = skinData.bulletColor.startsWith('rgba') ? skinData.bulletColor : skinData.bulletColor + 'b3'; } } } ctx.shadowColor = glowColor; ctx.shadowBlur = 12 + Math.sin(Date.now() / 250) * 4; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; } else if (this.skinId === 'golden_goliath') { ctx.shadowColor = 'rgba(255, 215, 0, 0.6)'; ctx.shadowBlur = 15 + Math.sin(Date.now() / 200) * 5; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; } ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); const bodyBaseColor = (this.skinId === 'golden_goliath') ? SKINS.golden_goliath.color : this.color; const trackColor = getShadedColor(bodyBaseColor, -40); const upperHullColor = bodyBaseColor; const detailColor = getShadedColor(bodyBaseColor, -20); const trackHeightActual = this.height * 0.4; const hullHeightActual = this.height * 0.6; const trackOffsetY = hullHeightActual / 2; ctx.fillStyle = trackColor; ctx.fillRect(-this.width / 2, trackOffsetY - trackHeightActual / 2, this.width, trackHeightActual); ctx.strokeStyle = getShadedColor(trackColor, -20); ctx.lineWidth = 2; const numTreads = 5; for (let i = 0; i <= numTreads; i++) { const xPos = -this.width / 2 + (i / numTreads) * this.width; ctx.beginPath(); ctx.moveTo(xPos, trackOffsetY - trackHeightActual / 2); ctx.lineTo(xPos, trackOffsetY + trackHeightActual / 2); ctx.stroke(); } ctx.fillStyle = upperHullColor; ctx.fillRect(-this.hullWidth / 2, -hullHeightActual / 2, this.hullWidth, hullHeightActual); if (this.skinId === 'golden_goliath') { ctx.strokeStyle = '#FFFACD'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(-this.hullWidth / 2, -hullHeightActual / 2); ctx.lineTo(this.hullWidth / 2, -hullHeightActual / 2); ctx.lineTo(this.hullWidth / 2, hullHeightActual / 2 - trackHeightActual*0.1); ctx.stroke(); } else { ctx.strokeStyle = detailColor; ctx.lineWidth = 1.5; ctx.strokeRect(-this.hullWidth / 2, -hullHeightActual / 2, this.hullWidth, hullHeightActual); } ctx.fillStyle = detailColor; ctx.beginPath(); ctx.arc(0, -hullHeightActual * 0.1, TANK_SIZE * 0.1, 0, Math.PI * 2); ctx.fill(); ctx.restore(); ctx.save(); ctx.translate(this.x, this.y); const turretRingColor = getShadedColor(bodyBaseColor, this.skinId === 'golden_goliath' ? -30 : -25); const turretRingRadius = TANK_SIZE * 0.22; ctx.fillStyle = turretRingColor; ctx.beginPath(); ctx.arc(0, 0, turretRingRadius, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = getShadedColor(turretRingColor, -15); ctx.lineWidth = 1; ctx.stroke(); ctx.rotate(this.turretAngle); const turretBaseActualColor = (this.skinId === 'golden_goliath') ? getShadedColor(bodyBaseColor, -5) : getShadedColor(bodyBaseColor, -10); ctx.fillStyle = turretBaseActualColor; ctx.fillRect(0, -TURRET_WIDTH / 2, TURRET_LENGTH, TURRET_WIDTH); if (this.skinId === 'golden_goliath') { ctx.strokeStyle = '#FFEEAA'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -TURRET_WIDTH/2); ctx.lineTo(TURRET_LENGTH, -TURRET_WIDTH/2); ctx.stroke(); } const muzzleColor = getShadedColor(turretBaseActualColor, -15); const muzzleWidth = TURRET_WIDTH * 1.3; const muzzleLength = TURRET_LENGTH * 0.15; ctx.fillStyle = muzzleColor; ctx.fillRect(TURRET_LENGTH, -muzzleWidth / 2, muzzleLength, muzzleWidth); ctx.restore(); if (this.skinId === 'golden_goliath' && this.hasMovedThisFrame) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); const flameLengthBase = TANK_SIZE * 0.45; const flameWidthBase = TANK_SIZE * 0.3; const pulse = Math.sin(Date.now() / 70) * 0.20 + 0.80; let flameLength = flameLengthBase * pulse; let flameWidth = flameWidthBase * pulse; if (this.speedBoostActive) { flameLength *= 1.6; flameWidth *= 1.4; } const flameOffsetX = -this.hullWidth / 2 - flameLength / 2 + 3; ctx.globalAlpha = 0.6 + Math.random() * 0.3; ctx.fillStyle = `rgba(255, 80, 0, ${ctx.globalAlpha})`; ctx.beginPath(); ctx.moveTo(flameOffsetX, -flameWidth / 2.5); ctx.bezierCurveTo(flameOffsetX - flameLength * 0.6, -flameWidth / 3, flameOffsetX - flameLength * 0.8, 0, flameOffsetX - flameLength, 0); ctx.bezierCurveTo(flameOffsetX - flameLength * 0.8, flameWidth / 3, flameOffsetX - flameLength * 0.6, flameWidth / 2.5, flameOffsetX, flameWidth / 2.5); ctx.closePath(); ctx.fill(); flameLength *= 0.55; flameWidth *= 0.55; ctx.globalAlpha = 0.75 + Math.random() * 0.2; ctx.fillStyle = `rgba(255, 200, 80, ${ctx.globalAlpha})`; ctx.beginPath(); ctx.moveTo(flameOffsetX, -flameWidth / 2.5); ctx.bezierCurveTo(flameOffsetX - flameLength * 0.6, -flameWidth / 3, flameOffsetX - flameLength * 0.8, 0, flameOffsetX - flameLength, 0); ctx.bezierCurveTo(flameOffsetX - flameLength * 0.8, flameWidth / 3, flameOffsetX - flameLength * 0.6, flameWidth / 2.5, flameOffsetX, flameWidth / 2.5); ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1.0; ctx.restore(); } ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.restore();
                if (this.shielded) { ctx.save(); ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.2; ctx.translate(this.x, this.y); ctx.strokeStyle = 'deepskyblue'; ctx.lineWidth = 4; ctx.shadowColor = 'rgba(0, 191, 255, 0.8)'; ctx.shadowBlur = 10 + Math.sin(Date.now() / 150) * 5; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; ctx.beginPath(); ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 8, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); }
                if (this.isImmortal) { ctx.save(); ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 150) * 0.3; ctx.translate(this.x, this.y); ctx.strokeStyle = 'gold'; ctx.lineWidth = 5; ctx.shadowColor = 'rgba(255, 215, 0, 0.9)'; ctx.shadowBlur = 12 + Math.sin(Date.now() / 120) * 6; ctx.beginPath(); ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 10, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); }
                if (!this.isPreview) this.updateHealthBarPosition();
            }
            drawCustomSkin() {
                const isNathania = this.skinId === 'heart_collab';
                const isLiam = this.skinId === 'soccer_collab';
                const isNiwan = this.skinId === 'niwan_tank';
                const isLapis = this.skinId === 'lapis';

                ctx.save();
                ctx.translate(this.x, this.y);
                
                // --- Body ---
                ctx.rotate(this.angle);

                if (isNathania) {
                    const chassisW = this.hullWidth; const chassisH = this.hullHeight; const treadW = this.width * 0.25; const treadOverhang = this.width * 0.1;
                    ctx.shadowColor = 'rgba(255, 20, 147, 0.6)'; ctx.shadowBlur = 15 + Math.sin(Date.now()/200)*3;
                    ctx.fillStyle = '#1a1a1a'; ctx.fillRect(-chassisW/2 - treadW + treadOverhang, -chassisH/2, treadW, chassisH); ctx.fillRect(chassisW/2 - treadOverhang, -chassisH/2, treadW, chassisH);
                    ctx.fillStyle = this.color; ctx.fillRect(-chassisW/2, -chassisH/2, chassisW, chassisH);
                    ctx.fillStyle = '#ff69b4'; ctx.shadowColor = '#ff69b4'; ctx.shadowBlur = 10; ctx.fillRect(-chassisW/2 - 5, -chassisH/4, 5, chassisH/2);
                } else if (isLapis) {
                    const chassisW = this.hullWidth; const chassisH = this.hullHeight;
                    // Glowing effect for Lapis skin
                    ctx.shadowColor = `rgba(148, 0, 211, ${0.5 + Math.sin(Date.now()/250)*0.2})`;
                    ctx.shadowBlur = 20 + Math.sin(Date.now()/250)*5;
                    // Main Body
                    ctx.fillStyle = this.color; ctx.fillRect(-chassisW/2, -chassisH/2, chassisW, chassisH);
                    // Accents
                    ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 1.5; ctx.strokeRect(-chassisW/2, -chassisH/2, chassisW, chassisH);
                    ctx.fillStyle = '#00BFFF'; ctx.beginPath(); ctx.arc(chassisW/2, 0, chassisW*0.1, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#9400D3'; ctx.beginPath(); ctx.arc(-chassisW/2, 0, chassisW*0.1, 0, Math.PI*2); ctx.fill();
                } else { // Fallback for Liam and Niwan
                    let glowColor = 'transparent';
                    if (isLiam) glowColor = 'rgba(0, 191, 255, 0.5)';
                    else if (isNiwan) glowColor = 'rgba(200, 200, 200, 0.4)';
                    ctx.shadowColor = glowColor; ctx.shadowBlur = 12;
                    const chassisW = this.hullWidth; const chassisH = this.hullHeight;
                    const treadW = this.width * 0.2; const treadOverhang = this.width * 0.05;
                    ctx.fillStyle = this.color; ctx.fillRect(-chassisW / 2, -chassisH / 2, chassisW, chassisH);
                    ctx.fillStyle = getShadedColor(this.color, -50);
                    ctx.fillRect(-chassisW / 2 - treadW + treadOverhang, -chassisH / 2, treadW, chassisH);
                    ctx.fillRect(chassisW / 2 - treadOverhang, -chassisH / 2, treadW, chassisH);
                }
                ctx.restore();

                // --- Turret ---
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.turretAngle); 
                const barrelW = this.width * 0.15;

                if (isNathania) {
                    const barrelL = this.height * 0.9; const turretBaseW = this.width * 0.4; const turretBaseH = this.height * 0.5;
                    ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.ellipse(0, 0, turretBaseW/2, turretBaseH/2, 0, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#282828'; ctx.fillRect(0, -barrelW/2, barrelL, barrelW);
                    ctx.fillStyle = '#ff69b4'; ctx.shadowColor = '#ff69b4'; ctx.shadowBlur = 12; ctx.fillRect(barrelL, -barrelW * 0.75, barrelW * 0.3, barrelW * 1.5);
                } else if (isLiam) {
                    const turretW = this.width * 0.7, turretH = this.height * 0.5; const barrelL = this.height * 0.9;
                    ctx.fillStyle = '#616161'; ctx.fillRect(0, -barrelW/2, barrelL, barrelW);
                    ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(0, 0, turretH/2, -Math.PI/2, Math.PI/2, false); ctx.fill();
                    ctx.fillStyle = this.color; const spikeWidth = this.width*0.1, spikeHeight = this.height*0.2, numSpikes = 3;
                    for (let i = 0; i < numSpikes; i++) { ctx.beginPath(); const baseX = turretH/2 * 0.8; const baseY = -turretH/2 + (turretH / (numSpikes+1) * (i+1)); ctx.moveTo(baseX, baseY - spikeWidth/2); ctx.lineTo(baseX, baseY + spikeWidth/2); ctx.lineTo(baseX + spikeHeight, baseY); ctx.closePath(); ctx.fill(); }
                } else if (isNiwan) {
                    const turretW = this.width * 0.7; const turretH = this.height * 0.4; const barrelL = this.height * 0.9;
                    ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(0, -turretH / 2); ctx.lineTo(turretW * 0.4, -turretH / 2); ctx.lineTo(turretW * 0.2, turretH / 2); ctx.lineTo(-turretW * 0.2, turretH / 2); ctx.lineTo(-turretW * 0.4, -turretH/2); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = getShadedColor(this.color, 40); ctx.fillRect(turretW * 0.1, -barrelW / 2, barrelL, barrelW);
                    ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(turretW * 0.1, 0); ctx.lineTo(turretW * 0.1 + barrelL, 0); ctx.stroke();
                } else if (isLapis) {
                    const barrelL = this.height * 0.8; const turretBaseW = this.width * 0.5;
                    ctx.shadowColor = `rgba(0, 191, 255, ${0.5 + Math.sin(Date.now()/200)*0.2})`;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#1a1a1a'; ctx.beginPath(); ctx.arc(0, 0, turretBaseW/2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#483D8B'; ctx.fillRect(0, -barrelW/2, barrelL, barrelW);
                    ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 1; ctx.strokeRect(0, -barrelW/2, barrelL, barrelW);
                }
                ctx.restore();
                if (this.shielded) { ctx.save(); ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.2; ctx.translate(this.x, this.y); ctx.strokeStyle = 'deepskyblue'; ctx.lineWidth = 4; ctx.shadowColor = 'rgba(0, 191, 255, 0.8)'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 8, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); }
                if (this.isImmortal) { ctx.save(); ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 150) * 0.3; ctx.translate(this.x, this.y); ctx.strokeStyle = 'gold'; ctx.lineWidth = 5; ctx.shadowColor = 'rgba(255, 215, 0, 0.9)'; ctx.shadowBlur = 12; ctx.beginPath(); ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 10, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); }
                if (!this.isPreview) this.updateHealthBarPosition();
            }
             drawMovementTrail() {
                let color1, color2;
                switch(this.movementEffect) {
                    case 'white_trail': color1 = '255, 255, 255'; break;
                    case 'pink_trail': color1 = '255, 105, 180'; break;
                    case 'blue_trail': color1 = '135, 206, 250'; break;
                    case 'purple_black_trail': color1 = '148, 0, 211'; color2 = '0, 191, 255'; break;
                    default: return;
                }
                const trailX = this.x - Math.cos(this.angle) * (this.width/2);
                const trailY = this.y - Math.sin(this.angle) * (this.height/2);
                for (let i=0; i<2; i++) {
                    let finalColor = color2 && Math.random() > 0.5 ? color2 : color1;
                    particles.push({
                        x: trailX + (Math.random() - 0.5) * this.width*0.5,
                        y: trailY + (Math.random() - 0.5) * this.height*0.5,
                        size: Math.random() * 4 + 2,
                        life: 25,
                        color: `rgba(${finalColor}, 0.8)`
                    });
                }
            }
            updateHealthBarPosition() { if (!this.healthBarContainer) return; const barX = (this.x - this.width / 2); const barY = (this.y - this.height / 2 - 25); this.healthBarContainer.style.transform = `translate(${barX}px, ${barY}px)`; }
            updateHealthBar() { if (!this.healthBarDiv) return; const healthPercentage = (this.health / this.maxHealth) * 100; this.healthBarDiv.style.width = healthPercentage + '%'; if (healthPercentage <= 0) this.healthBarDiv.style.backgroundColor = 'black'; else if (healthPercentage < 30) this.healthBarDiv.style.backgroundColor = 'red'; else if (healthPercentage < 60) this.healthBarDiv.style.backgroundColor = 'orange'; else this.healthBarDiv.style.backgroundColor = 'limegreen'; this.shieldIndicatorDiv.style.display = this.shielded ? 'block' : 'none'; this.immortalIndicatorDiv.style.display = this.isImmortal ? 'block' : 'none'; }
            updateEnergyBar() { if (!this.energyBarDiv || !this.ability || this.ability.type !== 'ENERGY_BALL') return; this.energyBarWrapper.style.display = 'block'; const energyPercentage = (this.energy / this.ability.maxEnergy) * 100; this.energyBarDiv.style.width = energyPercentage + '%'; }
            move(direction) { let currentSpeed = this.speed * (this.speedBoostActive ? (this.ability && this.ability.type === 'AEGIS_FIELD' && this.isAbilityActive ? this.ability.speedBoostMultiplier : 1.7) : 1); if (this.isAbilityActive && this.ability && this.ability.type === 'PHASE_WALK') { currentSpeed *= this.ability.speedMultiplier; } const prevX = this.x; const prevY = this.y; const hitBoxWidth = this.width * 0.9; const hitBoxHeight = this.height * 0.9; const newXUnchecked = this.x + direction * currentSpeed * Math.cos(this.angle); const newYUnchecked = this.y + direction * currentSpeed * Math.sin(this.angle); this.x = newXUnchecked; if (this.checkCollision(this.x, prevY, hitBoxWidth, hitBoxHeight) || this.checkBoundaryCollisionX()) { this.x = prevX; } this.y = newYUnchecked; if (this.checkCollision(prevX, this.y, hitBoxWidth, hitBoxHeight) || this.checkBoundaryCollisionY()) { this.y = prevY; } if(this.x !== prevX && this.y !== prevY && this.checkCollision(this.x, this.y, hitBoxWidth, hitBoxHeight)){ this.x = prevX; this.y = prevY; } if (direction !== 0 && (this.x !== prevX || this.y !== prevY)) { this.hasMovedThisFrame = true; if (this.skinId === 'niwan_tank' && this.ability.type === 'ENERGY_BALL') { this.gainEnergy(this.ability.chargeRate * currentSpeed); } } }
            checkBoundaryCollisionX() { return (this.x - this.width / 2 < 0 || this.x + this.width / 2 > G_MAP_WIDTH); }
            checkBoundaryCollisionY() { return (this.y - this.height / 2 < 0 || this.y + this.height / 2 > G_MAP_HEIGHT); }
            rotateBody(direction) { this.angle += direction * this.turnSpeed; if (direction !== 0) this.hasMovedThisFrame = true; }
            rotateTurret(direction) { this.turretAngle += direction * this.turretTurnSpeed; }
            setTurretAngle(targetAngle) { let current = (this.turretAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI); let target = (targetAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI); let diff = target - current; if (diff > Math.PI) diff -= 2 * Math.PI; if (diff < -Math.PI) diff += 2 * Math.PI; if (Math.abs(diff) < this.turretTurnSpeed * 1.1) { this.turretAngle = targetAngle; } else { this.turretAngle += Math.sign(diff) * this.turretTurnSpeed; } }
            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime > this.shootCooldownValue) {
                    const muzzleLength = TURRET_LENGTH * 0.15;
                    const bulletStartX = this.x + (TURRET_LENGTH + muzzleLength) * Math.cos(this.turretAngle);
                    const bulletStartY = this.y + (TURRET_LENGTH + muzzleLength) * Math.sin(this.turretAngle);
                    bullets.push(new Bullet(bulletStartX, bulletStartY, this.turretAngle, this, this.team, this.bulletDamage, this.bulletColor, this.bulletType));
                    this.lastShotTime = currentTime;
                    playShootSound.call(this, this.bulletType, this.skinId);
                    return true;
                } return false;
            }
            takeDamage(amount, instigatorTeam) {
                if (this.isEnergyBall) return;
                if (this.shielded || this.isImmortal || this.team === instigatorTeam) return;
                this.health -= amount; 
                if (!this.isPreview) this.updateHealthBar();
                if (this.health <= 0) { this.health = 0; this.destroy(instigatorTeam); }
                else if (this.isAI && this.aiDifficulty === "FREESTYLE" && this.aiEvadeTimer <= 0) { this.aiState = "EVADING"; this.aiEvadeTimer = 300 + Math.random() * 300; }
            }
            destroy(killerTeam) {
                if (this.hasFlag) {
                    const flag = flags.find(f => f.team === this.hasFlag);
                    if (flag) flag.drop(this.x, this.y);
                    this.hasFlag = null;
                }
                if (!this.isPreview) this.updateHealthBar();
                if (gameMode.startsWith('TDM')) {
                    if (killerTeam === 1) team1Score++; else if (killerTeam === 2) team2Score++;
                    ctfTeam1ScoreDisplay.textContent = team1Score;
                    ctfTeam2ScoreDisplay.textContent = team2Score;
                    if (team1Score >= TDM_SCORE_LIMIT) {
                        endGame("Team 1 (Blue) Wins!");
                    } else if (team2Score >= TDM_SCORE_LIMIT) {
                        endGame("Team 2 (Red) Wins!");
                    } else {
                        this.respawn();
                    }
                } else if (gameMode === 'CTF') {
                    this.respawn();
                } else {
                    const p1Wins = (this === player2);
                    const p2Wins = (this === player1);
                    if (p1Wins) {
                        let message = "Player 1 Wins!";
                        if (gameMode === 'vsCPU') {
                            let reward = 0; switch(currentAiDifficulty) { case 'EASY': reward = 5; break; case 'NORMAL': reward = 10; break; case 'HARD': reward = 20; break; case 'FREESTYLE': reward = 30; break; }
                            addMoney(reward); message += ` You earned $${reward}!`;
                        }
                        updateGameStats(true);
                        endGame(message);
                    } else if (p2Wins) {
                        updateGameStats(false);
                        endGame(gameMode === 'vsCPU' ? `${currentAiDifficulty} AI Wins!` : "Player 2 Wins!");
                    }
                }
            }
            respawn() {
                const mapConf = MAPS_CONFIG[currentMapId];
                const teamSpawns = mapConf.playerSpawns.filter(s => s.team === this.team);
                const spawnPoint = teamSpawns[Math.floor(Math.random() * teamSpawns.length)];
                this.x = spawnPoint.x; this.y = spawnPoint.y;
                this.angle = spawnPoint.angle; this.turretAngle = spawnPoint.angle;
                this.health = this.maxHealth; this.shielded = true; this.shieldTimer = 3000;
                if (!this.isPreview) this.updateHealthBar();
                if (this.ability && this.ability.type === 'ENERGY_BALL') {
                    this.energy = 0;
                    if (!this.isPreview) this.updateEnergyBar();
                }
            }
            checkCollision(checkX, checkY, colWidth = this.width, colHeight = this.height) { 
                if (this.isPhasing) { // Phasing tanks only collide with map boundaries
                    const tankRect = { x: checkX - colWidth / 2, y: checkY - colHeight / 2, width: colWidth, height: colHeight };
                    for (const obs of obstacles) { if (rectIntersect(tankRect, obs)) return true; }
                    return false;
                }
                const tankRect = { x: checkX - colWidth / 2, y: checkY - colHeight / 2, width: colWidth, height: colHeight }; 
                for (const obs of obstacles) { if (rectIntersect(tankRect, obs)) return true; } 
                for (const tempObs of temporaryObstacles) { if (tempObs.active && polygonRectIntersect(tempObs, tankRect)) return true; }
                for(const otherTank of allTanks) { if(otherTank !== this && otherTank.health > 0 && !otherTank.isPhasing) { const otherTankRect = { x: otherTank.x - otherTank.width / 2, y: otherTank.y - otherTank.height / 2, width: otherTank.width, height: otherTank.height }; if (rectIntersect(tankRect, otherTankRect)) return true; } } 
                return false; 
            }
            applyPowerUp(type) { const duration = POWERUP_DURATION_BASE * this.powerUpDurationMultiplier; if (type === 'shield') { this.shielded = true; this.shieldTimer = duration; this.shieldIndicatorDiv.style.display = 'block'; } else if (type === 'speed') { this.speedBoostActive = true; this.speedBoostTimer = duration; } else if (type === 'health') { this.health = Math.min(this.maxHealth, this.health + (MAX_HEALTH_BASE * 0.4)); if (!this.isPreview) this.updateHealthBar(); } }
            updatePowerUps(rawDeltaTime_ms) { if (this.shielded) { this.shieldTimer -= rawDeltaTime_ms; if (this.shieldTimer <= 0) { this.shielded = false; this.shieldTimer = 0; this.shieldIndicatorDiv.style.display = 'none'; } } if (this.speedBoostActive) { this.speedBoostTimer -= rawDeltaTime_ms; if (this.speedBoostTimer <= 0) { this.speedBoostActive = false; this.speedBoostTimer = 0; } } }

            canUseAbility() {
                if (!this.ability || gameState !== 'PLAYING') return false;
                if (this.ability.type === 'MULTI_DASH') {
                    return this.ability.currentCharges > 0 || (this.ability.currentCharges === 0 && !this.ability.isChargeCooldown);
                }
                if (this.ability.type === 'ENERGY_BALL') {
                    return this.energy >= this.ability.maxEnergy;
                }
                if (this.ability.type === 'PHASE_WALK' && gameMode === 'CTF') return false;
                return Date.now() - this.lastAbilityUseTime >= this.ability.cooldown;
            }
            
            gainEnergy(amount) {
                if (!this.ability || this.ability.type !== 'ENERGY_BALL') return;
                this.energy += amount;
                this.energy = Math.min(this.energy, this.ability.maxEnergy);
                if (!this.isPreview) this.updateEnergyBar();
            }

            stun(duration) {
                if(this.isImmortal || this.isEnergyBall) return;
                this.isStunned = true;
                this.stunTimer = Math.max(this.stunTimer, duration);
                if (this.isAI) {
                    this.aiState = 'IDLE';
                    this.aiMoveCooldown = duration;
                }
            }

            activateAbility() {
                if (!this.canUseAbility()) return;
                
                playAbilitySound(this.ability.type);

                if (this.ability.type === 'TARGETED_GLOO_WALL') {
                    gameState = 'AWAITING_GLOO_WALL_PLACEMENT';
                    targetingOverlay.style.display = 'block';
                    this.lastAbilityUseTime = Date.now();
                } else if (this.ability.type === 'HOOK_SHOT') {
                    gameState = 'AWAITING_HOOK_TARGET';
                    targetingOverlay.style.display = 'block';
                    this.lastAbilityUseTime = Date.now();
                } else if (this.ability.type === 'VORTEX_ULTIMATE') {
                    gameState = 'AWAITING_VORTEX_PLACEMENT';
                    targetingOverlay.style.display = 'block';
                    this.lastAbilityUseTime = Date.now();
                } else if (this.ability.type === 'MULTI_DASH') {
                    if (this.ability.currentCharges > 0) {
                        const oldX = this.x; const oldY = this.y;
                        const dashDistance = TANK_SIZE * 4; 
                        const dashX = this.x + dashDistance * Math.cos(this.angle);
                        const dashY = this.y + dashDistance * Math.sin(this.angle);
                        
                        let newX = this.x; let newY = this.y;
                        const tempX = Math.max(this.width / 2, Math.min(G_MAP_WIDTH - this.width / 2, dashX));
                        const tempY = Math.max(this.height / 2, Math.min(G_MAP_HEIGHT - this.height / 2, dashY));

                        if (!this.checkCollision(tempX, tempY)) {
                           this.x = tempX; this.y = tempY; newX = tempX; newY = tempY;
                        } else {
                            const shortDashX = this.x + (dashDistance/2) * Math.cos(this.angle); const shortDashY = this.y + (dashDistance/2) * Math.sin(this.angle);
                            const tempShortX = Math.max(this.width / 2, Math.min(G_MAP_WIDTH - this.width / 2, shortDashX)); const tempShortY = Math.max(this.height / 2, Math.min(G_MAP_HEIGHT - this.height / 2, shortDashY));
                            if (!this.checkCollision(tempShortX, tempShortY)) {
                                this.x = tempShortX; this.y = tempShortY; newX = tempShortX; newY = tempShortY;
                            }
                        }
                        const dx = newX - oldX; const dy = newY - oldY; const dist = Math.hypot(dx, dy);
                        if (dist > 1) { 
                            const trailCount = 20;
                            for (let i = 0; i < trailCount; i++) {
                                const progress = i / trailCount;
                                particles.push({ x: oldX + dx * progress + (Math.random() - 0.5) * 12, y: oldY + dy * progress + (Math.random() - 0.5) * 12, size: Math.random() * 5 + 3, life: 18 + Math.random() * 12, color: `rgba(255, 105, 180, ${0.9 - progress * 0.8})` });
                            }
                        }
                        this.ability.currentCharges--;
                        if (!this.ability.isChargeCooldown) {
                            this.ability.isChargeCooldown = true;
                            this.lastAbilityUseTime = Date.now();
                        }
                    }
                }
                else {
                    this.lastAbilityUseTime = Date.now();
                    this.isAbilityActive = true;

                    switch(this.ability.type) {
                        case 'ENERGY_BALL':
                            this.isEnergyBall = true;
                            this.energyBallTimer = this.ability.duration;
                            this.energy = 0;
                            if (!this.isPreview) this.updateEnergyBar();
                            break;
                        case 'PHASE_WALK':
                            this.isPhasing = true;
                            this.abilityDurationTimer = this.ability.duration;
                            if(this === player1) phaseShiftOverlay.style.display = 'block';
                            break;
                        case 'REFLECT_SHIELD':
                            this.abilityDurationTimer = this.ability.duration;
                            break;
                        case 'AEGIS_FIELD':
                            this.speedBoostActive = true; this.speedBoostTimer = this.ability.duration;
                            this.abilityDurationTimer = this.ability.duration;
                            if (gameMode.startsWith('TDM') || gameMode === 'CTF') {
                                activeEffects.push(new AbilityEffect(this.x, this.y, this.ability, this.team));
                            }
                            break;
                        case 'IMMORTAL_RAGE':
                            this.isImmortal = true; this.immortalTimer = this.ability.duration;
                            this.abilityDurationTimer = this.ability.duration;
                            break;
                    }
                }
                if (!this.isPreview) this.updateSkillButtonDisplay();
            }
            updateAbility(rawDeltaTime_ms) {
                if (this.isAbilityActive) {
                    this.abilityDurationTimer -= rawDeltaTime_ms;
                    
                    if (this.ability.type === 'REFLECT_SHIELD') { 
                        const shieldWidth = this.width * 1.8; const shieldDepth = this.width * 0.4; const shieldDist = this.width / 2 + 5;
                        const angle = this.turretAngle;
                        const cosA = Math.cos(angle); const sinA = Math.sin(angle); const cosP = Math.cos(angle + Math.PI/2); const sinP = Math.sin(angle + Math.PI/2);
                        const cx = this.x + shieldDist * cosA; const cy = this.y + shieldDist * sinA;
                        this.reflectShieldPoints = [ { x: cx - shieldWidth/2 * cosP, y: cy - shieldWidth/2 * sinP }, { x: cx - shieldWidth/3 * cosP + shieldDepth * cosA, y: cy - shieldWidth/3 * sinP + shieldDepth * sinA }, { x: cx + shieldWidth/3 * cosP + shieldDepth * cosA, y: cy + shieldWidth/3 * sinP + shieldDepth * sinA }, { x: cx + shieldWidth/2 * cosP, y: cy + shieldWidth/2 * sinP } ];
                    }

                    if(this.ability.type === 'AEGIS_FIELD' && this.health < this.maxHealth) {
                        this.health += this.ability.selfHealRate * (rawDeltaTime_ms / 1000);
                        this.health = Math.min(this.maxHealth, this.health);
                        if (!this.isPreview) this.updateHealthBar();
                    }

                    if (this.abilityDurationTimer <= 0) {
                        this.isAbilityActive = false;
                        this.abilityDurationTimer = 0;
                        if(this.ability.type === 'PHASE_WALK') { this.isPhasing = false; if(this === player1) phaseShiftOverlay.style.display = 'none'; }
                        if(this.ability.type === 'REFLECT_SHIELD') this.reflectShieldPoints = null;
                        if(this.ability.type === 'AEGIS_FIELD') { this.speedBoostActive = false; this.speedBoostTimer = 0; }
                        this.abilityEffect = null;
                    }
                }
                if (this.ability && this.ability.type === 'MULTI_DASH' && this.ability.isChargeCooldown) {
                    if (Date.now() - this.lastAbilityUseTime >= this.ability.cooldown) {
                        this.ability.currentCharges++;
                        this.lastAbilityUseTime = Date.now();
                        if(this.ability.currentCharges >= this.ability.maxCharges) {
                            this.ability.isChargeCooldown = false;
                            this.ability.currentCharges = this.ability.maxCharges;
                        }
                    }
                }
                if (this.isImmortal) {
                    this.immortalTimer -= rawDeltaTime_ms;
                    if (this.immortalTimer <= 0) {
                        this.isImmortal = false;
                        this.immortalTimer = 0;
                    }
                }
            }
            updateSkillButtonDisplay() {
                if (this.isPreview || this.isAI) return;
                let skillButtonElem;
                if (this === player1) skillButtonElem = skillButtonP1;
                else if (this === player2) skillButtonElem = skillButtonP2;
                else return;

                const skillNameTextElem = skillButtonElem.querySelector('.skill-name-text');
                const chargesTextElem = skillButtonElem.querySelector('.charges-text');
                const cooldownTextElem = skillButtonElem.querySelector('.cooldown-text');
                skillButtonElem.classList.remove('energy-ready');

                if (!this.ability) {
                    if (this === player1) skillButtonContainerP1.style.display = 'none';
                    if (this === player2) skillButtonContainerP2.style.display = 'none';
                    return;
                }

                if (this === player1) skillButtonContainerP1.style.display = 'flex';
                if (this === player2) skillButtonContainerP2.style.display = 'flex';

                skillNameTextElem.textContent = this.ability.name.toUpperCase();
                chargesTextElem.textContent = "";

                if (this.canUseAbility() && !this.isAbilityActive) {
                    skillButtonElem.classList.remove('on-cooldown');
                    skillButtonElem.disabled = false;
                    cooldownTextElem.textContent = "RDY";
                    if (this.ability.type === 'MULTI_DASH') {
                        chargesTextElem.textContent = `x${this.ability.currentCharges}`;
                        if (this.ability.currentCharges < this.ability.maxCharges && this.ability.isChargeCooldown) {
                             const remainingCooldown = Math.ceil((this.ability.cooldown - (Date.now() - this.lastAbilityUseTime)) / 1000);
                             cooldownTextElem.textContent = remainingCooldown > 0 ? `${remainingCooldown}s` : "RDY";
                        }
                    } else if (this.ability.type === 'ENERGY_BALL') {
                        skillButtonElem.classList.add('energy-ready');
                    }
                } else {
                    skillButtonElem.classList.add('on-cooldown');
                    skillButtonElem.disabled = true;
                    let remainingCooldown = 0;
                    if (this.isAbilityActive) {
                         remainingCooldown = Math.ceil(this.abilityDurationTimer / 1000);
                         skillNameTextElem.textContent = "ACTIVE";
                         cooldownTextElem.textContent = remainingCooldown > 0 ? `${remainingCooldown}s` : "RDY";
                    } else if (gameState !== 'PLAYING' && this === player1) {
                         skillNameTextElem.textContent = "AIMING";
                         cooldownTextElem.textContent = "TAP!";
                    } else if (this.ability.type === 'ENERGY_BALL') {
                        skillNameTextElem.textContent = "CHARGING";
                        cooldownTextElem.textContent = `${Math.floor((this.energy / this.ability.maxEnergy) * 100)}%`;
                    } else if (this.ability.type === 'MULTI_DASH' && this.ability.currentCharges < this.ability.maxCharges) {
                        const remainingChargeCooldown = Math.ceil((this.ability.cooldown - (Date.now() - this.lastAbilityUseTime)) / 1000);
                        cooldownTextElem.textContent = remainingChargeCooldown > 0 ? `${remainingChargeCooldown}s` : "RDY";
                        chargesTextElem.textContent = `x${this.ability.currentCharges}`;
                    } else {
                         remainingCooldown = Math.ceil((this.ability.cooldown - (Date.now() - this.lastAbilityUseTime)) / 1000);
                         cooldownTextElem.textContent = remainingCooldown > 0 ? `${remainingCooldown}s` : "RDY";
                    }
                     if (remainingCooldown <=0 && !this.isAbilityActive && !(this.ability.type === 'MULTI_DASH' && this.ability.currentCharges === 0) ) {
                        skillButtonElem.classList.remove('on-cooldown');
                        skillButtonElem.disabled = false;
                        cooldownTextElem.textContent = "RDY";
                        if (this.ability.type === 'MULTI_DASH') chargesTextElem.textContent = `x${this.ability.maxCharges}`;
                    }
                }
            }


            findClosestIncomingBullet(allBullets) { let closestBullet = null; let minDistance = Infinity; for (const bullet of allBullets) { if (bullet.owner === this) continue; const dist = Math.hypot(this.x - bullet.x, this.y - bullet.y); if (dist < minDistance) { const dx = this.x - bullet.x; const dy = this.y - bullet.y; const dotProduct = dx * Math.cos(bullet.angle) + dy * Math.sin(bullet.angle); if (dotProduct > 0) { minDistance = dist; closestBullet = bullet; } } } return closestBullet; }
            setAIDifficultyParameters() { 
                switch(this.aiDifficulty) { 
                    case 'EASY': this.aiAimInaccuracyFactor = 0.8; this.aiShootingAngleTolerance = 0.8; this.aiHesitationFactor = 0.6; this.aiPostActionReactionTime = 500; this.turretTurnSpeed = TURRET_TURN_SPEED * 0.7; break; 
                    case 'NORMAL': this.aiAimInaccuracyFactor = 0.4; this.aiShootingAngleTolerance = 0.45; this.aiHesitationFactor = 0.2; this.aiPostActionReactionTime = 250; this.turretTurnSpeed = TURRET_TURN_SPEED * 0.9; break; 
                    case 'HARD': this.aiAimInaccuracyFactor = 0.1; this.aiShootingAngleTolerance = 0.15; this.aiHesitationFactor = 0.03; this.aiPostActionReactionTime = 120; this.turretTurnSpeed = TURRET_TURN_SPEED * 1.1; break; 
                    case 'FREESTYLE': 
                        this.aiAimInaccuracyFactor = 0.005; this.aiShootingAngleTolerance = 0.03; this.aiHesitationFactor = 0; this.aiPostActionReactionTime = 25; this.AI_STUCK_THRESHOLD = 700; this.turretTurnSpeed = TURRET_TURN_SPEED * 1.3; 
                        this.speed *= 1.15; this.originalShootCooldownValue *= 0.8; this.shootCooldownValue = this.originalShootCooldownValue; this.bulletDamage *= 1.25; this.maxHealth *= 1.15; this.health = this.maxHealth;
                    break; 
                } 
            }
            aiAttemptShoot(targetAngle, targetIsShielded) { if (this.aiGeneralReactionTimer > 0) return; if (targetIsShielded && Math.random() < (this.aiDifficulty === 'EASY' ? 0.95 : (this.aiDifficulty === 'NORMAL' ? 0.8 : 0.6)) ) return; let turretNormalized = normalizeAngle(this.turretAngle); let targetNormalized = normalizeAngle(targetAngle); let diff = targetNormalized - turretNormalized; if (diff > Math.PI) diff -= 2 * Math.PI; if (diff < -Math.PI) diff += 2 * Math.PI; if (Math.abs(diff) < this.aiShootingAngleTolerance) { if (Math.random() > this.aiHesitationFactor) this.shoot(); this.aiGeneralReactionTimer = this.aiPostActionReactionTime + Math.random() * (this.aiDifficulty === 'EASY' ? 350 : (this.aiDifficulty === "FREESTYLE" ? 40 : 180) ); } }

            findBestTarget() {
                let bestTarget = null;
                let minDistance = Infinity;
                if (gameMode === 'CTF') {
                    const enemyFlag = flags.find(f => f.team !== this.team);
                    if (enemyFlag && enemyFlag.carrier && enemyFlag.carrier.health > 0) return enemyFlag.carrier;
                }
                for (const tank of allTanks) {
                    if (tank.team !== this.team && tank.health > 0) {
                        if (this.canSeeTarget(tank)) {
                            const dist = Math.hypot(this.x - tank.x, this.y - tank.y);
                            if (dist < minDistance) { minDistance = dist; bestTarget = tank; }
                        }
                    }
                }
                return bestTarget;
            }

            updateAI(deltaTime) {
                if (!this.isAI || this.health <= 0 || this.isStunned || this.isBeingPulled || gameState !== 'PLAYING') return;
                if (!this.aiTarget || this.aiTarget.health <= 0 || Math.random() < 0.05) this.aiTarget = this.findBestTarget();
                if (!this.aiAimInaccuracyFactor) this.setAIDifficultyParameters();
                
                this.aiMoveCooldown -= deltaTime; if (this.aiEvadeTimer > 0) this.aiEvadeTimer -= deltaTime; if (this.aiGeneralReactionTimer > 0) this.aiGeneralReactionTimer -= deltaTime; this.aiNextAimAdjustTimer -= deltaTime; const distMovedSqr = (this.x - this.aiLastPosition.x)**2 + (this.y - this.aiLastPosition.y)**2; if (distMovedSqr < this.AI_MIN_MOVE_DIST_FOR_STUCK_CHECK) { this.aiStuckTimer += deltaTime; } else { this.aiStuckTimer = 0; } this.aiLastPosition = { x: this.x, y: this.y }; 
                if (this.aiStuckTimer > this.AI_STUCK_THRESHOLD) { this.angle = normalizeAngle(this.angle + (Math.random() > 0.5 ? 1 : -1) * Math.PI/2); this.move(-1); this.aiStuckTimer = 0; this.aiMoveCooldown = 500; return; } 
                if (this.aiDifficulty === "FREESTYLE") { this.aiCurrentAimOffset = (Math.random() - 0.5) * 0.01; } else if (this.aiNextAimAdjustTimer <= 0) { this.aiCurrentAimOffset = (Math.random() - 0.5) * 2 * this.aiAimInaccuracyFactor; this.aiNextAimAdjustTimer = 500 + Math.random() * (this.aiDifficulty === 'EASY' ? 900 : 600); }

                if (!this.aiTarget) {
                    this.aiState = 'PATROLLING'; this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.25); if (this.aiMoveCooldown <= 0) { this.aiSmartTurn(this.angle + (Math.random() -0.7) * Math.PI / 2.2, null); this.move(0.55 + Math.random()*0.25); this.aiMoveCooldown = Math.random() * 1700 + 900; }
                    return;
                }

                const targetTank = this.aiTarget;
                const trueAngleToTarget = Math.atan2(targetTank.y - this.y, targetTank.x - this.x); let effectiveAimAngle = trueAngleToTarget + this.aiCurrentAimOffset; if (this.aiDifficulty === "FREESTYLE" && targetTank.speed > 0.01 && targetTank.hasMovedThisFrame) { const distToTargetForPred = Math.hypot(targetTank.x - this.x, targetTank.y - this.y); const timeToBulletHit = distToTargetForPred / BULLET_SPEED_BASE; const targetCurrentSpeedValue = targetTank.speed * (targetTank.speedBoostActive ? 1.7 : 1); const predictedTargetX = targetTank.x + Math.cos(targetTank.angle) * targetCurrentSpeedValue * timeToBulletHit; const predictedTargetY = targetTank.y + Math.sin(targetTank.angle) * targetCurrentSpeedValue * timeToBulletHit; effectiveAimAngle = Math.atan2(predictedTargetY - this.y, predictedTargetX - this.x) + this.aiCurrentAimOffset; } const distanceToTarget = Math.hypot(this.x - targetTank.x, this.y - targetTank.y); const canSee = this.canSeeTarget(targetTank); let closestPowerUp = null; let minDistToPowerUp = Infinity; if (canSee) this.aiTargetLostTimer = 0; else this.aiTargetLostTimer += deltaTime; if (this.aiDifficulty === "FREESTYLE" && this.aiEvadeTimer <= 0 && this.aiGeneralReactionTimer <= 0) { let incomingBullet = this.findClosestIncomingBullet(bullets); if (incomingBullet) { const B_DIST_THRESHOLD = this.width * (this.aiDifficulty === "FREESTYLE" ? 6 : 4.5); const B_ANGLE_THRESHOLD = Math.PI / (this.aiDifficulty === "FREESTYLE" ? 3.0 : 3.8); const distToBullet = Math.hypot(this.x - incomingBullet.x, this.y - incomingBullet.y); if (distToBullet < B_DIST_THRESHOLD) { const angleFromBulletToTank = Math.atan2(this.y - incomingBullet.y, this.x - incomingBullet.x); let angleDiff = Math.abs(normalizeAngle(incomingBullet.angle - angleFromBulletToTank)); if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff; if (angleDiff < B_ANGLE_THRESHOLD) { this.aiState = "EVADING"; this.aiEvadeTimer = (this.aiDifficulty === "FREESTYLE" ? 200 : 280) + Math.random() * 120; this.currentDodgeAngle = normalizeAngle(incomingBullet.angle + (Math.random() < 0.5 ? Math.PI / 1.8 : -Math.PI / 1.8)); this.aiIsDodgingBullet = true; this.aiMoveCooldown = 40; } } } } const seekPowerUpChance = this.aiDifficulty === 'EASY' ? 0.15 : (this.aiDifficulty === 'NORMAL' ? 0.35 : 0.75); if (this.health < this.maxHealth * (this.aiDifficulty === 'EASY' ? 0.9 : (this.aiDifficulty === "FREESTYLE" ? 0.85 : 0.75)) || (!this.shielded && Math.random() < seekPowerUpChance)) { powerUps.forEach(p => { if (p.active) { const dist = Math.hypot(this.x - p.x, this.y - p.y); if (dist < minDistToPowerUp) { minDistToPowerUp = dist; closestPowerUp = p; } } }); } if (this.aiState === "EVADING" && this.aiEvadeTimer > 0) { /* Stay in evading */ } else if (this.aiTargetLostTimer > this.AI_TARGET_LOST_PATROL_THRESHOLD && this.aiDifficulty !== 'EASY') { this.aiState = 'PATROLLING'; } else if (closestPowerUp && minDistToPowerUp < G_MAP_WIDTH / (this.aiDifficulty === 'EASY' ? 5.5 : (this.aiDifficulty === "FREESTYLE" ? 2.8 : 3.2)) && (this.health < this.maxHealth * (this.aiDifficulty === 'EASY' ? 0.85 : (this.aiDifficulty === "FREESTYLE" ? 0.75 : 0.65)) || (closestPowerUp.type === 'shield' && !this.shielded && Math.random() < (this.aiDifficulty === 'EASY' ? 0.25 : (this.aiDifficulty === "FREESTYLE" ? 0.85 : 0.65))))) { this.aiState = 'SEEKING_POWERUP'; } else if (canSee && distanceToTarget < this.width * (this.aiDifficulty === 'FREESTYLE' ? 7.5 : 5.5) ) { this.aiState = 'ATTACKING_CLOSE'; } else if (canSee && distanceToTarget < G_MAP_WIDTH / (this.aiDifficulty === 'FREESTYLE' ? 1.2 : 1.8)) { this.aiState = 'ATTACKING_RANGED'; } else if (distanceToTarget > G_MAP_WIDTH / 1.2 && this.aiDifficulty !== 'EASY') { this.aiState = 'SEEKING_PLAYER'; } else if (!canSee && this.aiMoveCooldown <=0 && this.aiDifficulty !== 'EASY' && this.aiState !== 'PATROLLING') { this.aiState = 'REPOSITIONING'; } else if (this.aiMoveCooldown <=0 && this.aiState !== 'PATROLLING' && this.aiState !== "EVADING") { this.aiState = 'IDLE'; } 
                
                // [MODIFICATION] Freestyle AI skill usage
                if (this.aiDifficulty === 'FREESTYLE' && this.aiState.startsWith('ATTACKING') && this.canUseAbility()) {
                    if (this.ability.type === 'HOOK_SHOT' && distanceToTarget <= this.ability.range) {
                        hooks.push(new Hook(this.x, this.y, effectiveAimAngle, this));
                        this.lastAbilityUseTime = Date.now();
                    } else if (this.ability.type === 'VORTEX_ULTIMATE') {
                        activeEffects.push(new AbilityEffect(targetTank.x, targetTank.y, this.ability, this.team));
                        this.lastAbilityUseTime = Date.now();
                    } else if (this.ability.type !== 'HOOK_SHOT' && this.ability.type !== 'VORTEX_ULTIMATE') { // for other skills like phase walk, etc.
                        this.activateAbility();
                    }
                }
                
                if (this.aiState === "EVADING" && this.aiEvadeTimer > 0) { this.setTurretAngle(effectiveAimAngle); if (this.aiMoveCooldown <= 0) { let moveDir = 1; if (this.aiIsDodgingBullet) { this.angle = this.currentDodgeAngle; } else { this.angle = normalizeAngle(trueAngleToTarget + Math.PI + (Math.random() - 0.5) * Math.PI/1.8); } if (!this.isPathClear(this.angle, this.speed * 1.6, targetTank)) { if (!this.isPathClear(this.angle, -this.speed * 1.6, targetTank)) { this.aiSmartTurn(this.angle, targetTank); if(this.isPathClear(this.angle, this.speed * 0.6, targetTank)) this.move(0.6); } else { moveDir = -1; this.move(moveDir * 1.1); } } else { this.move(moveDir * 1.4); } this.aiIsDodgingBullet = false; this.aiMoveCooldown = 80 + Math.random() * 80; } if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); return; } switch(this.aiState) { case 'PATROLLING': this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.25); if (this.aiMoveCooldown <= 0) { this.aiSmartTurn(this.angle + (Math.random() -0.7) * Math.PI / 2.2, targetTank); this.move(0.55 + Math.random()*0.25); this.aiMoveCooldown = Math.random() * 1700 + 900; } if (canSee) { this.aiTargetLostTimer = 0; this.aiState = 'ATTACKING_RANGED'; } break; case 'SEEKING_POWERUP': const angleToPowerUp = Math.atan2(closestPowerUp.y - this.y, closestPowerUp.x - this.x); this.setTurretAngle(canSee ? effectiveAimAngle : angleToPowerUp); if (!this.isPathClearToPoint(closestPowerUp.x, closestPowerUp.y, targetTank)) { this.aiSmartTurn(angleToPowerUp, targetTank); if(this.isPathClear(this.angle, this.speed * 0.85, targetTank)) this.move(0.55); } else { this.angle = angleToPowerUp; this.move(1.05); } if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); break; case 'ATTACKING_CLOSE': this.setTurretAngle(effectiveAimAngle); this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); if (this.aiMoveCooldown <= 0) { let strafeAngle = normalizeAngle(trueAngleToTarget + (Math.random() < 0.5 ? Math.PI/2.1 : -Math.PI/2.1)); if (this.aiDifficulty === "FREESTYLE" && distanceToTarget < this.width * 2.5) { strafeAngle = normalizeAngle(trueAngleToTarget + Math.PI); } if(this.isPathClear(strafeAngle, this.width*1.6, targetTank)){ this.angle = strafeAngle; this.move(0.75 + Math.random()*0.25); } else { this.aiSmartTurn(strafeAngle, targetTank); if(this.isPathClear(this.angle, this.speed*0.85, targetTank)) this.move(0.55 + Math.random()*0.25); } this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 900 : (this.aiDifficulty === "FREESTYLE" ? 200 : 600)) + (this.aiDifficulty === 'EASY' ? 450 : (this.aiDifficulty === "FREESTYLE" ? 80 : 250)); } break; case 'ATTACKING_RANGED': this.setTurretAngle(effectiveAimAngle); this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); if (this.aiMoveCooldown <= 0) { if (this.aiDifficulty === "FREESTYLE") { if (Math.random() < 0.92) { let moveAngleOffset = (Math.random() - 0.5) * Math.PI / 1.7; if (Math.random() < 0.38) { moveAngleOffset = (distanceToTarget > G_MAP_WIDTH / 2.3) ? 0 : Math.PI; } const intendedMoveAngle = normalizeAngle(trueAngleToTarget + moveAngleOffset); if (this.isPathClear(intendedMoveAngle, this.speed * 2.1, targetTank)) { this.angle = intendedMoveAngle; this.move(0.65 + Math.random() * 0.35); } else { this.aiSmartTurn(trueAngleToTarget, targetTank); if (this.isPathClear(this.angle, this.speed * 1.1, targetTank)) this.move(0.35); } } } else if (Math.random() < (this.aiDifficulty === 'EASY' ? 0.15 : 0.35)) { this.aiSmartTurn(trueAngleToTarget + (Math.random()-0.5) * Math.PI / 2.8, targetTank); if(this.isPathClear(this.angle, this.speed * 0.55, targetTank)) this.move(0.25 + Math.random()*0.25); } this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 1100 : (this.aiDifficulty === "FREESTYLE" ? 280 : 800)) + (this.aiDifficulty === 'EASY' ? 650 : (this.aiDifficulty === "FREESTYLE" ? 130 : 450)); } break; case 'SEEKING_PLAYER': this.setTurretAngle(effectiveAimAngle); if (!this.isPathClearToPoint(targetTank.x, targetTank.y, targetTank, this.width*2.8)) { this.aiSmartTurn(trueAngleToTarget, targetTank); if(this.isPathClear(this.angle, this.speed * 0.85, targetTank)) this.move(0.65 + Math.random()*0.25); } else { this.angle = trueAngleToTarget; this.move(0.95 + Math.random()*0.25); } if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded); break; case 'REPOSITIONING': this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.4 ); if (this.aiMoveCooldown <= 0) { this.aiSmartTurn(this.angle + (Math.random() - 0.5) * Math.PI / 1.9, targetTank); if(this.isPathClear(this.angle, this.speed * 0.85, targetTank)) this.move(0.75 + Math.random()*0.35); this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 800 : (this.aiDifficulty === "FREESTYLE" ? 200 : 450)) + (this.aiDifficulty === 'EASY' ? 350 : (this.aiDifficulty === "FREESTYLE" ? 70 : 180)); } break; case 'IDLE': default: this.setTurretAngle(this.turretAngle + (Math.random()-0.5)*0.2); if (this.aiMoveCooldown <= 0) { if (Math.random() < (this.aiDifficulty === 'EASY' ? 0.35 : (this.aiDifficulty === "FREESTYLE" ? 0.8 : 0.6))) { this.aiSmartTurn(this.angle + (Math.random() - 0.5) * Math.PI / (this.aiDifficulty === "FREESTYLE" ? 1.1 : 1.7), targetTank); if(this.isPathClear(this.angle, this.speed * 0.65, targetTank)) this.move(0.45 + Math.random() * (this.aiDifficulty === "FREESTYLE" ? 0.55 : 0.25)); } this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 1700 : (this.aiDifficulty === "FREESTYLE" ? 350 : 1200)) + (this.aiDifficulty === 'EASY' ? 900 : (this.aiDifficulty === "FREESTYLE" ? 180 : 600)); } break; } if(this.aiMoveCooldown <= 0 && this.aiState !== 'EVADING') { this.aiSmartTurn(this.angle + (Math.random() - 0.5) * 0.35, targetTank); if (Math.random() < 0.25 && this.isPathClear(this.angle, this.speed * 0.55, targetTank)) this.move(0.35); this.aiMoveCooldown = 180 + Math.random() * 180; }
            }
            aiSmartTurn(desiredAngle, targetTankToAvoid = null) { let bestTurn = 0; let maxClearDistance = 0; const anglesToTest = [0, Math.PI / 6, -Math.PI / 6, Math.PI / 3, -Math.PI / 3, Math.PI / 2, -Math.PI / 2, 2*Math.PI/3, -2*Math.PI/3, Math.PI*0.9]; for (const offset of anglesToTest) { const testAngle = normalizeAngle(desiredAngle + offset); let currentPathClearDistance = 0; for (let d = this.width * 0.6; d <= this.width * 4.5; d += this.width * 0.6) { if (this.isPathClear(testAngle, d, targetTankToAvoid)) { currentPathClearDistance = d; } else { break; } } if (currentPathClearDistance > maxClearDistance) { maxClearDistance = currentPathClearDistance; bestTurn = testAngle; } } if (maxClearDistance > this.width * 0.6) { this.angle = bestTurn; } else { this.angle = normalizeAngle(desiredAngle + (Math.random() < 0.5 ? Math.PI * 0.8 : -Math.PI * 0.8) + (Math.random() - 0.5) * 0.6); } }
            isPathClear(angle, distance, otherTankToAvoid = null) { const checkFeelerCount = 3; const feelerOffsetDist = this.width / 3.3; const cosAngle = Math.cos(angle); const sinAngle = Math.sin(angle); const cosPerp = Math.cos(angle + Math.PI / 2); const sinPerp = Math.sin(angle + Math.PI / 2); for (let i = 0; i < checkFeelerCount; i++) { let offsetX = 0; let offsetY = 0; if (i === 1) { offsetX = feelerOffsetDist * cosPerp; offsetY = feelerOffsetDist * sinPerp; } else if (i === 2) { offsetX = -feelerOffsetDist * cosPerp; offsetY = -feelerOffsetDist * sinPerp; } const projectedRectCenterX = this.x + offsetX + distance * cosAngle; const projectedRectCenterY = this.y + offsetY + distance * sinAngle; const projectedRect = { x: projectedRectCenterX - this.width / 3.8, y: projectedRectCenterY - this.height / 3.8, width: this.width / 1.9, height: this.height / 1.9 }; if (projectedRect.x < 0 || projectedRect.x + projectedRect.width > G_MAP_WIDTH || projectedRect.y < 0 || projectedRect.y + projectedRect.height > G_MAP_HEIGHT) { return false; } for (const obs of obstacles) { if (rectIntersect(projectedRect, obs)) return false; } for (const tempObs of temporaryObstacles) { if (tempObs.active && polygonRectIntersect(tempObs, projectedRect)) return false; } if (otherTankToAvoid && otherTankToAvoid.health > 0 && otherTankToAvoid !== this) { const otherTankHitbox = { x: otherTankToAvoid.x - otherTankToAvoid.width / 2, y: otherTankToAvoid.y - otherTankToAvoid.height / 2, width: otherTankToAvoid.width, height: otherTankToAvoid.height }; if (rectIntersect(projectedRect, otherTankHitbox)) return false; } } return true; }
            isPathClearToPoint(targetX, targetY, otherTankToAvoid = null, maxDist = G_MAP_WIDTH * 1.5) { const dx = targetX - this.x; const dy = targetY - this.y; const distToTarget = Math.hypot(dx, dy); if (distToTarget === 0) return true; if (maxDist > 0 && distToTarget > maxDist) return false; const angleToTarget = Math.atan2(dy, dx); const checkDist = Math.max(0, distToTarget - (this.width / 1.8) - (otherTankToAvoid ? otherTankToAvoid.width / 1.8 : 0)); return this.isPathClear(angleToTarget, checkDist, otherTankToAvoid); }
            canSeeTarget(target) { if (!target || target.health <= 0) return false; return this.isPathClearToPoint(target.x, target.y, target); }
        }

        function drawHeart(ctx, x, y, angle, size, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle - Math.PI / 2);
            const s = size / 2;
            ctx.fillStyle = color;
            ctx.shadowColor = 'rgba(255, 20, 147, 0.7)';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(0, -s);
            ctx.bezierCurveTo(s, -s * 1.5, s * 1.5, -s * 0.5, 0, s);
            ctx.bezierCurveTo(-s * 1.5, -s * 0.5, -s, -s * 1.5, 0, -s);
            ctx.fill();
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.restore();
        }
        function drawSoccerBall(ctx, x, y, angle, size, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Date.now()/500);
            const r = size / 2;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
            ctx.shadowBlur = 10;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.moveTo(r * 0.6, 0);
            ctx.arc(0, 0, r * 0.65, 0, Math.PI * 0.4);
            ctx.lineTo(r * 0.2, r * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * -0.3, r * 0.5);
            ctx.arc(0, 0, r * 0.6, Math.PI * 0.7, Math.PI * 1.1);
            ctx.lineTo(r * -0.5, 0);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * -0.3, r * -0.5);
            ctx.arc(0, 0, r * 0.6, Math.PI * 1.3, Math.PI * 1.7);
            ctx.lineTo(r * 0.1, r * -0.1);
            ctx.closePath();
            ctx.fill();
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.restore();
        }
        function drawPetal(ctx, x, y, angle, size, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = color;
            ctx.shadowColor = 'rgba(255,255,255,0.8)';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            const s = size * 0.7;
            ctx.moveTo(0,0);
            ctx.quadraticCurveTo(s, s, 0, s*2);
            ctx.quadraticCurveTo(-s, s, 0, 0);
            ctx.fill();
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.restore();
        }
        function drawShuriken(ctx, x, y, angle, size, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Date.now() / 100);
            const s = size * 0.8;
            ctx.fillStyle = '#444444';
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.shadowColor = '#FFFFFF';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(0, -s); // Top
            ctx.lineTo(s * 0.3, -s * 0.3);
            ctx.lineTo(s, 0); // Right
            ctx.lineTo(s * 0.3, s * 0.3);
            ctx.lineTo(0, s); // Bottom
            ctx.lineTo(-s * 0.3, s * 0.3);
            ctx.lineTo(-s, 0); // Left
            ctx.lineTo(-s * 0.3, -s * 0.3);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Center hole
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        class Bullet {
            constructor(x, y, angle, owner, team, damage = BASE_BULLET_DAMAGE, color = '#222222', type = 'normal') {
                this.x = x; this.y = y; this.angle = angle; this.speed = BULLET_SPEED_BASE;
                this.size = BULLET_SIZE; this.owner = owner; this.team = team; this.damage = damage;
                this.color = color; this.type = type;
                this.trail = [];
                this.maxTrailLength = 5;

                if (this.type === 'heart' || this.type === 'petal' || this.type === 'shuriken') { this.size *= 1.8; }
                else if (this.type === 'soccerball') { this.size *= 1.5; }
            }
            draw() {
                ctx.save();
                for (let i = 0; i < this.trail.length; i++) {
                    const pos = this.trail[i];
                    const alpha = (i / this.trail.length) * 0.3;
                    let trailColor;
                    if (this.type === 'heart') trailColor = 'rgba(148, 0, 211,' + alpha + ')';
                    else if (this.type === 'soccerball') trailColor = 'rgba(200, 200, 200,' + alpha + ')';
                    else trailColor = this.color.startsWith('#') ? this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0') : `rgba(${parseInt(this.color.slice(1,3),16)},${parseInt(this.color.slice(3,5),16)},${parseInt(this.color.slice(5,7),16)},${alpha})`;
                    ctx.fillStyle = trailColor;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, (this.size / 2) * ((i+1) / this.trail.length), 0, Math.PI * 2);
                    ctx.fill();
                }

                if (this.owner && this.owner.skinId === 'golden_goliath') {
                    ctx.save();
                    ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                    const missileLength = this.size * 2.5; const missileWidth = this.size * 0.8;
                    ctx.fillStyle = SKINS.golden_goliath.bulletColor; ctx.shadowColor = 'rgba(255, 140, 0, 0.9)'; ctx.shadowBlur = 12;
                    ctx.fillRect(-missileLength / 2, -missileWidth / 2, missileLength, missileWidth);
                    ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.moveTo(missileLength / 2, -missileWidth / 2); ctx.lineTo(missileLength / 2 + missileLength * 0.3, 0); ctx.lineTo(missileLength / 2, missileWidth / 2); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = `rgba(255, 80, 0, ${0.7 + Math.random() * 0.3})`;
                    const flameLength = missileLength * 0.6; const flameWidth = missileWidth * 1.2;
                    ctx.beginPath(); ctx.moveTo(-missileLength / 2, -flameWidth / 2); ctx.lineTo(-missileLength / 2 - flameLength, 0); ctx.lineTo(-missileLength / 2, flameWidth / 2); ctx.closePath(); ctx.fill();
                    ctx.restore();
                }
                else if (this.type === 'heart') { drawHeart(ctx, this.x, this.y, this.angle, this.size, this.color); }
                else if (this.type === 'soccerball') { drawSoccerBall(ctx, this.x, this.y, this.angle, this.size, this.color); }
                else if (this.type === 'petal') { drawPetal(ctx, this.x, this.y, this.angle, this.size, this.color); }
                else if (this.type === 'shuriken') { drawShuriken(ctx, this.x, this.y, this.angle, this.size, this.color); }
                else {
                    const ownerSkin = (this.owner && SKINS[this.owner.skinId]) ? SKINS[this.owner.skinId] : SKINS['default']; let shouldGlow = false; let glowCol = this.color; if (ownerSkin.price >= 1000 || ['phantom', 'sharpshooter', 'lapis'].includes(this.owner.skinId)) { shouldGlow = true; if (this.owner.skinId === 'phantom') glowCol = 'rgba(200,100,255,0.9)'; else if (this.owner.skinId === 'sharpshooter') glowCol = 'rgba(0,220,220,0.9)'; else if (this.color) glowCol = this.color.startsWith('rgba') ? this.color : (this.color.length === 7 ? this.color + 'b3' : this.color); } if (shouldGlow) { ctx.shadowColor = glowCol; ctx.shadowBlur = 8 + Math.sin(Date.now() / 100) * 3; } ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2); ctx.fill();
                }
                ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                ctx.restore();
            }
            update() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                this.x += this.speed * Math.cos(this.angle); this.y += this.speed * Math.sin(this.angle);
            }
            dealDamage(tank) {
                tank.takeDamage(this.damage, this.owner.team);
                if (this.owner) {
                    if (this.owner.skinId === 'soccer_collab' && this.owner.isAbilityActive) {
                        const healAmount = this.damage * this.owner.ability.lifestealPercentage;
                        this.owner.health = Math.min(this.owner.maxHealth, this.owner.health + healAmount);
                        if (!this.owner.isPreview) this.owner.updateHealthBar();
                    }
                }
            }
        }
        class Obstacle { constructor(x, y, width, height, color = '#7a5230') { this.x = x; this.y = y; this.width = width; this.height = height; this.color = color; this.darkerColor = getShadedColor(color, -20); } draw() { ctx.fillStyle = this.darkerColor; ctx.fillRect(this.x + 3, this.y + 3, this.width, this.height); ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; ctx.strokeRect(this.x, this.y, this.width, this.height); } }
        class PowerUp { constructor(x, y, type) { this.x = x; this.y = y; this.radius = POWERUP_SIZE / 2; this.type = type; this.active = true; this.spawnTime = Date.now(); this.lifeTime = 18000; } draw() { if (!this.active) return; ctx.save(); ctx.translate(this.x, this.y); const pulseFactor = 0.8 + Math.abs(Math.sin(Date.now() / 300)) * 0.4; const currentRadius = this.radius * pulseFactor; ctx.beginPath(); ctx.arc(0, 0, currentRadius, 0, Math.PI * 2); let fillColor, strokeColor, letter; if (this.type === 'shield') { fillColor = 'rgba(0, 191, 255, 0.7)'; strokeColor = 'rgba(0, 121, 205, 1)'; letter = 'S'; } else if (this.type === 'speed') { fillColor = 'rgba(255, 215, 0, 0.7)'; strokeColor = 'rgba(205, 165, 0, 1)'; letter = 'F'; } else if (this.type === 'health') { fillColor = 'rgba(50, 205, 50, 0.7)'; strokeColor = 'rgba(0, 155, 0, 1)'; letter = 'H'; } ctx.fillStyle = fillColor; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = 2.5; ctx.stroke(); ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.font = `bold ${this.radius*1.1}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(letter, 0, 1); ctx.restore(); } update() { if (Date.now() - this.spawnTime > this.lifeTime && this.active) { this.active = false; } } }
        class AbilityEffect {
            constructor(x, y, ability, team) {
                this.x = x; this.y = y;
                this.ability = ability;
                this.radius = ability.radius;
                this.duration = ability.duration;
                this.startTime = Date.now();
                this.team = team;
                this.active = true;
            }
            update(deltaTime_ms) {
                if (Date.now() - this.startTime > this.duration) {
                    this.active = false;
                    return;
                }
                allTanks.forEach(tank => {
                    if (tank.health > 0) {
                        const dist = Math.hypot(this.x - tank.x, this.y - tank.y);
                        if (dist < this.radius) {
                            if(this.ability.type === 'AEGIS_FIELD' && tank.team === this.team && tank.health < tank.maxHealth) {
                                tank.health += this.ability.teamHealRate * (deltaTime_ms / 1000);
                                tank.health = Math.min(tank.maxHealth, tank.health);
                                if (!tank.isPreview) tank.updateHealthBar();
                                particles.push({ x: tank.x + (Math.random() - 0.5) * tank.width, y: tank.y + (Math.random() - 0.5) * tank.height, size: Math.random() * 4 + 2, life: 25, color: 'rgba(124, 252, 0, 0.7)' });
                            }
                            if(this.ability.type === 'VORTEX_ULTIMATE' && tank.team !== this.team) {
                                tank.takeDamage(this.ability.damagePerSecond * (deltaTime_ms / 1000), this.team);
                                const angleToCenter = Math.atan2(this.y - tank.y, this.x - tank.x);
                                tank.x += Math.cos(angleToCenter) * this.ability.pullStrength * (1 - dist / this.radius);
                                tank.y += Math.sin(angleToCenter) * this.ability.pullStrength * (1 - dist / this.radius);
                            }
                        }
                    }
                });
            }
            draw() {
                if (!this.active) return;
                const elapsed = Date.now() - this.startTime;
                const remaining = this.duration - elapsed;
                let alpha = Math.min(0.5, (remaining / this.duration) * 0.7);
                const pulse = 1 + Math.sin(Date.now() / 250) * 0.05;
                ctx.save();
                
                if(this.ability.type === 'VORTEX_ULTIMATE') {
                    alpha = Math.min(0.8, (elapsed / 500));
                    ctx.globalAlpha = alpha;
                    ctx.translate(this.x, this.y);
                    ctx.rotate(-elapsed / 500);
                    const gradient = ctx.createRadialGradient(0, 0, this.radius * 0.1, 0, 0, this.radius * pulse);
                    gradient.addColorStop(0, 'rgba(10, 5, 20, 0.9)');
                    gradient.addColorStop(0.7, 'rgba(72, 61, 139, 0.5)');
                    gradient.addColorStop(1, 'rgba(0, 191, 255, 0.2)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.stroke();
                } else { // AEGIS_FIELD
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = 'rgba(50, 205, 50, 0.2)';
                    ctx.strokeStyle = `rgba(124, 252, 0, ${alpha * 1.5})`;
                    ctx.lineWidth = 4 * pulse;
                    ctx.shadowColor = 'rgba(124, 252, 0, 0.9)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }
        }
        class Flag {
            constructor(x, y, team) {
                this.baseX = x; this.baseY = y; this.x = x; this.y = y; this.team = team;
                this.color = team === 1 ? '#87CEFA' : '#F08080'; this.carrier = null;
                this.isAtBase = true; this.isDropped = false; this.size = 40;
                this.uiIcon = document.createElement('div'); this.uiIcon.className = 'flag-icon';
                this.uiIcon.textContent = '🚩'; this.uiIcon.style.color = this.color;
                uiLayer.appendChild(this.uiIcon);
            }
            pickup(tank) { this.carrier = tank; this.isAtBase = false; this.isDropped = false; tank.hasFlag = this.team; }
            drop(x, y) { this.carrier = null; this.x = x; this.y = y; this.isDropped = true; }
            returnToBase() { this.carrier = null; this.x = this.baseX; this.y = this.baseY; this.isAtBase = true; this.isDropped = false; }
            update() {
                if (this.carrier) { this.x = this.carrier.x; this.y = this.carrier.y; }
                if(this.carrier) { this.uiIcon.style.display = 'none'; } else { this.uiIcon.style.display = 'block'; this.uiIcon.style.left = `${this.x - this.size/2}px`; this.uiIcon.style.top = `${this.y - this.size}px`; }
            }
            draw() {
                if(this.carrier) return;
                ctx.save();
                ctx.font = `${this.size}px sans-serif`; ctx.fillStyle = this.color;
                ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                ctx.shadowColor = 'black'; ctx.shadowBlur = 5;
                ctx.fillText('🚩', this.x, this.y);
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.team === 1 ? '0,100,200' : '200,50,50'}, 0.2)`;
                ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.fill(); ctx.stroke();
                ctx.restore();
            }
        }

        function switchScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
                gameArea.style.display = 'none';
            } else {
                document.getElementById('menuScreen').classList.add('active');
                 gameArea.style.display = 'none';
            }
            const activeScreenContent = document.querySelector('.screen.active .screen-content-wrapper, .screen.active .menu-content-grid');
            if (activeScreenContent) {
                activeScreenContent.scrollTop = 0;
            }
            requestAnimationFrame(rescaleGame);
        }

        function initGame() {
            if (gameMode === 'CTF') { tempSelectedMapId = 'division'; }
            currentMapId = tempSelectedMapId || currentProfileData.selectedMapId || 'classic';
            savePlayerData();
            const selectedMapConfig = MAPS_CONFIG[currentMapId];
            G_MAP_WIDTH = selectedMapConfig.width; G_MAP_HEIGHT = selectedMapConfig.height;

            gameContainer.style.width = G_MAP_WIDTH + 'px'; gameContainer.style.height = G_MAP_HEIGHT + 'px';
            canvas.width = G_MAP_WIDTH; canvas.height = G_MAP_HEIGHT; ctx = canvas.getContext('2d');

            camera.x = 0; camera.y = 0; gameContainer.style.transform = `translate(0px, 0px)`;
            gameState = 'PLAYING';

            bullets.length = 0; hooks.length = 0; powerUps.length = 0; particles.length = 0; activeEffects.length = 0; temporaryObstacles.length = 0; flags.length = 0;
            allTanks = []; player1 = null; player2 = null;
            lastPowerUpSpawnTime = Date.now();
            while (uiLayer.firstChild) uiLayer.removeChild(uiLayer.firstChild);

            if (gameMode.startsWith('TDM') || gameMode === 'CTF') {
                ctfScores = { 1: 0, 2: 0 }; team1Score = 0; team2Score = 0;
                ctfScoreUI.style.display = 'block';
                ctfTeam1ScoreDisplay.textContent = '0'; ctfTeam2ScoreDisplay.textContent = '0';
                const team1Spawns = [...selectedMapConfig.playerSpawns.filter(s => s.team === 1)];
                const team2Spawns = [...selectedMapConfig.playerSpawns.filter(s => s.team === 2)];
                const p1Spawn = team1Spawns.shift();
                player1 = new Tank('player1', p1Spawn.x, p1Spawn.y, p1Spawn.angle, 1, false, currentProfileData.selectedSkinId);
                allTanks.push(player1);
                if (gameMode === 'TDM_2P') {
                    const p2Spawn = team2Spawns.shift();
                    const p2SkinId = (currentProfileData.ownedSkins.includes('soccer_collab') && currentProfileData.selectedSkinId !== 'soccer_collab') ? 'soccer_collab' : 'default';
                    player2 = new Tank('player2', p2Spawn.x, p2Spawn.y, p2Spawn.angle, 2, false, p2SkinId);
                    allTanks.push(player2);
                }
                const team1AICount = gameMode === 'CTF' ? 4 : 3;
                const team2AICount = (gameMode === 'TDM_2P') ? 3 : (gameMode === 'CTF' ? 5 : 4);
                
                for(let i=0; i < team1AICount; i++) {
                    const spawn = team1Spawns.shift() || team1Spawns[0];
                    // [MODIFICATION] AI always uses default skin to reduce lag
                    allTanks.push(new Tank(`ai1_${i}`, spawn.x, spawn.y, spawn.angle, 1, true, 'default', currentAiDifficulty));
                }
                for(let i=0; i < team2AICount; i++) {
                     const spawn = team2Spawns.shift() || team2Spawns[0];
                    allTanks.push(new Tank(`ai2_${i}`, spawn.x, spawn.y, spawn.angle, 2, true, 'default', currentAiDifficulty));
                }

            } else { // 1v1 modes
                ctfScoreUI.style.display = 'none';
                const p1Spawn = selectedMapConfig.playerSpawns.find(s=>s.team === 1);
                player1 = new Tank('player1', p1Spawn.x, p1Spawn.y, p1Spawn.angle, 1, false, currentProfileData.selectedSkinId);
                allTanks.push(player1);
                const p2Spawn = selectedMapConfig.playerSpawns.find(s=>s.team === 2);
                if (gameMode === 'vsCPU') {
                    player2 = new Tank('player2_ai', p2Spawn.x, p2Spawn.y, p2Spawn.angle, 2, true, 'default', currentAiDifficulty);
                } else if (gameMode === 'twoPlayer') {
                     const p2SkinId = (currentProfileData.ownedSkins.includes('soccer_collab') && currentProfileData.selectedSkinId !== 'soccer_collab') ? 'soccer_collab' : 'default';
                    player2 = new Tank('player2', p2Spawn.x, p2Spawn.y, p2Spawn.angle, 2, false, p2SkinId);
                }
                if(player2) allTanks.push(player2);
            }
            if (gameMode === 'CTF' && selectedMapConfig.flagSpawns) {
                selectedMapConfig.flagSpawns.forEach(spawn => { flags.push(new Flag(spawn.x, spawn.y, spawn.team)); });
            }
            initObstacles();
            spawnInitialPowerUps(Math.floor( (G_MAP_WIDTH * G_MAP_HEIGHT) / (1200*800) * 3) + 1 );
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            gameArea.style.display = 'block';
            gameRunning = true;
            setupMobileControls();
            rescaleGame();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = performance.now();
            gameLoop();
        }


        function initObstacles() { obstacles.length = 0; const mapObsConfig = MAPS_CONFIG[currentMapId].obstacles; mapObsConfig.forEach(obsData => { const x = typeof obsData.x === 'function' ? obsData.x() : obsData.x; const y = typeof obsData.y === 'function' ? obsData.y() : obsData.y; const w = typeof obsData.w === 'function' ? obsData.w() : obsData.w; const h = typeof obsData.h === 'function' ? obsData.h() : obsData.h; obstacles.push(new Obstacle(x, y, w, h, obsData.color || '#7a5230')); }); }
        function spawnPowerUp() { if (powerUps.filter(p => p.active).length >= Math.floor( (G_MAP_WIDTH*G_MAP_HEIGHT) / (1200*800) * 4) + 2 ) return; let validPosition = false; let x, y, attempts = 0; const types = ['shield', 'speed', 'health', 'health', 'speed']; const type = types[Math.floor(Math.random() * types.length)]; while (!validPosition && attempts < 50) { x = Math.random() * (G_MAP_WIDTH - POWERUP_SIZE * 3) + POWERUP_SIZE * 1.5; y = Math.random() * (G_MAP_HEIGHT - POWERUP_SIZE * 3) + POWERUP_SIZE * 1.5; validPosition = true; const powerUpRect = { x: x - POWERUP_SIZE, y: y - POWERUP_SIZE, width: POWERUP_SIZE*2, height: POWERUP_SIZE*2 }; for (const obs of obstacles) if (rectIntersect(powerUpRect, obs)) { validPosition = false; break; } for (const pup of powerUps) if (pup.active && Math.hypot(x-pup.x, y-pup.y) < POWERUP_SIZE * 4) { validPosition = false; break; } allTanks.forEach(tank => { if (Math.hypot(x - tank.x, y - tank.y) < tank.width * 3) validPosition = false; }); attempts++; } if (validPosition) powerUps.push(new PowerUp(x, y, type)); }
        function spawnInitialPowerUps(count) { for(let i = 0; i < count; i++) spawnPowerUp(); }

        let lastTime = 0;
        function update(currentTime) {
            if (!gameRunning) return;
            const deltaTime_ms = (currentTime - lastTime) || (1000/60);
            lastTime = currentTime;
            const normalizedDeltaTime = deltaTime_ms / (1000/60);
            
            if (gameState === 'PLAYING') {
                if (player1 && player1.health > 0 && !player1.isStunned && !player1.isEnergyBall && !player1.isBeingPulled) {
                    player1.hasMovedThisFrame = false;
                    if (isTouch) {
                        if (p1JoystickMoveState.active && (p1JoystickMoveState.joyX !== 0 || p1JoystickMoveState.joyY !== 0)) {
                            player1.angle = Math.atan2(p1JoystickMoveState.joyY, p1JoystickMoveState.joyX);
                            player1.move(1);
                        }
                        if (p1JoystickAimState.active && (p1JoystickAimState.joyX !== 0 || p1JoystickAimState.joyY !== 0)) {
                            player1.turretAngle = Math.atan2(p1JoystickAimState.joyY, p1JoystickAimState.joyX);
                            if (Math.hypot(p1JoystickAimState.joyX, p1JoystickAimState.joyY) > AIM_JOYSTICK_SHOOT_THRESHOLD) {
                                player1.shoot();
                            }
                        }
                    } else {
                        if (keys['w'] || keys['W']) player1.move(1);
                        if (keys['s'] || keys['S']) player1.move(-1);
                        if (keys['a'] || keys['A']) player1.rotateBody(-1);
                        if (keys['d'] || keys['D']) player1.rotateBody(1);
                        
                        if (keys['arrowleft']) player1.rotateTurret(-1);
                        if (keys['arrowright']) player1.rotateTurret(1);
                        if (keys['arrowup']) player1.setTurretAngle(player1.angle);
                        if (keys['arrowdown']) player1.setTurretAngle(player1.angle + Math.PI);
                        
                        if (keys[' ']) player1.shoot();
                        if (keys['shift'] || keys['shiftleft']) {
                            player1.activateAbility();
                            keys['shift'] = false; keys['shiftleft'] = false;
                        }
                    }
                }
                if (player2 && player2.health > 0 && !player2.isStunned && !player2.isEnergyBall && !player2.isBeingPulled) {
                    player2.hasMovedThisFrame = false;
                    if (gameMode === 'twoPlayer' || gameMode === 'TDM_2P') {
                         if (isTouch) {
                            if (p2JoystickMoveState.active && (p2JoystickMoveState.joyX !== 0 || p2JoystickMoveState.joyY !== 0)) {
                                player2.angle = Math.atan2(p2JoystickMoveState.joyY, p2JoystickMoveState.joyX);
                                player2.move(1);
                            }
                            if (p2JoystickAimState.active && (p2JoystickAimState.joyX !== 0 || p2JoystickAimState.joyY !== 0)) {
                                player2.turretAngle = Math.atan2(p2JoystickAimState.joyY, p2JoystickAimState.joyX);
                                if (Math.hypot(p2JoystickAimState.joyX, p2JoystickAimState.joyY) > AIM_JOYSTICK_SHOOT_THRESHOLD) {
                                    player2.shoot();
                                }
                            }
                        } else {
                            if (keys['i']) player2.move(1);
                            if (keys['k']) player2.move(-1);
                            if (keys['j']) player2.rotateBody(-1);
                            if (keys['l']) player2.rotateBody(1);
                            if (keys['u']) player2.rotateTurret(-1);
                            if (keys['o']) player2.rotateTurret(1);
                            if (keys['h']) player2.shoot();
                            if (keys['shiftright'] || keys['controlright']) {
                               player2.activateAbility();
                               keys['shiftright'] = false; keys['controlright'] = false;
                            }
                        }
                    }
                }
            }


            allTanks.forEach(tank => {
                tank.update(normalizedDeltaTime, deltaTime_ms);
                if (tank.isAI) tank.updateAI(deltaTime_ms);
            });
            hooks.forEach(h => h.update()); hooks.filter(h => h.active);

            for (let i = bullets.length - 1; i >= 0; i--) { const bullet = bullets[i]; bullet.update(); if (bullet.x < -BULLET_SIZE * 3 || bullet.x > G_MAP_WIDTH + BULLET_SIZE * 3 || bullet.y < -BULLET_SIZE * 3 || bullet.y > G_MAP_HEIGHT + BULLET_SIZE * 3) { bullets.splice(i, 1); continue; } let hit = false; for (const obs of obstacles) if (pointInRect({x: bullet.x, y: bullet.y}, obs)) { bullets.splice(i, 1); hit = true; break; } if (hit) continue; 
                for (let j = temporaryObstacles.length - 1; j >= 0; j--) {
                    const tempObs = temporaryObstacles[j];
                    if (tempObs.active && polygonPointIntersect(tempObs, {x: bullet.x, y: bullet.y})) {
                        tempObs.takeDamage(1);
                        bullets.splice(i, 1);
                        hit = true;
                        break;
                    }
                }
                if (hit) continue;
                for (const tank of allTanks) { if (tank.health > 0 && bullet.team !== tank.team) { 
                if (tank.skinId === 'rcb_champion' && tank.isAbilityActive && tank.reflectShieldPoints && linePolygonIntersect(bullet.x, bullet.y, bullet.x - bullet.speed*Math.cos(bullet.angle), bullet.y - bullet.speed*Math.sin(bullet.angle), tank.reflectShieldPoints)) {
                    bullet.team = tank.team; bullet.owner = tank;
                    bullet.angle = 2 * tank.turretAngle - bullet.angle + Math.PI;
                    hit = true; break;
                }
                const dist = Math.hypot(bullet.x - tank.x, bullet.y - tank.y); if (dist < tank.width / 2 + bullet.size / 2) { bullet.dealDamage(tank); bullets.splice(i, 1); hit = true; break; } } } if (hit) continue; }
            for (let i = powerUps.length - 1; i >= 0; i--) { const pu = powerUps[i]; pu.update(); if (!pu.active) { powerUps.splice(i, 1); continue; } for (const tank of allTanks) { if (tank.health > 0) { const dist = Math.hypot(tank.x - pu.x, tank.y - pu.y); if (dist < tank.width / 2 + pu.radius) { tank.applyPowerUp(pu.type); pu.active = false; break; } } } }
            for (let i = activeEffects.length - 1; i >= 0; i--) { const effect = activeEffects[i]; effect.update(deltaTime_ms); if (!effect.active) { activeEffects.splice(i, 1); } }
            for (let i = temporaryObstacles.length - 1; i >= 0; i--) { const tempObs = temporaryObstacles[i]; tempObs.update(); if (!tempObs.active) { temporaryObstacles.splice(i, 1); } }

            if (gameMode === 'CTF') {
                flags.forEach(flag => {
                    flag.update();
                    if (flag.isAtBase || flag.isDropped) {
                        allTanks.forEach(tank => {
                            if (tank.health > 0 && !tank.hasFlag) {
                                const dist = Math.hypot(tank.x - flag.x, tank.y - flag.y);
                                if (dist < tank.width / 2 + flag.size / 2) {
                                    if (tank.team !== flag.team) {
                                        flag.pickup(tank);
                                    } else if (flag.isDropped) {
                                        flag.returnToBase();
                                    }
                                }
                            }
                        });
                    }
                    if (flag.carrier && flag.carrier.team !== flag.team) {
                        const friendlyFlag = flags.find(f => f.team === flag.carrier.team);
                        if (friendlyFlag && friendlyFlag.isAtBase) {
                            const distToBase = Math.hypot(flag.carrier.x - friendlyFlag.baseX, flag.carrier.y - friendlyFlag.baseY);
                            if (distToBase < flag.carrier.width) {
                                ctfScores[flag.carrier.team]++;
                                ctfTeam1ScoreDisplay.textContent = ctfScores[1];
                                ctfTeam2ScoreDisplay.textContent = ctfScores[2];
                                if (ctfScores[flag.carrier.team] >= CTF_SCORE_LIMIT) {
                                    endGame(`Team ${flag.carrier.team} Wins!`);
                                } else {
                                    flags.forEach(f => f.returnToBase());
                                    allTanks.forEach(t => t.hasFlag = null);
                                }
                            }
                        }
                    }
                });
            }

            if (Date.now() - lastPowerUpSpawnTime > POWERUP_SPAWN_INTERVAL) { spawnPowerUp(); lastPowerUpSpawnTime = Date.now(); }
            for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.life--; p.x += p.vx || 0; p.y += p.vy || 0; if (p.life <= 0) particles.splice(i, 1); }
        }
        function draw() {
            ctx.fillStyle = MAPS_CONFIG[currentMapId].bgColor || '#bfa870'; ctx.fillRect(0, 0, G_MAP_WIDTH, G_MAP_HEIGHT);
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 20; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); 
            ctx.globalAlpha = 1;
            obstacles.forEach(obs => obs.draw());
            temporaryObstacles.forEach(obs => obs.draw());
            activeEffects.forEach(effect => effect.draw());
            flags.forEach(flag => flag.draw());
            powerUps.forEach(pu => pu.draw());
            allTanks.sort((a,b) => a.y - b.y).forEach(tank => { if (tank.health > 0) tank.draw(); });
            bullets.forEach(bullet => bullet.draw());
            hooks.forEach(h => h.draw());
            
            // Draw targeting indicators
            if (gameState !== 'PLAYING' && player1) {
                ctx.save();
                const ability = player1.ability;
                if (gameState === 'AWAITING_HOOK_TARGET') {
                    const angle = Math.atan2(mousePos.y - player1.y, mousePos.x - player1.x);
                    const endX = player1.x + ability.range * Math.cos(angle);
                    const endY = player1.y + ability.range * Math.sin(angle);
                    ctx.beginPath(); ctx.moveTo(player1.x, player1.y); ctx.lineTo(endX, endY);
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; ctx.lineWidth = 2; ctx.setLineDash([10, 5]); ctx.stroke();
                } else if (gameState === 'AWAITING_VORTEX_PLACEMENT') {
                    ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, ability.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(148, 0, 211, 0.9)'; ctx.fillStyle = 'rgba(148, 0, 211, 0.2)';
                    ctx.lineWidth = 3; ctx.stroke(); ctx.fill();
                } else if (gameState === 'AWAITING_GLOO_WALL_PLACEMENT') {
                    // Preview the wall
                    const angle = Math.atan2(mousePos.y - player1.y, mousePos.x - player1.x) + Math.PI/2;
                    const wallWidth = TANK_SIZE * 3.5; const wallThickness = TANK_SIZE * 0.4;
                    ctx.translate(mousePos.x, mousePos.y); ctx.rotate(angle);
                    ctx.fillStyle = `rgba(150, 50, 255, 0.4)`; ctx.strokeStyle = `rgba(220, 180, 255, 0.8)`; ctx.lineWidth = 2;
                    ctx.fillRect(-wallWidth / 2, -wallThickness / 2, wallWidth, wallThickness);
                    ctx.strokeRect(-wallWidth / 2, -wallThickness / 2, wallWidth, wallThickness);
                }
                ctx.restore();
            }
        }
        function gameLoop(currentTime) {
            if (!gameRunning) return; animationFrameId = requestAnimationFrame(gameLoop);
            update(currentTime); draw();
        }
        function endGame(message) {
            gameRunning = false; gameState = 'MENU'; messageText.textContent = message;
            switchScreen('messageScreen');
            hideAllMobileControls();
        }
        function rectIntersect(r1, r2) { return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y); }
        function pointInRect(point, rect) { return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height; }
        function polygonPointIntersect(poly, point) {
            let i, j, c = false; const points = [poly.p1, poly.p2, poly.p3, poly.p4];
            for (i = 0, j = points.length-1; i < points.length; j = i++) {
                if (((points[i].y > point.y) != (points[j].y > point.y)) && (point.x < (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)) c = !c;
            } return c;
        }
        function lineLineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den == 0) return false;
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
            return (t > 0 && t < 1 && u > 0 && u < 1);
        }
        function linePolygonIntersect(x1, y1, x2, y2, points) {
            for (let i = 0; i < points.length; i++) {
                const next = (i + 1) % points.length;
                if (lineLineIntersect(x1, y1, x2, y2, points[i].x, points[i].y, points[next].x, points[next].y)) return true;
            } return false;
        }
        function polygonRectIntersect(poly, rect) {
            const polyPoints = [poly.p1, poly.p2, poly.p3, poly.p4];
            const rectPoints = [{x:rect.x, y:rect.y}, {x:rect.x+rect.width, y:rect.y}, {x:rect.x+rect.width, y:rect.y+rect.height}, {x:rect.x, y:rect.y+rect.height}];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (lineLineIntersect(polyPoints[i].x, polyPoints[i].y, polyPoints[(i+1)%4].x, polyPoints[(i+1)%4].y, rectPoints[j].x, rectPoints[j].y, rectPoints[(j+1)%4].x, rectPoints[(j+1)%4].y)) return true;
                }
            }
            if (polygonPointIntersect(poly, rectPoints[0])) return true;
            if (pointInRect(polyPoints[0], rect)) return true;
            return false;
        }

        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; keys[e.code.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; keys[e.code.toLowerCase()] = false; });

        let isTouch = false;
        function isTouchDevice() { return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)); }
        function setupMobileControls() {
            isTouch = isTouchDevice();
            hideAllMobileControls();
            if (isTouch && gameRunning) {
                const isTwoPlayerMode = (gameMode === 'twoPlayer' || gameMode === 'TDM_2P');
                if (isTwoPlayerMode) {
                    joystickContainerP1Move.style.display = 'block'; joystickContainerP1Aim.style.display = 'block';
                    if (player1 && player1.ability) skillButtonContainerP1.style.display = 'flex'; else skillButtonContainerP1.style.display = 'none';
                    joystickContainerP2Move.style.top = '20px'; joystickContainerP2Move.style.bottom = 'auto'; joystickContainerP2Move.style.left = '20px'; joystickContainerP2Move.style.right = 'auto';
                    joystickContainerP2Move.style.display = 'block';
                    joystickContainerP2Aim.style.top = '20px'; joystickContainerP2Aim.style.bottom = 'auto'; joystickContainerP2Aim.style.right = '20px'; joystickContainerP2Aim.style.left = 'auto';
                    joystickContainerP2Aim.style.display = 'block';
                    if (player2 && player2.ability) { skillButtonContainerP2.style.top = '140px'; skillButtonContainerP2.style.bottom = 'auto'; skillButtonContainerP2.style.right = '35px'; skillButtonContainerP2.style.left = 'auto'; skillButtonContainerP2.style.display = 'flex'; } else { skillButtonContainerP2.style.display = 'none'; }
                } else {
                    joystickContainerP1Move.style.display = 'block'; joystickContainerP1Aim.style.display = 'block';
                    if (player1 && player1.ability) skillButtonContainerP1.style.display = 'flex'; else skillButtonContainerP1.style.display = 'none';
                    joystickContainerP2Move.style.display = 'none'; joystickContainerP2Aim.style.display = 'none'; skillButtonContainerP2.style.display = 'none';
                }
                if (joystickContainerP1Move.style.display === 'block' && joystickContainerP1Move.offsetWidth > 0) { p1JoystickMoveState.radius = joystickContainerP1Move.offsetWidth / 2; p1JoystickMoveState.handleRadius = joystickHandleP1Move.offsetWidth / 2; }
                if (joystickContainerP1Aim.style.display === 'block' && joystickContainerP1Aim.offsetWidth > 0) { p1JoystickAimState.radius = joystickContainerP1Aim.offsetWidth / 2; p1JoystickAimState.handleRadius = joystickHandleP1Aim.offsetWidth / 2; }
                if (joystickContainerP2Move.style.display === 'block' && joystickContainerP2Move.offsetWidth > 0) { p2JoystickMoveState.radius = joystickContainerP2Move.offsetWidth / 2; p2JoystickMoveState.handleRadius = joystickHandleP2Move.offsetWidth / 2; }
                if (joystickContainerP2Aim.style.display === 'block' && joystickContainerP2Aim.offsetWidth > 0) { p2JoystickAimState.radius = joystickContainerP2Aim.offsetWidth / 2; p2JoystickAimState.handleRadius = joystickHandleP2Aim.offsetWidth / 2; }
            }
        }
        function hideAllMobileControls() {
            joystickContainerP1Move.style.display = 'none'; joystickContainerP1Aim.style.display = 'none'; skillButtonContainerP1.style.display = 'none';
                        skillButtonContainerP2.style.display = 'none';
        }

        const p1JoystickMoveState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };
        const p1JoystickAimState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };
        const p2JoystickMoveState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };
        const p2JoystickAimState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };

        function newJoystickInit(joystickCont, joystickHandle, stateObj) { if (!joystickCont || !joystickHandle) return; stateObj.radius = parseFloat(getComputedStyle(joystickCont).width) / 2 || 60; stateObj.handleRadius = parseFloat(getComputedStyle(joystickHandle).width) / 2 || 30; joystickHandle.style.left = '50%'; joystickHandle.style.top = '50%'; joystickHandle.style.transform = 'translate(-50%, -50%)'; joystickCont.addEventListener('touchstart', (e) => { e.preventDefault(); if (stateObj.active) return; if (joystickCont.offsetWidth > 0) { stateObj.radius = joystickCont.offsetWidth / 2; stateObj.handleRadius = joystickHandle.offsetWidth / 2; } const touch = e.changedTouches[0]; stateObj.active = true; stateObj.identifier = touch.identifier; newUpdateJoystickPosition(touch, joystickCont, joystickHandle, stateObj); }, { passive: false }); }
        function newUpdateJoystickPosition(touch, joystickCont, joystickHandle, stateObj) { if (!joystickCont || !joystickHandle) return; const rect = joystickCont.getBoundingClientRect(); let currentX = touch.clientX - rect.left; let currentY = touch.clientY - rect.top; let deltaX = currentX - stateObj.radius; let deltaY = currentY - stateObj.radius; const distance = Math.hypot(deltaX, deltaY); const maxDist = stateObj.radius - stateObj.handleRadius; if (maxDist <= 0) return; if (distance > maxDist) { deltaX = (deltaX / distance) * maxDist; deltaY = (deltaY / distance) * maxDist; } joystickHandle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`; stateObj.joyX = maxDist ? deltaX / maxDist : 0; stateObj.joyY = maxDist ? deltaY / maxDist : 0; }
        function newResetJoystick(joystickHandle, stateObj) { if (!joystickHandle) return; stateObj.active = false; stateObj.identifier = null; joystickHandle.style.transform = 'translate(-50%, -50%)'; stateObj.joyX = 0; stateObj.joyY = 0; }

        window.addEventListener('touchmove', (e) => {
            if (!gameRunning || !isTouch) return; e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i];
                if (p1JoystickMoveState.active && touch.identifier === p1JoystickMoveState.identifier) newUpdateJoystickPosition(touch, joystickContainerP1Move, joystickHandleP1Move, p1JoystickMoveState);
                if (p1JoystickAimState.active && touch.identifier === p1JoystickAimState.identifier) newUpdateJoystickPosition(touch, joystickContainerP1Aim, joystickHandleP1Aim, p1JoystickAimState);
                if (p2JoystickMoveState.active && touch.identifier === p2JoystickMoveState.identifier) newUpdateJoystickPosition(touch, joystickContainerP2Move, joystickHandleP2Move, p2JoystickMoveState);
                if (p2JoystickAimState.active && touch.identifier === p2JoystickAimState.identifier) newUpdateJoystickPosition(touch, joystickContainerP2Aim, joystickHandleP2Aim, p2JoystickAimState);
            }
        }, { passive: false });
        window.addEventListener('touchend', (e) => {
            if (!gameRunning || !isTouch) return;
            for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i];
                if (p1JoystickMoveState.active && touch.identifier === p1JoystickMoveState.identifier) newResetJoystick(joystickHandleP1Move, p1JoystickMoveState);
                if (p1JoystickAimState.active && touch.identifier === p1JoystickAimState.identifier) newResetJoystick(joystickHandleP1Aim, p1JoystickAimState);
                if (p2JoystickMoveState.active && touch.identifier === p2JoystickMoveState.identifier) newResetJoystick(joystickHandleP2Move, p2JoystickMoveState);
                if (p2JoystickAimState.active && touch.identifier === p2JoystickAimState.identifier) newResetJoystick(joystickHandleP2Aim, p2JoystickAimState);
            }
        }, { passive: false });

        function setupSkillButton(skillButtonElem, playerProvider) {
            if (!skillButtonElem) return;
            skillButtonElem.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const player = playerProvider();
                if (player && player.health > 0) player.activateAbility();
            }, { passive: false });
            skillButtonElem.addEventListener('click', (e) => {
                e.preventDefault();
                const player = playerProvider();
                if (player && player.health > 0 && !isTouch) player.activateAbility();
            });
        }
        
        let previewCanvases = {};
        function initPreviewCanvases() {
            document.querySelectorAll('canvas[data-preview-id]').forEach(canvasEl => {
                const id = canvasEl.dataset.previewId;
                previewCanvases[id] = {
                    el: canvasEl,
                    ctx: canvasEl.getContext('2d'),
                    tank: null,
                    skinId: null,
                    needsRedraw: true
                };
            });
        }

        function setPreviewCanvasSkin(previewId, skinId) {
            if (previewCanvases[previewId]) {
                if (previewCanvases[previewId].skinId !== skinId) {
                    previewCanvases[previewId].skinId = skinId;
                    const canvasEl = previewCanvases[previewId].el;
                    const w = canvasEl.width; const h = canvasEl.height;
                    previewCanvases[previewId].tank = new Tank('preview', w/2, h/2 + 5, -Math.PI/2, 1, false, skinId, 'NORMAL', true);
                    previewCanvases[previewId].tank.turretAngle = -Math.PI/2;
                    previewCanvases[previewId].needsRedraw = true;
                }
            }
        }

        function previewAnimationLoop() {
            Object.values(previewCanvases).forEach(preview => {
                const { el, ctx, tank, skinId, needsRedraw } = preview;
                if (tank) {
                    const alwaysRedraw = ['golden_goliath', 'heart_collab', 'phantom', 'lapis'].includes(skinId);
                    if (needsRedraw || alwaysRedraw) {
                        ctx.clearRect(0, 0, el.width, el.height);
                        ctx.save();
                        ctx.scale(0.8, 0.8);
                        ctx.translate(el.width*0.125, el.height*0.125);
                        tank.draw();
                        ctx.restore();
                        preview.needsRedraw = false;
                    }
                }
            });
            requestAnimationFrame(previewAnimationLoop);
        }

        function updateMenuSkinPreview() {
            setPreviewCanvasSkin('menu_preview', currentProfileData.selectedSkinId);
        }

        function populateShop() {
            shopItemsContainer.innerHTML = '';
            
            const renderSkin = (skinId, skin) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shopItem';
                if (skinId === 'lapis') itemDiv.classList.add('lapis-skin-glow');
                else if (skin.price >= 1000) itemDiv.classList.add('expensive-skin-glow');
                if (skinId === 'heart_collab' || skinId === 'soccer_collab') itemDiv.classList.add('event-skin-glow');

                const previewCanvas = document.createElement('canvas');
                previewCanvas.className = 'skin-preview-canvas';
                previewCanvas.width = 100; previewCanvas.height = 75;
                const previewId = `shop_preview_${skinId}`;
                previewCanvas.dataset.previewId = previewId;

                const nameH3 = document.createElement('h3');
                nameH3.textContent = skin.name;

                if (skin.buffs || skin.nerfs) {
                    const indicator = document.createElement('span');
                    indicator.className = 'buff-nerf-indicator';
                    const tooltip = document.createElement('span');
                    tooltip.className = 'tooltip-text';
                    let tooltipContent = '';
                    if (skin.buffs) { 
                        indicator.textContent = '⬆️';
                        tooltipContent += '<strong>Buffs:</strong><ul>' + skin.buffs.map(b => `<li>${b}</li>`).join('') + '</ul>';
                    }
                    if (skin.nerfs) {
                        indicator.textContent = skin.buffs ? '↕️' : '⬇️';
                        tooltipContent += '<strong>Nerfs:</strong><ul>' + skin.nerfs.map(n => `<li>${n}</li>`).join('') + '</ul>';
                    }
                    tooltip.innerHTML = tooltipContent;
                    indicator.appendChild(tooltip);
                    nameH3.appendChild(indicator);
                }

                const bulletPreview = document.createElement('span');
                bulletPreview.className = 'bullet-color-preview';
                bulletPreview.style.backgroundColor = skin.bulletColor;
                nameH3.appendChild(bulletPreview);

                const descP = document.createElement('p');
                descP.innerHTML = skin.description;
                if (skin.ability) {
                    descP.innerHTML += `<br><strong style="color:#FFD700;">Skill: ${skin.ability.name}</strong>`;
                }

                const priceP = document.createElement('p');
                priceP.className = 'price';
                priceP.textContent = `Price: $${skin.price}`;

                const buyButton = document.createElement('button');
                buyButton.className = 'buySkinButton baseButton';
                if (currentProfileData.ownedSkins.includes(skinId)) {
                    buyButton.textContent = 'Owned';
                    buyButton.disabled = true;
                } else if (currentProfileData.money < skin.price) {
                    buyButton.textContent = 'Too Expensive';
                    buyButton.disabled = true;
                } else {
                    buyButton.textContent = 'Buy';
                    buyButton.onclick = () => buySkin(skinId);
                }
                itemDiv.appendChild(previewCanvas);
                itemDiv.appendChild(nameH3);
                itemDiv.appendChild(descP);
                itemDiv.appendChild(priceP);
                itemDiv.appendChild(buyButton);
                shopItemsContainer.appendChild(itemDiv);
                
                // [FIX] Ensure preview canvas is initialized for shop items
                if (!previewCanvases[previewId]) {
                    previewCanvases[previewId] = { el: previewCanvas, ctx: previewCanvas.getContext('2d'), tank: null, skinId: null, needsRedraw: true };
                }
                setPreviewCanvasSkin(previewId, skinId);
            };

            const sortedSkins = Object.keys(SKINS)
              .filter(id => id !== 'default' && id !== 'rcb_champion')
              .sort((a,b) => SKINS[a].price - SKINS[b].price);

            sortedSkins.forEach(id => renderSkin(id, SKINS[id]));
        }

        function buySkin(skinId) {
            const skin = SKINS[skinId];
            if (skin && !currentProfileData.ownedSkins.includes(skinId) && currentProfileData.money >= skin.price) {
                currentProfileData.money -= skin.price; currentProfileData.ownedSkins.push(skinId);
                savePlayerData();
                populateShop();
                updateUIAfterAuthChange();
            }
        }
        
        function populateSkinSelector() {
            skinSelector.innerHTML = '';
            if (currentProfileData.ownedSkins && Array.isArray(currentProfileData.ownedSkins)) {
                currentProfileData.ownedSkins.forEach(skinId => {
                    const skin = SKINS[skinId];
                    if (skin) {
                        const option = document.createElement('option');
                        option.value = skinId;
                        option.textContent = skin.name;
                        if (skinId === currentProfileData.selectedSkinId) option.selected = true;
                        skinSelector.appendChild(option);
                    }
                });
            }
        }
        skinSelector.addEventListener('change', (e) => { 
            currentProfileData.selectedSkinId = e.target.value; 
            savePlayerData();
            updateMenuSkinPreview();
        });

        function populateMapSelectorScreen() {
            mapSelectionButtonsContainer.innerHTML = '';
            Object.keys(MAPS_CONFIG).forEach(mapId => {
                const mapConf = MAPS_CONFIG[mapId];
                if (mapConf.isCTFMap) return;
                const mapButton = document.createElement('button');
                mapButton.className = 'map-selection-button baseButton';
                mapButton.textContent = mapConf.name;
                mapButton.dataset.mapId = mapId;
                mapButton.addEventListener('click', () => {
                    tempSelectedMapId = mapId;
                    initGame();
                });
                mapSelectionButtonsContainer.appendChild(mapButton);
            });
        }

        function populateProfileScreen() {
            try {
                if (!profileScreen.classList.contains('active')) return;
                usernameInputProfile.value = currentProfileData.username || "Guest";
                usernameInputProfile.readOnly = !currentUser;
                profileMoney.textContent = `$${currentProfileData.money || 0}`;
                profileGamesPlayed.textContent = currentProfileData.gamesPlayed || 0;
                profileWins.textContent = currentProfileData.wins || 0;
                profileLosses.textContent = currentProfileData.losses || 0;
                profileHardAIWins.textContent = currentProfileData.hardAIWins || 0;
                profileFreestyleAIWins.textContent = currentProfileData.freestyleAIWins || 0;
                profileCtfWins.textContent = currentProfileData.ctfWins || 0;
                ownedSkinsList.innerHTML = '';
                (currentProfileData.ownedSkins || ['default']).forEach(skinId => {
                    const skin = SKINS[skinId]; if (skin) { const li = document.createElement('li'); const skinColorDot = document.createElement('span'); skinColorDot.style.display = 'inline-block'; skinColorDot.style.width = '12px'; skinColorDot.style.height = '12px'; skinColorDot.style.borderRadius = '50%'; skinColorDot.style.backgroundColor = skin.color; skinColorDot.style.marginRight = '10px'; skinColorDot.style.border = '1px solid rgba(255,255,255,0.4)'; li.appendChild(skinColorDot); const skinNameSpan = document.createElement('span'); skinNameSpan.textContent = skin.name; li.appendChild(skinNameSpan); ownedSkinsList.appendChild(li); }
                });
            } catch (error) {
                console.error("Error populating profile screen:", error);
                ownedSkinsList.innerHTML = '<li>Error loading profile data.</li>';
            }
        }
        usernameInputProfile.addEventListener('change', (e) => {
            if (currentUser) {
                const newUsername = e.target.value.trim();
                if (newUsername.length >= 3 && newUsername !== currentProfileData.username) {
                    const profiles = loadUserProfiles();
                    if (Object.keys(profiles).some(existingUser => existingUser.toLowerCase() === newUsername.toLowerCase() && existingUser !== currentUser)) {
                        alert("That username is already taken by another registered user. Please choose a different one.");
                        e.target.value = currentProfileData.username;
                        return;
                    }

                    currentProfileData.username = newUsername;
                    if (profiles[currentUser]) {
                        const oldProfileData = profiles[currentUser];
                        delete profiles[currentUser];
                        currentUser = newUsername;
                        profiles[currentUser] = oldProfileData;
                        profiles[currentUser].profileData.username = newUsername;
                        localStorage.setItem(LOGGED_IN_USER_KEY, currentUser);
                        saveUserProfiles(profiles);
                    }
                    savePlayerData();
                    loggedInUserDisplay.textContent = newUsername;
                    updateUIAfterAuthChange();
                } else if (newUsername.length < 3) {
                    alert("Username too short (min 3 characters). Reverting.");
                    e.target.value = currentProfileData.username;
                }
            }
        });

        function rescaleGame() {
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;
            if (gameArea.style.display === 'block') {
                const scaleX = availableWidth / G_MAP_WIDTH;
                const scaleY = availableHeight / G_MAP_HEIGHT;
                G_SCALE = Math.min(scaleX, scaleY, 1);
                gameArea.style.transformOrigin = 'top left';
                gameArea.style.transform = `scale(${G_SCALE})`;
                const scaledWidth = G_MAP_WIDTH * G_SCALE;
                const scaledHeight = G_MAP_HEIGHT * G_SCALE;
                gameArea.style.width = G_MAP_WIDTH + 'px';
                gameArea.style.height = G_MAP_HEIGHT + 'px';
                gameArea.style.position = 'absolute';
                gameArea.style.left = `${Math.max(0, (availableWidth - scaledWidth) / 2)}px`;
                gameArea.style.top = `${Math.max(0, (availableHeight - scaledHeight) / 2)}px`;
                if (gameRunning) {
                    allTanks.forEach(tank => tank.updateHealthBarPosition());
                }
            } else {
                gameArea.style.transform = `scale(1)`;
                gameArea.style.position = 'relative';
                gameArea.style.left = 'auto';
                gameArea.style.top = 'auto';
            }
            if (isTouch && gameRunning) { setupMobileControls(); }
            fullscreenButtonMenu.textContent = document.fullscreenElement ? "↔️ Exit Fullscreen" : "↔️ Enter Fullscreen";
        }
        
        function runLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            const progressBar = document.getElementById('progressBar');
            const loadingStatus = document.getElementById('loadingStatus');
            const tapButton = document.getElementById('tapToContinueButton');
            
            initPreviewCanvases(); // Init early for loading screen
            setPreviewCanvasSkin('loading_preview', 'lapis'); // Show off the new skin!
            
            let progress = 0;
            const updateProgress = () => {
                progress += Math.random() * 5;
                if (progress >= 100) {
                    progress = 100;
                    progressBar.style.width = '100%';
                    loadingStatus.textContent = "Game Ready!";
                    tapButton.style.display = 'block';
                    clearInterval(progressInterval);
                } else {
                    progressBar.style.width = progress + '%';
                    if (progress > 70) loadingStatus.textContent = "Finalizing...";
                    else if (progress > 30) loadingStatus.textContent = "Loading Assets...";
                }
            };
            
            const progressInterval = setInterval(updateProgress, 150);

            tapButton.addEventListener('click', () => {
                backgroundMusic.play().catch(e => console.log("Audio play failed, user must interact again."));
                loadingScreen.classList.add('fade-out');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 800);
                initApp();
            }, { once: true });
        }
        
        function initApp() {
            loadPlayerData();
            switchScreen('menuScreen');
            isTouch = isTouchDevice();
            if (isTouch) {
                newJoystickInit(joystickContainerP1Move, joystickHandleP1Move, p1JoystickMoveState);
                newJoystickInit(joystickContainerP1Aim, joystickHandleP1Aim, p1JoystickAimState);
                newJoystickInit(joystickContainerP2Move, joystickHandleP2Move, p2JoystickMoveState);
                newJoystickInit(joystickContainerP2Aim, joystickHandleP2Aim, p2JoystickAimState);
                setupSkillButton(skillButtonP1, () => player1);
                setupSkillButton(skillButtonP2, () => player2);
            }
            hideAllMobileControls();
            populateMapSelectorScreen();
            previewAnimationLoop();
        }

        window.addEventListener('load', () => {
            runLoadingScreen();
        });

        window.addEventListener('resize', rescaleGame);
        document.addEventListener('fullscreenchange', rescaleGame);

        function toggleFullScreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`); }); } else { if (document.exitFullscreen) document.exitFullscreen(); } }

        fullscreenButtonMenu.addEventListener('click', toggleFullScreen);

        newVsCPUButton.addEventListener('click', () => { gameMode = 'vsCPU'; switchScreen('difficultyScreen'); });
        newTdmButton.addEventListener('click', () => { gameMode = 'TDM_CPU'; switchScreen('difficultyScreen'); });
        newCtfButton.addEventListener('click', () => { gameMode = 'CTF'; switchScreen('difficultyScreen'); });
        newTwoPlayerButton.addEventListener('click', () => { gameMode = 'twoPlayer'; tempSelectedMapId = 'classic'; initGame(); });

        document.querySelectorAll('.difficultyButton').forEach(button => {
            button.addEventListener('click', (e) => {
                currentAiDifficulty = e.target.dataset.difficulty;
                if (gameMode === 'CTF') {
                    tempSelectedMapId = 'division';
                    initGame();
                } else {
                    switchScreen('mapSelectorScreen');
                }
            });
        });

        newShopButton.addEventListener('click', () => { populateShop(); switchScreen('shopScreen'); });
        newProfileButton.addEventListener('click', () => { populateProfileScreen(); switchScreen('profileScreen'); });
        newEventButton.addEventListener('click', () => switchScreen('eventScreen'));
        newInfoButton.addEventListener('click', () => switchScreen('infoScreen'));
        newHowToPlayButton.addEventListener('click', () => switchScreen('howToPlayScreen'));

        backToMenuFromEvent.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromInfo.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromHowToPlay.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromMapSelector.addEventListener('click', () => switchScreen('difficultyScreen'));
        backToMenuFromDifficulty.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromShop.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromProfile.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromLogin.addEventListener('click', () => { loginErrorMessage.style.display = 'none'; switchScreen('menuScreen'); });
        backToMenuFromRegister.addEventListener('click', () => { registerErrorMessage.style.display = 'none'; switchScreen('menuScreen');});

        playAgainButton.addEventListener('click', () => { initGame(); });
        backToMenuButton.addEventListener('click', () => { switchScreen('menuScreen'); gameRunning = false; hideAllMobileControls(); });

        loginRegisterButton.addEventListener('click', () => { loginErrorMessage.style.display = 'none'; switchScreen('loginScreen');});
        logoutButton.addEventListener('click', () => { logoutUser(); switchScreen('loginScreen'); });

        switchToRegisterLink.addEventListener('click', () => { loginErrorMessage.style.display = 'none'; registerErrorMessage.style.display = 'none'; switchScreen('registerScreen');});
        switchToLoginLink.addEventListener('click', () => { loginErrorMessage.style.display = 'none'; registerErrorMessage.style.display = 'none'; switchScreen('loginScreen');});

        loginSubmitButton.addEventListener('click', () => {
            const username = loginUsernameInput.value.trim();
            const password = loginPasswordInput.value;
            loginErrorMessage.style.display = 'none';
            if (!username || !password) {
                loginErrorMessage.textContent = "Username and password required.";
                loginErrorMessage.style.display = 'block';
                return;
            }
            const result = loginUser(username, password);
            if (result.success) {
                if (username.toLowerCase() === 'lapis yamz') {
                    alert("Welcome, Owner! Special bonus applied.");
                }
                switchScreen('menuScreen');
                loginUsernameInput.value = ''; loginPasswordInput.value = '';
            } else {
                loginErrorMessage.textContent = result.message;
                loginErrorMessage.style.display = 'block';
            }
        });

        registerSubmitButton.addEventListener('click', () => {
            const username = registerUsernameInput.value.trim();
            const password = registerPasswordInput.value;
            registerErrorMessage.style.display = 'none';
             if (!username || !password) {
                registerErrorMessage.textContent = "Username and password required.";
                registerErrorMessage.style.display = 'block';
                return;
            }
            const result = registerUser(username, password);
            if (result.success) {
                if (username.toLowerCase() === 'lapis yamz') {
                     alert("Welcome, Owner! Registration successful. Please login to receive your bonus.");
                } else {
                    alert(result.message);
                }
                switchScreen('loginScreen');
                registerUsernameInput.value = ''; registerPasswordInput.value = '';
            } else {
                registerErrorMessage.textContent = result.message;
                registerErrorMessage.style.display = 'block';
            }
        });
        
        function handleTargeting(e) {
            e.preventDefault();
            if (gameState === 'PLAYING' || !player1) return;

            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const targetX = (clientX - rect.left) / G_SCALE - camera.x;
            const targetY = (clientY - rect.top) / G_SCALE - camera.y;

            if (gameState === 'AWAITING_HOOK_TARGET') {
                const angle = Math.atan2(targetY - player1.y, targetX - player1.x);
                hooks.push(new Hook(player1.x, player1.y, angle, player1));
            } else if (gameState === 'AWAITING_GLOO_WALL_PLACEMENT') {
                 const angle = Math.atan2(targetY - player1.y, targetX - player1.x) + Math.PI/2;
                 temporaryObstacles.push(new GlooWall(targetX, targetY, angle, player1));
            } else if (gameState === 'AWAITING_VORTEX_PLACEMENT') {
                activeEffects.push(new AbilityEffect(targetX, targetY, player1.ability, player1.team));
            }
            
            gameState = 'PLAYING';
            targetingOverlay.style.display = 'none';
        }

        targetingOverlay.addEventListener('click', handleTargeting);
        targetingOverlay.addEventListener('touchstart', handleTargeting, {passive: false});

        canvas.addEventListener('mousemove', (e) => {
             if (gameState === 'PLAYING') return;
             const rect = canvas.getBoundingClientRect();
             mousePos.x = (e.clientX - rect.left) / G_SCALE - camera.x;
             mousePos.y = (e.clientY - rect.top) / G_SCALE - camera.y;
        });

    </script>
</body>
</html>
