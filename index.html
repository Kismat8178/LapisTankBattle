
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tank Battle by Lapis Yamz - V2.5.4 (AI/UI/Data Fixes)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #3a3a3a 0%, #2c2c2c 100%);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        #gameArea {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            display: none;
            background-color: #e0e0e0; /* Fallback for canvas */
        }
        #gameContainer {
            position: relative;
        }
        canvas {
            display: block;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }
        .health-bar-container {
            position: absolute;
            width: 50px;
            height: 8px;
            background-color: rgba(85, 85, 85, 0.7);
            border: 1px solid #222;
            border-radius: 2px;
            box-sizing: border-box;
        }
        .health-bar {
            height: 100%;
            background-color: limegreen;
            border-radius: 1px;
            transition: width 0.2s ease-out;
        }
        .shield-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: deepskyblue;
            border-radius: 50%;
            border: 1px solid #fff;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .joystick-container-base {
            position: fixed;
            width: 120px;
            height: 120px;
            background-color: rgba(100, 100, 100, 0.35);
            border-radius: 50%;
            display: none;
            z-index: 100;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            border: 2px solid rgba(255,255,255,0.1);
        }
        .joystick-handle-base {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(180, 180, 180, 0.6);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #joystickContainerP1 { bottom: 20px; left: 20px; }
        #joystickContainerP2 { bottom: 20px; right: 20px; }

        .fire-button-container-base {
            position: fixed;
            display: none;
            z-index: 100;
        }
        .fire-button-base {
            width: 75px;
            height: 75px;
            background-color: rgba(255, 20, 20, 0.5);
            color: white;
            border: 2px solid rgba(200,0,0,0.8);
            border-radius: 50%;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            box-shadow: 0 0 12px rgba(255,0,0,0.4);
            transition: background-color 0.05s ease-out, box-shadow 0.05s ease-out, transform 0.05s ease-out;
        }
        .fire-button-base.glowing {
            background-color: rgba(255, 60, 60, 0.8);
            box-shadow: 0 0 18px rgba(255, 60, 60, 0.7), 0 0 30px rgba(255, 100, 100, 0.5) inset;
            transform: scale(1.08);
        }
        #fireButtonContainerP1 { bottom: 30px; right: 20px; }
        #fireButtonContainerP2 { bottom: 30px; left: 20px; }

        /* --- Menu & Screen Styles --- */
        .screen {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.88);
            z-index: 200;
            padding: 0;
            box-sizing: border-box;
            text-align: center;
        }
        .screen.active {
            display: flex;
            flex-direction: column;
        }

        #menuScreen {
             height: 100%; /* Ensure #menuScreen itself takes full height for flex to work */
        }

        .screen h1 {
            font-size: clamp(2.2em, 7vw, 3.8em); margin-bottom: 15px; margin-top: 0;
            color: gold; text-shadow: 3px 3px 2px #111;
        }
         #menuScreen h1 { margin-top: 10px; margin-bottom: 10px; }

        .screen p {
             margin-bottom: 20px; font-size: clamp(0.9em, 3vw, 1.2em); color: #ddd;
        }
        .baseButton {
            padding: clamp(12px, 3vw, 18px) clamp(25px, 5vw, 35px);
            font-size: clamp(1.1em, 4vw, 1.6em);
            margin: 8px;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            min-width: 220px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        .menuButton {
            background: linear-gradient(145deg, #4CAF50, #3a8a3e);
            box-shadow: 0 5px 0 #2c6f2f, 0 8px 15px rgba(0,0,0,0.3);
        }
        .menuButton:hover { background: linear-gradient(145deg, #5cb85c, #45a049); transform: translateY(-2px); box-shadow: 0 7px 0 #2c6f2f, 0 10px 20px rgba(0,0,0,0.2);}
        .menuButton:active { background: linear-gradient(145deg, #3e8e41, #3a8a3e); transform: translateY(2px); box-shadow: 0 2px 0 #2c6f2f, 0 5px 10px rgba(0,0,0,0.4); }

        .shopButton.menuScreenBtn {
            background: linear-gradient(145deg, #2196F3, #1976D2);
            box-shadow: 0 5px 0 #1565C0, 0 8px 15px rgba(0,0,0,0.3);
        }
        .shopButton.menuScreenBtn:hover { background: linear-gradient(145deg, #42A5F5, #1E88E5); transform: translateY(-2px);box-shadow: 0 7px 0 #1565C0, 0 10px 20px rgba(0,0,0,0.2); }
        .shopButton.menuScreenBtn:active { background: linear-gradient(145deg, #1976D2, #1565C0);transform: translateY(2px); box-shadow: 0 2px 0 #1565C0, 0 5px 10px rgba(0,0,0,0.4);}

        .profileButton.menuScreenBtn {
             background: linear-gradient(145deg, #9c27b0, #7b1fa2);
             box-shadow: 0 5px 0 #6a1b9a, 0 8px 15px rgba(0,0,0,0.3);
        }
        .profileButton.menuScreenBtn:hover { background: linear-gradient(145deg, #ab47bc, #8e24aa); transform: translateY(-2px); box-shadow: 0 7px 0 #6a1b9a, 0 10px 20px rgba(0,0,0,0.2);}
        .profileButton.menuScreenBtn:active { background: linear-gradient(145deg, #7b1fa2, #6a1b9a); transform: translateY(2px); box-shadow: 0 2px 0 #6a1b9a, 0 5px 10px rgba(0,0,0,0.4);}

        .leaderboardButton.menuScreenBtn {
             background: linear-gradient(145deg, #FFC107, #FFA000);
             box-shadow: 0 5px 0 #FF6F00, 0 8px 15px rgba(0,0,0,0.3);
        }
        .leaderboardButton.menuScreenBtn:hover { background: linear-gradient(145deg, #FFCA28, #FFB300); transform: translateY(-2px); box-shadow: 0 7px 0 #FF6F00, 0 10px 20px rgba(0,0,0,0.2);}
        .leaderboardButton.menuScreenBtn:active { background: linear-gradient(145deg, #FFA000, #FF8F00); transform: translateY(2px); box-shadow: 0 2px 0 #FF6F00, 0 5px 10px rgba(0,0,0,0.4);}

         #menuScreenHeaderButtons {
            padding: 15px 15px 0 15px;
            box-sizing: border-box;
            width: 100%;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #menuScreenHeaderButtons > button {
            pointer-events: auto;
            margin: 0;
            min-width: auto;
            padding: 10px 15px;
            font-size: clamp(0.9em, 2.5vw, 1.2em);
        }

        #menuScreenFooterButtons {
            padding: 0 15px 15px 15px;
            box-sizing: border-box;
            width: 100%;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
            flex-shrink: 0; /* Prevent shrinking */
        }
         #menuScreenFooterButtons > button {
            pointer-events: auto;
            margin: 0;
            min-width: auto;
            padding: 10px 15px;
            font-size: clamp(0.9em, 2.5vw, 1.2em);
        }

        .difficultyButton {
            background: linear-gradient(145deg, #ff9800, #f57c00);
            box-shadow: 0 5px 0 #e65100, 0 8px 15px rgba(0,0,0,0.3);
        }
        .difficultyButton:hover { background: linear-gradient(145deg, #ffa726, #fb8c00);transform: translateY(-2px);box-shadow: 0 7px 0 #e65100, 0 10px 20px rgba(0,0,0,0.2); }
        .difficultyButton:active { background: linear-gradient(145deg, #f57c00, #e65100); transform: translateY(2px);box-shadow: 0 2px 0 #e65100, 0 5px 10px rgba(0,0,0,0.4); }

        .backButton {
            background: linear-gradient(145deg, #f44336, #d32f2f);
            box-shadow: 0 5px 0 #b71c1c, 0 8px 15px rgba(0,0,0,0.3);
            margin-top: 25px;
        }
        .backButton:hover { background: linear-gradient(145deg, #ef5350, #e53935); transform: translateY(-2px); box-shadow: 0 7px 0 #b71c1c, 0 10px 20px rgba(0,0,0,0.2); }
        .backButton:active { background: linear-gradient(145deg, #d32f2f, #c62828); transform: translateY(2px);box-shadow: 0 2px 0 #b71c1c, 0 5px 10px rgba(0,0,0,0.4); }

        #playerMoneyDisplay {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(1.1em, 3.2vw, 1.6em);
            color: #FFD700;
            background-color: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 210;
            border: 1px solid rgba(255,215,0,0.5);
            font-weight: bold;
        }

        .screen-content-wrapper {
            padding: 20px;
            padding-top: 30px;
            box-sizing: border-box;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            flex-grow: 1;
        }


        #shopItemsContainer {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 15px;
            width: 95%;
            max-width: 900px;
            background-color: rgba(255,255,255,0.03);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 15px;
        }
        .shopItem {
            background-color: rgba(40,40,40,0.8);
            border: 1px solid #555;
            border-radius: 10px;
            padding: 20px;
            width: clamp(220px, 30vw, 280px);
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .shopItem:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        .shopItem.expensive-skin-glow {
            box-shadow: 0 0 18px gold, 0 0 30px #FFFF99, 0 5px 15px rgba(0,0,0,0.5);
            border: 1px solid gold;
        }
        .shopItem.expensive-skin-glow:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 25px gold, 0 0 40px #FFFF99, 0 8px 25px rgba(0,0,0,0.4);
        }

        .shopItem h3 { margin-top: 0; margin-bottom: 8px; color: #FFD700; font-size: clamp(1.2em, 3vw, 1.5em);}
        .shopItem p { font-size: clamp(0.85em, 2.5vw, 1.05em); margin-bottom: 10px; color: #ccc;}
        .shopItem .price { font-weight: bold; color: #8BC34A; font-size: clamp(1em, 2.8vw, 1.2em); }
        .shopItem .owned { color: #4CAF50; font-weight: bold; font-size: clamp(1em, 2.8vw, 1.2em); }
        .buySkinButton {
            background: linear-gradient(145deg, #03A9F4, #0288D1);
            box-shadow: 0 4px 0 #0277BD, 0 6px 12px rgba(0,0,0,0.25);
            font-size: clamp(1em, 3.5vw, 1.4em); padding: 10px 20px; min-width: 150px;
        }
        .buySkinButton:hover { background: linear-gradient(145deg, #29B6F6, #039BE5);transform: translateY(-1px);box-shadow: 0 5px 0 #0277BD, 0 7px 15px rgba(0,0,0,0.2); }
        .buySkinButton:active { background: linear-gradient(145deg, #0288D1, #0277BD);transform: translateY(1px);box-shadow: 0 2px 0 #0277BD, 0 4px 8px rgba(0,0,0,0.3); }
        .buySkinButton:disabled {
            background: #78909C; color: #CFD8DC;
            box-shadow: 0 4px #546E7A; cursor: not-allowed;
        }
        .skin-color-preview {
            width: 40px; height: 40px; border-radius: 50%;
            margin: 0 auto 15px auto; border: 3px solid white;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        .bullet-color-preview {
            width: 15px; height: 15px; border-radius: 50%;
            display: inline-block; margin-left: 8px;
            border: 1px solid rgba(255,255,255,0.7);
            vertical-align: middle;
        }

        #mySkinsSection, #mapSelectorContainer {
            margin-top: 15px;
            text-align: center;
            background-color: rgba(0,0,0,0.2);
            padding: 10px 15px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
        }
        #mySkinsSection h2, #mapSelectorContainer h2 {
            font-size: clamp(1.2em, 3.5vw, 1.7em);
            margin-bottom: 8px; color: #FFEB3B;
        }
        #skinSelector, #mapSelectorMenu {
            padding: 10px 15px;
            font-size: clamp(1em, 3vw, 1.3em);
            border-radius: 6px;
            background-color: #555;
            color: white;
            border: 1px solid #777;
            min-width: 250px;
            width: 100%;
            box-sizing: border-box;
        }

        /* Profile Screen */
        #profileScreen .profile-info {
            background-color: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #profileScreen label { display: block; margin-top: 10px; font-size: 1.1em; color: #FFC107; }
        #profileScreen input[type="text"] {
            padding: 8px; margin-top: 5px; border-radius: 5px; border: 1px solid #777;
            background-color: #444; color: white; font-size: 1em; width: 80%;
        }
        #profileScreen .stat { margin: 8px 0; font-size: 1.2em; }
        #profileScreen .stat-label { color: #BDBDBD; }
        #profileScreen .stat-value { color: #4CAF50; font-weight: bold; }
        #profileScreen #ownedSkinsList { list-style: none; padding: 0; margin-top: 10px;}
        #profileScreen #ownedSkinsList li {
            background-color: rgba(255,255,255,0.1);
            margin: 5px 0;
            padding: 8px 12px;
            border-radius: 4px;
            display: flex;
            align-items: center;
        }

        /* Leaderboard Screen */
        #leaderboardScreen .leaderboard-section {
            background-color: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            width: 90%;
            max-width: 600px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #leaderboardScreen h2 {
            color: #FFC107;
            font-size: clamp(1.4em, 4vw, 2em);
            margin-bottom: 10px;
        }
        #leaderboardScreen ol {
            list-style-type: decimal;
            padding-left: 30px;
            margin: 0;
            text-align: left;
        }
        #leaderboardScreen li {
            padding: 8px 5px;
            font-size: clamp(1em, 2.8vw, 1.3em);
            color: #eee;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        #leaderboardScreen li:last-child {
            border-bottom: none;
        }
        #leaderboardScreen li .username { font-weight: bold; color: #87CEFA; }
        #leaderboardScreen li .score { float: right; color: #FFD700; }


        #messageScreen { z-index: 300; }
        .game-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(1em, 3vw, 1.5em);
            color: #eee;
            opacity: 0.6;
            text-shadow: 1px 1px #000;
            pointer-events: none;
        }
        #otherGameLinkContainer {
            position: fixed;
            bottom: 5px;
            width: 100%;
            text-align: center;
            font-size: 0.7em;
            z-index: 500;
            color: #ccc;
            padding: 2px 0;
            background-color: rgba(0,0,0,0.3);
        }
        #otherGameLinkContainer a { color: #87CEFA; text-decoration: none; }
        #otherGameLinkContainer a:hover { text-decoration: underline; }

        .instructions { margin-top: 20px; font-size: clamp(0.7em, 2.5vw, 0.9em); text-align: center; max-width: 90%; color: #aaa; }
        .instructions p { margin: 5px 0; }

        #menuScreen .main-menu-content {
            padding-left: 15px;
            padding-right: 15px;
            padding-top: 5px;
            padding-bottom: 5px;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
            flex-grow: 1;
            -webkit-overflow-scrolling: touch;
        }

    </style>
</head>
<body>
    <div id="playerMoneyDisplay">$0</div>

    <div id="menuScreen" class="screen active">
        <div id="menuScreenHeaderButtons">
            <button class="menuButton baseButton" id="fullscreenButton">‚ÜîÔ∏è Fullscreen</button>
            <button class="profileButton menuScreenBtn baseButton" id="profileButtonMenu">üë§ Profile</button>
        </div>

        <div class="main-menu-content">
            <h1>Tank Battle</h1>
            <p>By Lapis Yamz</p>
            <button class="menuButton baseButton" id="vsCPUButton">VS Computer</button>
            <button class="menuButton baseButton" id="twoPlayerButton">2 Player Local</button>

            <div id="mapSelectorContainer">
                <h2>Select Map:</h2>
                <select id="mapSelectorMenu"></select>
            </div>

            <div id="mySkinsSection">
                <h2>My Tank Skin:</h2>
                <select id="skinSelector"></select>
            </div>

            <div class="instructions">
                <p>P1: WASD (move), QE (turret), Space (shoot)</p>
                <p>P2: Arrows (move), Comma/Period (turret), Enter (shoot)</p>
                <p>Mobile (VS CPU): P1 Joystick Bottom-Left, Fire Bottom-Right</p>
                <p>Mobile (2 Player): P1 Joystick Top-Left, Fire Top-Right</p>
                <p style="margin-top:5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2 Joystick Bottom-Right, Fire Bottom-Left</p>
            </div>
        </div>

        <div id="menuScreenFooterButtons">
             <button class="leaderboardButton menuScreenBtn baseButton" id="leaderboardButtonMenu">üèÜ Leaderboard</button>
             <button class="shopButton menuScreenBtn baseButton" id="shopButtonMenu">üõçÔ∏è Shop</button>
        </div>
    </div>

    <div id="difficultyScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Select AI Difficulty</h1>
            <button class="difficultyButton baseButton" data-difficulty="EASY">Easy ($5 Reward)</button>
            <button class="difficultyButton baseButton" data-difficulty="NORMAL">Normal ($10 Reward)</button>
            <button class="difficultyButton baseButton" data-difficulty="HARD">Hard ($20 Reward)</button>
            <button class="difficultyButton baseButton" data-difficulty="FREESTYLE">Freestyle ($30 Reward)</button>
            <button class="backButton baseButton" id="backToMenuFromDifficulty">Back to Menu</button>
        </div>
    </div>

    <div id="shopScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Tank Skin Shop</h1>
            <div id="shopItemsContainer">
                <!-- Shop items will be populated here by JavaScript -->
            </div>
            <button class="backButton baseButton" id="backToMenuFromShop">Back to Menu</button>
        </div>
    </div>

    <div id="profileScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Player Profile</h1>
            <div class="profile-info">
                <div>
                    <label for="usernameInput">Username:</label>
                    <input type="text" id="usernameInput" placeholder="Enter your name">
                </div>
                <p class="stat"><span class="stat-label">Money:</span> <span id="profileMoney" class="stat-value">$0</span></p>
                <p class="stat"><span class="stat-label">Games Played:</span> <span id="profileGamesPlayed" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">Wins:</span> <span id="profileWins" class="stat-value">0</span></p>
                <p class="stat"><span class="stat-label">Losses:</span> <span id="profileLosses" class="stat-value">0</span></p>
                <div>
                    <h3 style="color: #FFC107; margin-top: 15px;">Owned Skins:</h3>
                    <ul id="ownedSkinsList"></ul>
                </div>
            </div>
            <button class="backButton baseButton" id="backToMenuFromProfile">Back to Menu</button>
            <p style="font-size: 0.8em; color: #777; margin-top: 15px;">Note: Profile data is saved locally in your browser.</p>
        </div>
    </div>

    <div id="leaderboardScreen" class="screen">
        <div class="screen-content-wrapper">
            <h1>Leaderboards</h1>
            <div class="leaderboard-section">
                <h2>üí∞ Richest Players (Top Money)</h2>
                <ol id="leaderboardMoneyList"></ol>
            </div>
            <div class="leaderboard-section">
                <h2>üèÜ Top Victors (Most Wins)</h2>
                <ol id="leaderboardWinsList"></ol>
            </div>
            <div class="leaderboard-section">
                <h2>‚ú® Skin Collectors (Most Skins)</h2>
                <ol id="leaderboardSkinsList"></ol>
            </div>
            <button class="backButton baseButton" id="backToMenuFromLeaderboard">Back to Menu</button>
        </div>
    </div>


    <div id="gameArea">
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div id="uiLayer"></div>
        </div>
        <div class="game-title">Tank Battle by Lapis Yamz</div>
    </div>

    <div id="joystickContainerP1" class="joystick-container-base">
        <div id="joystickHandleP1" class="joystick-handle-base"></div>
    </div>
    <div id="fireButtonContainerP1" class="fire-button-container-base">
        <button id="fireButtonP1" class="fire-button-base">FIRE</button>
    </div>

    <div id="joystickContainerP2" class="joystick-container-base">
        <div id="joystickHandleP2" class="joystick-handle-base"></div>
    </div>
    <div id="fireButtonContainerP2" class="fire-button-container-base">
        <button id="fireButtonP2" class="fire-button-base">FIRE</button>
    </div>

    <div id="messageScreen" class="screen">
        <div class="screen-content-wrapper">
            <div id="messageText" style="font-size: clamp(1.8em, 6vw, 2.8em); color: white; margin-bottom: 20px;">Game Over!</div>
            <button class="menuButton baseButton" id="playAgainButton">Play Again (Same Mode)</button>
            <button class="backButton baseButton" id="backToMenuButton">Back to Menu</button>
        </div>
    </div>

    <div id="otherGameLinkContainer">
        Try our other game: <a href="https://kismat8178.github.io/LapisYamCricket/" target="_blank">LapisYamCricket</a> |
        My YouTube: <a href="https://www.youtube.com/@gamingwithkismat8178" target="_blank">@gamingwithkismat8178</a>
    </div>

    <script>
        const gameArea = document.getElementById('gameArea');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('uiLayer');
        const gameContainer = document.getElementById('gameContainer');

        const joystickContainerP1 = document.getElementById('joystickContainerP1');
        const joystickHandleP1 = document.getElementById('joystickHandleP1');
        const fireButtonContainerP1 = document.getElementById('fireButtonContainerP1');
        const fireButtonP1 = document.getElementById('fireButtonP1');
        const joystickContainerP2 = document.getElementById('joystickContainerP2');
        const joystickHandleP2 = document.getElementById('joystickHandleP2');
        const fireButtonContainerP2 = document.getElementById('fireButtonContainerP2');
        const fireButtonP2 = document.getElementById('fireButtonP2');

        const menuScreen = document.getElementById('menuScreen');
        const difficultyScreen = document.getElementById('difficultyScreen');
        const shopScreen = document.getElementById('shopScreen');
        const profileScreen = document.getElementById('profileScreen');
        const leaderboardScreen = document.getElementById('leaderboardScreen');
        const messageScreen = document.getElementById('messageScreen');

        const vsCPUButton = document.getElementById('vsCPUButton');
        const twoPlayerButton = document.getElementById('twoPlayerButton');
        const shopButtonMenu = document.getElementById('shopButtonMenu');
        const profileButtonMenu = document.getElementById('profileButtonMenu');
        const leaderboardButtonMenu = document.getElementById('leaderboardButtonMenu');
        const fullscreenButton = document.getElementById('fullscreenButton');

        const backToMenuFromDifficulty = document.getElementById('backToMenuFromDifficulty');
        const backToMenuFromShop = document.getElementById('backToMenuFromShop');
        const backToMenuFromProfile = document.getElementById('backToMenuFromProfile');
        const backToMenuFromLeaderboard = document.getElementById('backToMenuFromLeaderboard');

        const messageText = document.getElementById('messageText');
        const playAgainButton = document.getElementById('playAgainButton');
        const backToMenuButton = document.getElementById('backToMenuButton');

        const playerMoneyDisplay = document.getElementById('playerMoneyDisplay');
        const shopItemsContainer = document.getElementById('shopItemsContainer');
        const skinSelector = document.getElementById('skinSelector');
        const mapSelectorMenu = document.getElementById('mapSelectorMenu');


        const usernameInput = document.getElementById('usernameInput');
        const profileMoney = document.getElementById('profileMoney');
        const profileGamesPlayed = document.getElementById('profileGamesPlayed');
        const profileWins = document.getElementById('profileWins');
        const profileLosses = document.getElementById('profileLosses');
        const ownedSkinsList = document.getElementById('ownedSkinsList');

        const leaderboardMoneyList = document.getElementById('leaderboardMoneyList');
        const leaderboardWinsList = document.getElementById('leaderboardWinsList');
        const leaderboardSkinsList = document.getElementById('leaderboardSkinsList');


        let gameMode = null;
        let currentAiDifficulty = 'NORMAL';
        let gameRunning = false;
        let animationFrameId;

        let G_MAP_WIDTH = 1200;
        let G_MAP_HEIGHT = 800;

        const TANK_SIZE = 40;
        const TURRET_LENGTH = TANK_SIZE * 0.9;
        const TURRET_WIDTH = TANK_SIZE * 0.25;
        const BULLET_SPEED_BASE = 8;
        const BULLET_SIZE = 6;
        const BASE_TANK_SPEED = 2;
        const TANK_TURN_SPEED = 0.05;
        const TURRET_TURN_SPEED = 0.07;
        const MAX_HEALTH_BASE = 100;
        const SHOOT_COOLDOWN_BASE = 600;
        const BASE_BULLET_DAMAGE = 12;
        const POWERUP_SIZE = 25;
        const POWERUP_DURATION_BASE = 10000;
        const POWERUP_SPAWN_INTERVAL = 12000;


        let player1, player2;
        const bullets = [];
        const obstacles = [];
        const powerUps = [];
        let lastPowerUpSpawnTime = 0;

        const keys = {};
        let G_SCALE = 1;

        let playerData = {
            username: 'Player',
            money: 0,
            ownedSkins: ['default'],
            selectedSkinId: 'default',
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            selectedMapId: 'classic'
        };

        const SKINS = {
            'default': {
                name: 'Default Mark I', price: 0, color: '#337ab7', bulletColor: '#222222',
                description: "The tried and true classic.",
                p2Color: '#d9534f'
            },
            'scout': {
                name: 'Light Scout X2', price: 75, color: '#90EE90', bulletColor: '#7FFF00',
                description: "Faster movement & fire rate, lighter armor.",
                healthMultiplier: 0.85, speedMultiplier: 1.25, cooldownMultiplier: 0.92,
            },
            'bruiser': {
                name: 'Heavy Bruiser T7', price: 150, color: '#B22222', bulletColor: '#FF4500',
                description: "Heavy armor, stronger shells, but slower.",
                healthMultiplier: 1.30, speedMultiplier: 0.80, damageMultiplier: 1.20,
            },
            'sharpshooter': {
                name: 'Sniper Model S', price: 300, color: '#00CED1', bulletColor: '#00FFFF',
                description: "Enhanced targeting. Higher damage, quick reload. Fragile.",
                healthMultiplier: 0.80, damageMultiplier: 1.35, cooldownMultiplier: 0.75,
            },
            'phantom': {
                name: 'Phantom Stealth', price: 550, color: '#6A0DAD', bulletColor: '#DA70D6',
                description: "Quick & deadly. Starts with a temporary shield for 6s.",
                healthMultiplier: 0.95, speedMultiplier: 1.20, damageMultiplier: 1.15, cooldownMultiplier: 0.88,
                special: 'starts_shielded_briefly'
            },
            'golden_goliath': {
                name: 'Golden Goliath', price: 1200, color: '#B8860B', /* DarkGoldenRod base */ bulletColor: '#FFA500',
                description: "The ultimate tank. Superior stats. Power-ups last 30% longer. Slight health regen.",
                healthMultiplier: 1.5, speedMultiplier: 1.15, damageMultiplier: 1.25, cooldownMultiplier: 0.80,
                special: 'powerup_duration_boost_regen'
            }
        };

        const MAPS_CONFIG = {
            classic: {
                name: "Classic Arena",
                width: 1200,
                height: 800,
                playerSpawns: [
                    { x: () => 150, y: () => G_MAP_HEIGHT / 2 + 50, angle: Math.PI / 2 },
                    { x: () => G_MAP_WIDTH - 150, y: () => G_MAP_HEIGHT / 2 - 50, angle: -Math.PI / 2 }
                ],
                obstacles: [
                    { x: () => G_MAP_WIDTH/2 - 120, y: () => G_MAP_HEIGHT/2 - 200, w: 240, h: 80 },
                    { x: () => G_MAP_WIDTH/2 - 120, y: () => G_MAP_HEIGHT/2 + 120, w: 240, h: 80 },
                    { x: () => G_MAP_WIDTH/2 - 40,  y: () => G_MAP_HEIGHT/2 - 120, w: 80,  h: 240 },
                    { x: () => 100, y: () => 100, w: 120, h: 60 },
                    { x: () => G_MAP_WIDTH - 220, y: () => 100, w: 120, h: 60 },
                    { x: () => 100, y: () => G_MAP_HEIGHT - 160, w: 120, h: 60 },
                    { x: () => G_MAP_WIDTH - 220, y: () => G_MAP_HEIGHT - 160, w: 120, h: 60 },
                    { x: () => 300, y: () => G_MAP_HEIGHT/2 - 30, w: 60, h: 100, color: '#8c6c46' },
                    { x: () => G_MAP_WIDTH - 360, y: () => G_MAP_HEIGHT/2 - 70, w: 60, h: 100, color: '#8c6c46' },
                    { x: () => G_MAP_WIDTH/2 + 150, y: () => 200, w: 100, h: 50 },
                    { x: () => G_MAP_WIDTH/2 - 250, y: () => G_MAP_HEIGHT - 250, w: 100, h: 50 }
                ],
                bgColor: '#bfa870'
            },
            urban_chaos: {
                name: "Urban Chaos",
                width: 1600,
                height: 1000,
                playerSpawns: [
                    { x: () => 100, y: () => 100, angle: Math.PI / 4 },
                    { x: () => G_MAP_WIDTH - 100, y: () => G_MAP_HEIGHT - 100, angle: -3 * Math.PI / 4 }
                ],
                obstacles: [
                    { x: () => G_MAP_WIDTH * 0.2, y: () => G_MAP_HEIGHT * 0.2, w: 300, h: 60, color: '#606060' },
                    { x: () => G_MAP_WIDTH * 0.2, y: () => G_MAP_HEIGHT * 0.2 + 100, w: 60, h: 200, color: '#606060' },
                    { x: () => G_MAP_WIDTH * 0.8 - 300, y: () => G_MAP_HEIGHT * 0.8 - 60, w: 300, h: 60, color: '#555555' },
                    { x: () => G_MAP_WIDTH * 0.8 - 60, y: () => G_MAP_HEIGHT * 0.8 - 260, w: 60, h: 200, color: '#555555' },
                    { x: () => G_MAP_WIDTH / 2 - 150, y: () => G_MAP_HEIGHT / 2 - 30, w: 300, h: 60, color: '#666' },
                    { x: () => G_MAP_WIDTH / 2 - 30, y: () => G_MAP_HEIGHT / 2 - 150, w: 60, h: 300, color: '#666' },
                    { x: () => 150, y: () => G_MAP_HEIGHT - 200, w: 250, h: 50, color: '#505050' },
                    { x: () => G_MAP_WIDTH - 400, y: () => 150, w: 250, h: 50, color: '#505050' }
                ],
                bgColor: '#A9A9A9'
            },
            vast_wasteland: {
                name: "Vast Wasteland",
                width: 2400,
                height: 1600,
                playerSpawns: [
                    { x: () => 200, y: () => G_MAP_HEIGHT / 2, angle: 0 },
                    { x: () => G_MAP_WIDTH - 200, y: () => G_MAP_HEIGHT / 2, angle: Math.PI }
                ],
                obstacles: [
                    { x: () => G_MAP_WIDTH/2 - 200, y: () => G_MAP_HEIGHT/2 - 200, w: 400, h: 400, color: '#5A5A5A'},
                    { x: () => G_MAP_WIDTH * 0.25 - 100, y: () => G_MAP_HEIGHT * 0.25 - 100, w: 200, h: 200, color: '#706233'},
                    { x: () => G_MAP_WIDTH * 0.75 - 100, y: () => G_MAP_HEIGHT * 0.25 - 100, w: 200, h: 200, color: '#706233'},
                    { x: () => G_MAP_WIDTH * 0.25 - 100, y: () => G_MAP_HEIGHT * 0.75 - 100, w: 200, h: 200, color: '#706233'},
                    { x: () => G_MAP_WIDTH * 0.75 - 100, y: () => G_MAP_HEIGHT * 0.75 - 100, w: 200, h: 200, color: '#706233'},
                    ...Array.from({length: 30}).map((_,i) => ({
                        x: () => Math.random() * (G_MAP_WIDTH - 150) + 50,
                        y: () => Math.random() * (G_MAP_HEIGHT - 150) + 50,
                        w: () => Math.random() * 100 + 50,
                        h: () => Math.random() * 100 + 50,
                        color: (Math.random() < 0.6 ? '#8c6c46' : '#7a5230')
                    }))
                ].filter(obs => {
                    const x = typeof obs.x === 'function' ? obs.x() : obs.x;
                    const y = typeof obs.y === 'function' ? obs.y() : obs.y;
                    if (Math.hypot(x - G_MAP_WIDTH/2, y - G_MAP_HEIGHT/2) < 300 && obs.w < 300) return false;
                    if (Math.hypot(x - 200, y - G_MAP_HEIGHT/2) < 200) return false;
                    if (Math.hypot(x - (G_MAP_WIDTH-200), y - G_MAP_HEIGHT/2) < 200) return false;
                    return true;
                }),
                bgColor: '#D2B48C'
            }
        };
        let currentMapId = 'classic';


        const PLAYER_DATA_KEY = 'tankBattlePlayerData_v2.5.4';
        const LEADERBOARD_KEY = 'tankBattleLeaderboard_v2.5.4';
        const MAX_LEADERBOARD_ENTRIES = 10;
        let leaderboardEntries = [];

        function loadPlayerData() {
            const savedData = localStorage.getItem(PLAYER_DATA_KEY);
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    playerData = {...playerData, ...parsedData};
                } catch (e) {
                    console.error("Error parsing player data from localStorage:", e);
                }

                if (!playerData.ownedSkins || !Array.isArray(playerData.ownedSkins)) {
                    playerData.ownedSkins = ['default'];
                } else if (!playerData.ownedSkins.includes('default')) {
                    playerData.ownedSkins.push('default');
                }
                if (!playerData.selectedSkinId || !SKINS[playerData.selectedSkinId] || !playerData.ownedSkins.includes(playerData.selectedSkinId)) {
                    playerData.selectedSkinId = 'default';
                }
                currentMapId = playerData.selectedMapId && MAPS_CONFIG[playerData.selectedMapId] ? playerData.selectedMapId : 'classic';
            }

            if (playerData.username === 'Lapis Yamz') { // Admin money
                playerData.money = Math.max(playerData.money, 10000000);
            }

            updateMoneyDisplay();
            populateSkinSelector();
            populateMapSelector();
            if (usernameInput) usernameInput.value = playerData.username;
            loadLeaderboardEntries(); // Load LB after player data potentially updates username for it
        }

        function savePlayerData() {
            playerData.selectedMapId = currentMapId;
            try {
                localStorage.setItem(PLAYER_DATA_KEY, JSON.stringify(playerData));
                // console.log("Player data saved:", JSON.parse(JSON.stringify(playerData)));
            } catch (e) {
                console.error("Error saving player data to localStorage:", e);
            }
            updateMoneyDisplay();
            updateLeaderboardEntry(playerData); // This will update LB array and save it
            if (profileScreen.classList.contains('active')) {
                populateProfileScreen(); // Refresh profile if it's currently viewed
            }
        }

        function loadLeaderboardEntries() {
            const savedLeaderboard = localStorage.getItem(LEADERBOARD_KEY);
            if (savedLeaderboard) {
                try {
                    leaderboardEntries = JSON.parse(savedLeaderboard);
                } catch (e) {
                    console.error("Error parsing leaderboard data:", e);
                    leaderboardEntries = [];
                }
            } else {
                leaderboardEntries = [];
            }
        }

        function saveLeaderboardEntries() {
            try {
                localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboardEntries));
                // console.log("Leaderboard entries saved.");
            } catch (e) {
                console.error("Error saving leaderboard data:", e);
            }
        }

        function updateLeaderboardEntry(currentProfile) {
            if (!currentProfile || typeof currentProfile.username !== 'string' || currentProfile.username.trim() === '') {
                // console.warn("Attempted to update leaderboard with invalid or empty username in profile:", currentProfile);
                return;
            }
            const entryIndex = leaderboardEntries.findIndex(entry => entry.username === currentProfile.username);
            const newEntry = {
                username: currentProfile.username,
                money: currentProfile.money || 0,
                wins: currentProfile.wins || 0,
                gamesPlayed: currentProfile.gamesPlayed || 0,
                losses: currentProfile.losses || 0,
                skinsCount: currentProfile.ownedSkins ? currentProfile.ownedSkins.length : 0
            };

            if (entryIndex > -1) {
                leaderboardEntries[entryIndex] = newEntry;
            } else {
                leaderboardEntries.push(newEntry);
            }
            saveLeaderboardEntries(); // Save LB immediately after updating array
        }

        function populateLeaderboardScreen() {
            if (!leaderboardScreen.classList.contains('active')) return;
            loadLeaderboardEntries(); // Always load fresh from localStorage

            const displayLeaderboard = (listElement, data, sortFn, valueFn) => {
                listElement.innerHTML = '';
                const sortedData = [...data].sort(sortFn).slice(0, MAX_LEADERBOARD_ENTRIES);
                if (sortedData.length === 0) {
                    listElement.innerHTML = '<li>No data yet. Play some games!</li>';
                    return;
                }
                sortedData.forEach(entry => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="username">${entry.username || 'Unknown'}</span> <span class="score">${valueFn(entry)}</span>`;
                    listElement.appendChild(li);
                });
            };

            displayLeaderboard(leaderboardMoneyList, leaderboardEntries, (a, b) => (b.money || 0) - (a.money || 0), entry => `$${entry.money || 0}`);
            displayLeaderboard(leaderboardWinsList, leaderboardEntries, (a, b) => (b.wins || 0) - (a.wins || 0), entry => `${entry.wins || 0} wins`);
            displayLeaderboard(leaderboardSkinsList, leaderboardEntries, (a, b) => (b.skinsCount || 0) - (a.skinsCount || 0), entry => `${entry.skinsCount || 0} skins`);
        }


        function updateGameStats(player1Won) {
            playerData.gamesPlayed = (playerData.gamesPlayed || 0) + 1;
            if (player1Won) {
                playerData.wins = (playerData.wins || 0) + 1;
            } else {
                playerData.losses = (playerData.losses || 0) + 1;
            }
            savePlayerData();
        }

        function updateMoneyDisplay() {
            playerMoneyDisplay.textContent = `$${playerData.money || 0}`;
        }

        function addMoney(amount) {
            playerData.money = (playerData.money || 0) + amount;
            savePlayerData();
        }

        let audioCtx;
        let shootGain;

        function initAudio() {
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.warn("Audio context resume failed:", e));
            }
            if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (!audioCtx) {
                    console.warn("Web Audio API not supported. No sound will play.");
                    return;
                }
                shootGain = audioCtx.createGain();
                shootGain.connect(audioCtx.destination);
                shootGain.gain.value = 0.07;
            }
        }
        document.body.addEventListener('click', initAudio, { once: true });
        document.body.addEventListener('touchstart', initAudio, { once: true });


        function playShootSound() {
            if (!audioCtx || audioCtx.state === 'suspended') {
                initAudio();
                 if (!audioCtx || audioCtx.state === 'suspended') return;
            }
            try {
                const oscillator = audioCtx.createOscillator();
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);

                const gainNode = audioCtx.createGain();
                gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

                oscillator.connect(gainNode);
                gainNode.connect(shootGain);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.11);
            } catch (e) {
                console.warn("Error playing shoot sound:", e);
            }
        }

        function normalizeAngle(angle) {
            angle = angle % (2 * Math.PI);
            if (angle < 0) angle += (2 * Math.PI);
            return angle;
        }

        function getShadedColor(hexColor, percent) {
            if (!hexColor || !hexColor.startsWith('#')) return '#808080';
            let R = parseInt(hexColor.substring(1,3),16);
            let G = parseInt(hexColor.substring(3,5),16);
            let B = parseInt(hexColor.substring(5,7),16);
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            R = Math.max(0, Math.min(255, R));
            G = Math.max(0, Math.min(255, G));
            B = Math.max(0, Math.min(255, B));
            const RR = R.toString(16).padStart(2, '0');
            const GG = G.toString(16).padStart(2, '0');
            const BB = B.toString(16).padStart(2, '0');
            return `#${RR}${GG}${BB}`;
        }


        class Tank {
            constructor(id, x, y, isAI = false, skinId = 'default', aiDifficulty = 'NORMAL') {
                this.id = id;
                this.x = x;
                this.y = y;
                this.width = TANK_SIZE;
                this.height = TANK_SIZE;

                this.hullWidth = TANK_SIZE * 0.95;
                this.hullHeight = TANK_SIZE * 0.65;

                this.angle = (this.id === 'player1') ? Math.PI / 2 : -Math.PI / 2;
                this.turretAngle = this.angle;
                this.isAI = isAI;
                this.aiDifficulty = aiDifficulty;

                const skinDataToUse = SKINS[skinId] || SKINS['default'];
                this.skinId = skinId;

                this.color = skinDataToUse.color;
                this.bulletColor = skinDataToUse.bulletColor || '#222222';
                this.maxHealth = MAX_HEALTH_BASE * (skinDataToUse.healthMultiplier || 1);
                this.speed = BASE_TANK_SPEED * (skinDataToUse.speedMultiplier || 1);
                this.shootCooldownValue = SHOOT_COOLDOWN_BASE * (skinDataToUse.cooldownMultiplier || 1);
                this.bulletDamage = BASE_BULLET_DAMAGE * (skinDataToUse.damageMultiplier || 1);
                this.skinSpecial = skinDataToUse.special;
                this.healthRegenRate = (this.skinSpecial === 'powerup_duration_boost_regen' ? 0.2 / 60 : 0); // Rate per 1/60th sec target frame

                if ((this.id === 'player2' || this.id === 'player2_ai') && skinId === 'default') {
                    this.color = SKINS['default'].p2Color;
                }

                this.health = this.maxHealth;

                if (currentMapId === 'vast_wasteland') {
                    this.speed *= 1.20;
                }

                this.turnSpeed = TANK_TURN_SPEED;
                this.turretTurnSpeed = TURRET_TURN_SPEED;
                this.lastShotTime = 0;
                this.shielded = false;
                this.shieldTimer = 0;
                this.speedBoostActive = false;
                this.speedBoostTimer = 0;
                this.powerUpDurationMultiplier = 1;
                if (this.skinSpecial === 'powerup_duration_boost_regen' || this.skinSpecial === 'powerup_duration_boost') {
                     this.powerUpDurationMultiplier = 1.30;
                }

                if (this.skinSpecial === 'starts_shielded_briefly') {
                    this.shielded = true;
                    this.shieldTimer = 6000; // in ms
                }

                if (this.isAI) {
                    this.aiState = 'IDLE'; this.aiTarget = null; this.aiMoveCooldown = 0;
                    this.aiLastPosition = { x: this.x, y: this.y }; this.aiStuckTimer = 0;
                    this.AI_STUCK_THRESHOLD = 1500; // ms
                    this.AI_MIN_MOVE_DIST_FOR_STUCK_CHECK = 0.01; // (0.1 pixels)^2 Ensures tiny valid moves don't register as stuck.
                    this.aiAimInaccuracyFactor = 0.45; this.aiShootingAngleTolerance = 0.5;
                    this.aiCurrentAimOffset = 0; this.aiNextAimAdjustTimer = 0;
                    this.aiHesitationFactor = 0.25; this.aiPostActionReactionTime = 300;
                    this.aiGeneralReactionTimer = 0; this.aiTargetLostTimer = 0;
                    this.AI_TARGET_LOST_PATROL_THRESHOLD = 4000; this.aiEvadeTimer = 0;
                    this.aiIsDodgingBullet = false;
                    this.currentDodgeAngle = 0;
                }

                this.healthBarContainer = document.createElement('div');
                this.healthBarContainer.className = 'health-bar-container';
                this.healthBarDiv = document.createElement('div');
                this.healthBarDiv.className = 'health-bar';
                this.healthBarContainer.appendChild(this.healthBarDiv);
                this.shieldIndicatorDiv = document.createElement('div');
                this.shieldIndicatorDiv.className = 'shield-indicator';
                this.shieldIndicatorDiv.style.display = 'none';
                this.healthBarContainer.appendChild(this.shieldIndicatorDiv);
                uiLayer.appendChild(this.healthBarContainer);
                this.updateHealthBar();
                this.updateHealthBarPosition();
            }

            update(normalizedDeltaTime, rawDeltaTime_ms) { // Receives normalized for physics/anim, raw for timers
                if (this.healthRegenRate > 0 && this.health < this.maxHealth) {
                    // healthRegenRate is defined as 'rate per 1/60th of a second'
                    // normalizedDeltaTime is 'how many 1/60th second equivalents passed this frame'
                    this.health += this.healthRegenRate * normalizedDeltaTime; 
                    if (this.health > this.maxHealth) this.health = this.maxHealth;
                    this.updateHealthBar();
                }
                this.updatePowerUps(rawDeltaTime_ms); // Pass raw ms for timers
            }

            draw() {
                ctx.save();

                const skinData = SKINS[this.skinId] || SKINS['default'];
                let isPremiumSkin = skinData.price >= 1000 || this.skinId === 'golden_goliath' || this.skinId === 'phantom';

                if (isPremiumSkin) {
                    let glowColor = 'rgba(255,255,255,0.7)';
                    if (this.skinId === 'golden_goliath') glowColor = 'rgba(255, 215, 0, 0.6)'; // More distinct gold glow
                    else if (this.skinId === 'phantom') glowColor = 'rgba(180, 80, 255, 0.7)';
                    else if (skinData.bulletColor) {
                        const hex = skinData.bulletColor.replace('#', '');
                        if (hex.length === 6) { // Ensure valid hex
                            const r = parseInt(hex.substring(0,2), 16);
                            const g = parseInt(hex.substring(2,4), 16);
                            const b = parseInt(hex.substring(4,6), 16);
                            if (r > 150 || g > 150 || b > 150) { // Simple brightness check
                                glowColor = skinData.bulletColor.startsWith('rgba') ? skinData.bulletColor : skinData.bulletColor + 'b3';
                            }
                        }
                    }
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 12 + Math.sin(Date.now() / 250) * 4;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const bodyBaseColor = (this.skinId === 'golden_goliath') ? SKINS.golden_goliath.color : this.color;
                const trackColor = getShadedColor(bodyBaseColor, -40);
                const upperHullColor = bodyBaseColor;
                const detailColor = getShadedColor(bodyBaseColor, -20);

                const trackHeightActual = this.height * 0.4;
                const hullHeightActual = this.height * 0.6;
                const trackOffsetY = hullHeightActual / 2;

                ctx.fillStyle = trackColor;
                ctx.fillRect(-this.width / 2, trackOffsetY - trackHeightActual / 2, this.width, trackHeightActual);

                ctx.strokeStyle = getShadedColor(trackColor, -20);
                ctx.lineWidth = 2;
                const numTreads = 5;
                for (let i = 0; i <= numTreads; i++) {
                    const xPos = -this.width / 2 + (i / numTreads) * this.width;
                    ctx.beginPath(); ctx.moveTo(xPos, trackOffsetY - trackHeightActual / 2); ctx.lineTo(xPos, trackOffsetY + trackHeightActual / 2); ctx.stroke();
                }

                ctx.fillStyle = upperHullColor;
                ctx.fillRect(-this.hullWidth / 2, -hullHeightActual / 2, this.hullWidth, hullHeightActual);

                if (this.skinId === 'golden_goliath') {
                    // Gold highlight
                    ctx.strokeStyle = '#FFFACD'; // LemonChiffon - bright gold highlight
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(-this.hullWidth / 2, -hullHeightActual / 2); // Top-left
                    ctx.lineTo(this.hullWidth / 2, -hullHeightActual / 2);  // Top-right
                    ctx.lineTo(this.hullWidth / 2, hullHeightActual / 2 - trackHeightActual*0.1); // Partway down right side
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(-this.hullWidth / 2, -hullHeightActual / 2, this.hullWidth, hullHeightActual);
                }

                ctx.fillStyle = detailColor;
                ctx.beginPath(); ctx.arc(0, -hullHeightActual * 0.1, TANK_SIZE * 0.1, 0, Math.PI * 2); ctx.fill();

                ctx.restore();


                ctx.save();
                ctx.translate(this.x, this.y);

                const turretRingColor = getShadedColor(bodyBaseColor, this.skinId === 'golden_goliath' ? -30 : -25);
                const turretRingRadius = TANK_SIZE * 0.22;
                ctx.fillStyle = turretRingColor;
                ctx.beginPath(); ctx.arc(0, 0, turretRingRadius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = getShadedColor(turretRingColor, -15); ctx.lineWidth = 1; ctx.stroke();

                ctx.rotate(this.turretAngle);

                const turretBaseActualColor = (this.skinId === 'golden_goliath') ? getShadedColor(bodyBaseColor, -5) : getShadedColor(bodyBaseColor, -10);
                ctx.fillStyle = turretBaseActualColor;
                ctx.fillRect(0, -TURRET_WIDTH / 2, TURRET_LENGTH, TURRET_WIDTH);

                if (this.skinId === 'golden_goliath') {
                    ctx.strokeStyle = '#FFEEAA'; // Lighter gold highlight for barrel
                    ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(0, -TURRET_WIDTH/2); ctx.lineTo(TURRET_LENGTH, -TURRET_WIDTH/2); ctx.stroke();
                }

                const muzzleColor = getShadedColor(turretBaseActualColor, -15);
                const muzzleWidth = TURRET_WIDTH * 1.3;
                const muzzleLength = TURRET_LENGTH * 0.15;
                ctx.fillStyle = muzzleColor;
                ctx.fillRect(TURRET_LENGTH, -muzzleWidth / 2, muzzleLength, muzzleWidth);

                ctx.restore();

                ctx.restore();

                if (this.shielded) {
                    ctx.save();
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.translate(this.x, this.y);
                    ctx.strokeStyle = 'deepskyblue';
                    ctx.lineWidth = 4;
                    ctx.shadowColor = 'rgba(0, 191, 255, 0.8)';
                    ctx.shadowBlur = 10 + Math.sin(Date.now() / 150) * 5;
                    ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
                    ctx.beginPath();
                    ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                this.updateHealthBarPosition();
            }


            updateHealthBarPosition() {
                const barX = (this.x - this.width / 2);
                const barY = (this.y - this.height / 2 - 15 - (this.height * 0.1));
                this.healthBarContainer.style.left = barX + 'px';
                this.healthBarContainer.style.top = barY + 'px';
            }


            updateHealthBar() {
                const healthPercentage = (this.health / this.maxHealth) * 100;
                this.healthBarDiv.style.width = healthPercentage + '%';
                if (healthPercentage <= 0) this.healthBarDiv.style.backgroundColor = 'black';
                else if (healthPercentage < 30) this.healthBarDiv.style.backgroundColor = 'red';
                else if (healthPercentage < 60) this.healthBarDiv.style.backgroundColor = 'orange';
                else this.healthBarDiv.style.backgroundColor = 'limegreen';
                this.shieldIndicatorDiv.style.display = this.shielded ? 'block' : 'none';
            }

            move(direction) {
                const currentSpeed = this.speed * (this.speedBoostActive ? 1.7 : 1);
                const prevX = this.x;
                const prevY = this.y;
                const hitBoxWidth = this.width * 0.9;
                const hitBoxHeight = this.height * 0.9;

                const newXUnchecked = this.x + direction * currentSpeed * Math.cos(this.angle);
                const newYUnchecked = this.y + direction * currentSpeed * Math.sin(this.angle);

                this.x = newXUnchecked;
                if (this.checkCollision(this.x, prevY, hitBoxWidth, hitBoxHeight) || this.checkBoundaryCollisionX()) {
                    this.x = prevX;
                }
                this.y = newYUnchecked;
                 if (this.checkCollision(prevX, this.y, hitBoxWidth, hitBoxHeight) || this.checkBoundaryCollisionY()) {
                    this.y = prevY;
                }
                if(this.x !== prevX && this.y !== prevY && this.checkCollision(this.x, this.y, hitBoxWidth, hitBoxHeight)){
                    this.x = prevX;
                    this.y = prevY;
                }
            }
            checkBoundaryCollisionX() {
                 return (this.x - this.width / 2 < 0 || this.x + this.width / 2 > G_MAP_WIDTH);
            }
            checkBoundaryCollisionY() {
                 return (this.y - this.height / 2 < 0 || this.y + this.height / 2 > G_MAP_HEIGHT);
            }
            rotateBody(direction) {
                this.angle += direction * this.turnSpeed;
            }
            rotateTurret(direction) {
                this.turretAngle += direction * this.turretTurnSpeed;
            }
            setTurretAngle(targetAngle) {
                let current = (this.turretAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                let target = (targetAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                let diff = target - current;
                if (diff > Math.PI) diff -= 2 * Math.PI;
                if (diff < -Math.PI) diff += 2 * Math.PI;

                if (Math.abs(diff) < this.turretTurnSpeed * 1.1) {
                    this.turretAngle = targetAngle;
                } else {
                    this.turretAngle += Math.sign(diff) * this.turretTurnSpeed;
                }
            }
            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime > this.shootCooldownValue) {
                    const muzzleLength = TURRET_LENGTH * 0.15;
                    const bulletStartX = this.x + (TURRET_LENGTH + muzzleLength) * Math.cos(this.turretAngle);
                    const bulletStartY = this.y + (TURRET_LENGTH + muzzleLength) * Math.sin(this.turretAngle);
                    bullets.push(new Bullet(bulletStartX, bulletStartY, this.turretAngle, this, this.bulletDamage, this.bulletColor));
                    this.lastShotTime = currentTime;
                    playShootSound();
                    return true;
                }
                return false;
            }
            takeDamage(amount) {
                if (this.shielded) return;
                this.health -= amount;
                this.updateHealthBar();
                if (this.health <= 0) {
                    this.health = 0;
                    this.destroy();
                } else if (this.isAI && this.aiDifficulty === "FREESTYLE" && this.aiEvadeTimer <= 0) {
                    this.aiState = "EVADING";
                    this.aiEvadeTimer = 300 + Math.random() * 300;
                }
            }
            destroy() {
                this.updateHealthBar();
                const p1Wins = (this === player2);
                const p2Wins = (this === player1);

                if (p1Wins) {
                    let message = "Player 1 Wins!";
                    if (gameMode === 'vsCPU') {
                        let reward = 0;
                        switch(currentAiDifficulty) {
                            case 'EASY': reward = 5; break;
                            case 'NORMAL': reward = 10; break;
                            case 'HARD': reward = 20; break;
                            case 'FREESTYLE': reward = 30; break;
                        }
                        addMoney(reward);
                        message += ` You earned $${reward}!`;
                    }
                    updateGameStats(true);
                    endGame(message);
                } else if (p2Wins) {
                     updateGameStats(false);
                     endGame(gameMode === 'vsCPU' ? `${currentAiDifficulty} AI Wins!` : "Player 2 Wins!");
                }
            }
            checkCollision(checkX, checkY, colWidth = this.width, colHeight = this.height) {
                const tankRect = {
                    x: checkX - colWidth / 2,
                    y: checkY - colHeight / 2,
                    width: colWidth,
                    height: colHeight
                };
                for (const obs of obstacles) {
                    if (rectIntersect(tankRect, obs)) return true;
                }
                const otherTank = (this === player1 && player2) ? player2 : (this === player2 && player1) ? player1 : null;
                if(otherTank && otherTank.health > 0) {
                    const otherTankRect = {
                        x: otherTank.x - otherTank.width / 2,
                        y: otherTank.y - otherTank.height / 2,
                        width: otherTank.width,
                        height: otherTank.height
                    };
                    if (rectIntersect(tankRect, otherTankRect)) return true;
                }
                return false;
            }
            applyPowerUp(type) {
                const duration = POWERUP_DURATION_BASE * this.powerUpDurationMultiplier; // duration in ms
                if (type === 'shield') {
                    this.shielded = true;
                    this.shieldTimer = duration;
                    this.shieldIndicatorDiv.style.display = 'block';
                } else if (type === 'speed') {
                    this.speedBoostActive = true;
                    this.speedBoostTimer = duration;
                } else if (type === 'health') {
                    this.health = Math.min(this.maxHealth, this.health + (MAX_HEALTH_BASE * 0.4));
                    this.updateHealthBar();
                }
            }
            updatePowerUps(rawDeltaTime_ms) { // Expects raw ms
                if (this.shielded) {
                    this.shieldTimer -= rawDeltaTime_ms;
                    if (this.shieldTimer <= 0) {
                        this.shielded = false; this.shieldTimer = 0; this.shieldIndicatorDiv.style.display = 'none';
                    }
                }
                if (this.speedBoostActive) {
                    this.speedBoostTimer -= rawDeltaTime_ms;
                    if (this.speedBoostTimer <= 0) {
                        this.speedBoostActive = false; this.speedBoostTimer = 0;
                    }
                }
            }

            findClosestIncomingBullet(allBullets) {
                let closestBullet = null;
                let minDistance = Infinity;

                for (const bullet of allBullets) {
                    if (bullet.owner === this) continue;

                    const dist = Math.hypot(this.x - bullet.x, this.y - bullet.y);
                    if (dist < minDistance) {
                        const dx = this.x - bullet.x;
                        const dy = this.y - bullet.y;
                        const dotProduct = dx * Math.cos(bullet.angle) + dy * Math.sin(bullet.angle);
                        if (dotProduct > 0) {
                            minDistance = dist;
                            closestBullet = bullet;
                        }
                    }
                }
                return closestBullet;
            }


            setAIDifficultyParameters() {
                switch(this.aiDifficulty) {
                    case 'EASY':
                        this.aiAimInaccuracyFactor = 0.9; this.aiShootingAngleTolerance = 1.0;
                        this.aiHesitationFactor = 0.7; this.aiPostActionReactionTime = 600;
                        break;
                    case 'NORMAL':
                        this.aiAimInaccuracyFactor = 0.45; this.aiShootingAngleTolerance = 0.5;
                        this.aiHesitationFactor = 0.25; this.aiPostActionReactionTime = 300;
                        break;
                    case 'HARD':
                        this.aiAimInaccuracyFactor = 0.15; this.aiShootingAngleTolerance = 0.2;
                        this.aiHesitationFactor = 0.05; this.aiPostActionReactionTime = 150;
                        break;
                    case 'FREESTYLE':
                        this.aiAimInaccuracyFactor = 0.01;
                        this.aiShootingAngleTolerance = 0.05;
                        this.aiHesitationFactor = 0;
                        this.aiPostActionReactionTime = 30;
                        this.AI_STUCK_THRESHOLD = 800;
                        break;
                }
            }
            aiAttemptShoot(targetAngle, targetIsShielded) {
                if (this.aiGeneralReactionTimer > 0) return;
                if (targetIsShielded && Math.random() < (this.aiDifficulty === 'EASY' ? 0.9 : (this.aiDifficulty === 'NORMAL' ? 0.75 : 0.5)) ) return;

                let turretNormalized = normalizeAngle(this.turretAngle);
                let targetNormalized = normalizeAngle(targetAngle);
                let diff = targetNormalized - turretNormalized;
                if (diff > Math.PI) diff -= 2 * Math.PI; if (diff < -Math.PI) diff += 2 * Math.PI;

                if (Math.abs(diff) < this.aiShootingAngleTolerance) {
                    if (Math.random() > this.aiHesitationFactor) this.shoot();
                    this.aiGeneralReactionTimer = this.aiPostActionReactionTime + Math.random() * (this.aiDifficulty === 'EASY' ? 400 : (this.aiDifficulty === "FREESTYLE" ? 50 : 200) );
                }
            }
            updateAI(deltaTime, targetTank) { // deltaTime here is raw ms
                if (!this.isAI || !targetTank || targetTank.health <= 0 || this.health <= 0) return;
                this.setAIDifficultyParameters();

                this.aiTarget = targetTank; // Keep aiTarget updated
                this.aiMoveCooldown -= deltaTime;
                if (this.aiEvadeTimer > 0) this.aiEvadeTimer -= deltaTime;

                if (this.aiGeneralReactionTimer > 0) this.aiGeneralReactionTimer -= deltaTime;
                this.aiNextAimAdjustTimer -= deltaTime;

                const distMovedSqr = (this.x - this.aiLastPosition.x)**2 + (this.y - this.aiLastPosition.y)**2;
                if (distMovedSqr < this.AI_MIN_MOVE_DIST_FOR_STUCK_CHECK) {
                    this.aiStuckTimer += deltaTime;
                } else {
                    this.aiStuckTimer = 0;
                }
                this.aiLastPosition = { x: this.x, y: this.y };

                if (this.aiStuckTimer > this.AI_STUCK_THRESHOLD) {
                    this.angle = normalizeAngle(this.angle + (Math.random() - 0.5) * Math.PI * 1.5);
                    this.move(Math.random() < 0.6 ? -0.8 : 0.8);
                    this.aiState = 'IDLE';
                    this.aiStuckTimer = 0;
                    this.aiMoveCooldown = 200 + Math.random() * 200;
                    this.aiTargetLostTimer = 0;
                    return;
                }

                if (this.aiDifficulty === "FREESTYLE") {
                    this.aiCurrentAimOffset = 0;
                } else if (this.aiNextAimAdjustTimer <= 0) {
                    this.aiCurrentAimOffset = (Math.random() - 0.5) * 2 * this.aiAimInaccuracyFactor;
                    this.aiNextAimAdjustTimer = 600 + Math.random() * (this.aiDifficulty === 'EASY' ? 1000 : 700);
                }

                const trueAngleToTarget = Math.atan2(targetTank.y - this.y, targetTank.x - this.x);
                let effectiveAimAngle = trueAngleToTarget + this.aiCurrentAimOffset;

                if (this.aiDifficulty === "FREESTYLE" && targetTank.speed > 0.01) {
                    const distToTargetForPred = Math.hypot(targetTank.x - this.x, targetTank.y - this.y);
                    const timeToBulletHit = distToTargetForPred / BULLET_SPEED_BASE;
                    const targetCurrentSpeedValue = (keys['w'] || keys['W'] || keys['s'] || keys['S'] || keys['ArrowUp'] || keys['ArrowDown'] || (isTouch && (p1JoystickState.active || p2JoystickState.active))) ? targetTank.speed : 0; // Estimate player movement
                    const predictedTargetX = targetTank.x + Math.cos(targetTank.angle) * targetCurrentSpeedValue * timeToBulletHit * (targetTank.speedBoostActive ? 1.7 : 1);
                    const predictedTargetY = targetTank.y + Math.sin(targetTank.angle) * targetCurrentSpeedValue * timeToBulletHit * (targetTank.speedBoostActive ? 1.7 : 1);
                    effectiveAimAngle = Math.atan2(predictedTargetY - this.y, predictedTargetX - this.x) + this.aiCurrentAimOffset;
                }

                const distanceToTarget = Math.hypot(this.x - targetTank.x, this.y - targetTank.y);
                const canSee = this.canSeeTarget(targetTank); // Uses updated canSeeTarget
                let closestPowerUp = null; let minDistToPowerUp = Infinity;
                if (canSee) this.aiTargetLostTimer = 0; else this.aiTargetLostTimer += deltaTime;

                if (this.aiDifficulty === "FREESTYLE" && this.aiEvadeTimer <= 0 && this.aiGeneralReactionTimer <= 0) {
                    let incomingBullet = this.findClosestIncomingBullet(bullets);
                    if (incomingBullet) {
                        const B_DIST_THRESHOLD = this.width * 5;
                        const B_ANGLE_THRESHOLD = Math.PI / 3.5;
                        const distToBullet = Math.hypot(this.x - incomingBullet.x, this.y - incomingBullet.y);
                        if (distToBullet < B_DIST_THRESHOLD) {
                            const angleFromBulletToTank = Math.atan2(this.y - incomingBullet.y, this.x - incomingBullet.x);
                            let angleDiff = Math.abs(normalizeAngle(incomingBullet.angle - angleFromBulletToTank));
                            if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                            if (angleDiff < B_ANGLE_THRESHOLD) {
                                this.aiState = "EVADING"; this.aiEvadeTimer = 250 + Math.random() * 150;
                                this.currentDodgeAngle = normalizeAngle(incomingBullet.angle + (Math.random() < 0.5 ? Math.PI / 1.9 : -Math.PI / 1.9));
                                this.aiIsDodgingBullet = true; this.aiMoveCooldown = 50;
                            }
                        }
                    }
                }

                const seekPowerUpChance = this.aiDifficulty === 'EASY' ? 0.1 : (this.aiDifficulty === 'NORMAL' ? 0.3 : 0.7);
                if (this.health < this.maxHealth * (this.aiDifficulty === 'EASY' ? 0.9 : (this.aiDifficulty === "FREESTYLE" ? 0.8 : 0.7)) || (!this.shielded && Math.random() < seekPowerUpChance)) {
                    powerUps.forEach(p => { if (p.active) { const dist = Math.hypot(this.x - p.x, this.y - p.y); if (dist < minDistToPowerUp) { minDistToPowerUp = dist; closestPowerUp = p; } } });
                }

                if (this.aiState === "EVADING" && this.aiEvadeTimer > 0) { /* Stay in evading */ }
                else if (this.aiTargetLostTimer > this.AI_TARGET_LOST_PATROL_THRESHOLD && this.aiDifficulty !== 'EASY') { this.aiState = 'PATROLLING'; }
                else if (closestPowerUp && minDistToPowerUp < G_MAP_WIDTH / (this.aiDifficulty === 'EASY' ? 6 : (this.aiDifficulty === "FREESTYLE" ? 3 : 3.5)) && (this.health < this.maxHealth * (this.aiDifficulty === 'EASY' ? 0.8 : (this.aiDifficulty === "FREESTYLE" ? 0.7 : 0.6)) || (closestPowerUp.type === 'shield' && !this.shielded && Math.random() < (this.aiDifficulty === 'EASY' ? 0.2 : (this.aiDifficulty === "FREESTYLE" ? 0.8 : 0.6))))) { this.aiState = 'SEEKING_POWERUP'; }
                else if (canSee && distanceToTarget < this.width * (this.aiDifficulty === 'FREESTYLE' ? 8 : 6) ) { this.aiState = 'ATTACKING_CLOSE'; }
                else if (canSee && distanceToTarget < G_MAP_WIDTH / (this.aiDifficulty === 'FREESTYLE' ? 1.3 : 2)) { this.aiState = 'ATTACKING_RANGED'; }
                else if (distanceToTarget > G_MAP_WIDTH / 1.3 && this.aiDifficulty !== 'EASY') { this.aiState = 'SEEKING_PLAYER'; }
                else if (!canSee && this.aiMoveCooldown <=0 && this.aiDifficulty !== 'EASY' && this.aiState !== 'PATROLLING') { this.aiState = 'REPOSITIONING'; }
                else if (this.aiMoveCooldown <=0 && this.aiState !== 'PATROLLING' && this.aiState !== "EVADING") { this.aiState = 'IDLE'; }


                if (this.aiState === "EVADING" && this.aiEvadeTimer > 0) {
                    this.setTurretAngle(effectiveAimAngle);
                    if (this.aiMoveCooldown <= 0) {
                        let moveDir = 1;
                        if (this.aiIsDodgingBullet) {
                            this.angle = this.currentDodgeAngle; // Already normalized
                        } else {
                            this.angle = normalizeAngle(trueAngleToTarget + Math.PI + (Math.random() - 0.5) * Math.PI/2);
                        }

                        if (!this.isPathClear(this.angle, this.speed * 1.5, targetTank)) {
                           if (!this.isPathClear(this.angle, -this.speed * 1.5, targetTank)) {
                                this.aiSmartTurn(this.angle, targetTank);
                                if(this.isPathClear(this.angle, this.speed * 0.5, targetTank)) this.move(0.5);
                           } else {
                               moveDir = -1;
                               this.move(moveDir * 1.0);
                           }
                        } else {
                           this.move(moveDir * 1.3);
                        }
                        this.aiIsDodgingBullet = false;
                        this.aiMoveCooldown = 100 + Math.random() * 100;
                    }
                    if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                    return;
                }

                switch(this.aiState) {
                    case 'PATROLLING':
                        this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.2);
                        if (this.aiMoveCooldown <= 0) { this.aiSmartTurn(this.angle + (Math.random() -0.7) * Math.PI / 2.5, targetTank); this.move(0.6 + Math.random()*0.3); this.aiMoveCooldown = Math.random() * 1800 + 1000; }
                        if (canSee) { this.aiTargetLostTimer = 0; this.aiState = 'ATTACKING_RANGED'; }
                        break;
                    case 'SEEKING_POWERUP':
                        const angleToPowerUp = Math.atan2(closestPowerUp.y - this.y, closestPowerUp.x - this.x);
                        this.setTurretAngle(canSee ? effectiveAimAngle : angleToPowerUp);
                        if (!this.isPathClearToPoint(closestPowerUp.x, closestPowerUp.y, targetTank)) { this.aiSmartTurn(angleToPowerUp, targetTank); if(this.isPathClear(this.angle, this.speed * 0.8, targetTank)) this.move(0.5); }
                        else { this.angle = angleToPowerUp; this.move(1); }
                        if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                        break;
                    case 'ATTACKING_CLOSE':
                        this.setTurretAngle(effectiveAimAngle); this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                        if (this.aiMoveCooldown <= 0) {
                            let strafeAngle = normalizeAngle(trueAngleToTarget + (Math.random() < 0.5 ? Math.PI/2.2 : -Math.PI/2.2));
                            if (this.aiDifficulty === "FREESTYLE" && distanceToTarget < this.width * 2.8) { strafeAngle = normalizeAngle(trueAngleToTarget + Math.PI); } // Retreat if too close
                            if(this.isPathClear(strafeAngle, this.width*1.5, targetTank)){ this.angle = strafeAngle; this.move(0.7 + Math.random()*0.2); }
                            else { this.aiSmartTurn(strafeAngle, targetTank); if(this.isPathClear(this.angle, this.speed*0.8, targetTank)) this.move(0.5 + Math.random()*0.2); }
                            this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 1000 : (this.aiDifficulty === "FREESTYLE" ? 250 : 700)) + (this.aiDifficulty === 'EASY' ? 500 : (this.aiDifficulty === "FREESTYLE" ? 100 : 300));
                        }
                        break;
                    case 'ATTACKING_RANGED':
                        this.setTurretAngle(effectiveAimAngle); this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                        if (this.aiMoveCooldown <= 0) {
                            if (this.aiDifficulty === "FREESTYLE") {
                                if (Math.random() < 0.9) {
                                    let moveAngleOffset = (Math.random() - 0.5) * Math.PI / 1.8;
                                    if (Math.random() < 0.35) { moveAngleOffset = (distanceToTarget > G_MAP_WIDTH / 2.5) ? 0 : Math.PI; }
                                    const intendedMoveAngle = normalizeAngle(trueAngleToTarget + moveAngleOffset);
                                    if (this.isPathClear(intendedMoveAngle, this.speed * 2, targetTank)) {
                                       this.angle = intendedMoveAngle; this.move(0.6 + Math.random() * 0.3);
                                    } else {
                                       this.aiSmartTurn(trueAngleToTarget, targetTank);
                                       if (this.isPathClear(this.angle, this.speed, targetTank)) this.move(0.3);
                                    }
                                }
                            } else if (Math.random() < (this.aiDifficulty === 'EASY' ? 0.1 : 0.3)) { this.aiSmartTurn(trueAngleToTarget + (Math.random()-0.5) * Math.PI / 3, targetTank); if(this.isPathClear(this.angle, this.speed * 0.5, targetTank)) this.move(0.2 + Math.random()*0.2); }
                            this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 1200 : (this.aiDifficulty === "FREESTYLE" ? 300 : 900)) + (this.aiDifficulty === 'EASY' ? 700 : (this.aiDifficulty === "FREESTYLE" ? 150 : 500));
                        }
                        break;
                    case 'SEEKING_PLAYER':
                        this.setTurretAngle(effectiveAimAngle);
                        if (!this.isPathClearToPoint(targetTank.x, targetTank.y, targetTank, this.width*3)) { this.aiSmartTurn(trueAngleToTarget, targetTank); if(this.isPathClear(this.angle, this.speed * 0.8, targetTank)) this.move(0.6 + Math.random()*0.2); }
                        else { this.angle = trueAngleToTarget; this.move(0.9 + Math.random()*0.2); }
                        if (canSee) this.aiAttemptShoot(effectiveAimAngle, targetTank.shielded);
                        break;
                    case 'REPOSITIONING':
                        this.setTurretAngle(this.turretAngle + (Math.random() - 0.5) * 0.35 );
                        if (this.aiMoveCooldown <= 0) {
                            this.aiSmartTurn(this.angle + (Math.random() - 0.5) * Math.PI / 2.0, targetTank); if(this.isPathClear(this.angle, this.speed * 0.8, targetTank)) this.move(0.7 + Math.random()*0.3);
                            this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 900 : (this.aiDifficulty === "FREESTYLE" ? 250 : 500)) + (this.aiDifficulty === 'EASY' ? 400 : (this.aiDifficulty === "FREESTYLE" ? 80 : 200));
                        }
                        break;
                    case 'IDLE': default:
                        this.setTurretAngle(this.turretAngle + (Math.random()-0.5)*0.15);
                        if (this.aiMoveCooldown <= 0) {
                            if (Math.random() < (this.aiDifficulty === 'EASY' ? 0.3 : (this.aiDifficulty === "FREESTYLE" ? 0.75 : 0.55))) {
                                this.aiSmartTurn(this.angle + (Math.random() - 0.5) * Math.PI / (this.aiDifficulty === "FREESTYLE" ? 1.2 : 1.8), targetTank);
                                if(this.isPathClear(this.angle, this.speed * 0.6, targetTank)) this.move(0.4 + Math.random() * (this.aiDifficulty === "FREESTYLE" ? 0.5 : 0.2));
                            }
                            this.aiMoveCooldown = Math.random() * (this.aiDifficulty === 'EASY' ? 1800 : (this.aiDifficulty === "FREESTYLE" ? 400 : 1300)) + (this.aiDifficulty === 'EASY' ? 1000 : (this.aiDifficulty === "FREESTYLE" ? 200 : 700));
                        }
                        break;
                }

                if(this.aiMoveCooldown <= 0 && this.aiState !== 'EVADING') {
                    this.aiSmartTurn(this.angle + (Math.random() - 0.5) * 0.3, targetTank);
                    if (Math.random() < 0.2 && this.isPathClear(this.angle, this.speed * 0.5, targetTank)) this.move(0.3);
                    this.aiMoveCooldown = 200 + Math.random() * 200;
                }
            }

            aiSmartTurn(desiredAngle, targetTankToAvoid = null) {
                let bestTurn = 0;
                let maxClearDistance = 0;
                const anglesToTest = [0, Math.PI / 6, -Math.PI / 6, Math.PI / 3, -Math.PI / 3, Math.PI / 2, -Math.PI / 2];

                for (const offset of anglesToTest) {
                    const testAngle = normalizeAngle(desiredAngle + offset);
                    let currentPathClearDistance = 0;
                    for (let d = this.width * 0.5; d <= this.width * 4; d += this.width * 0.5) {
                        if (this.isPathClear(testAngle, d, targetTankToAvoid)) {
                            currentPathClearDistance = d;
                        } else {
                            break;
                        }
                    }
                    if (currentPathClearDistance > maxClearDistance) {
                        maxClearDistance = currentPathClearDistance;
                        bestTurn = testAngle;
                    }
                }

                if (maxClearDistance > this.width * 0.5) {
                    this.angle = bestTurn;
                } else {
                    this.angle = normalizeAngle(desiredAngle + (Math.random() < 0.5 ? Math.PI * 0.75 : -Math.PI * 0.75) + (Math.random() - 0.5) * 0.5);
                }
            }

            isPathClear(angle, distance, otherTankToAvoid = null) {
                const checkFeelerCount = 3;
                const feelerOffsetDist = this.width / 3.5;
                const cosAngle = Math.cos(angle);
                const sinAngle = Math.sin(angle);
                const cosPerp = Math.cos(angle + Math.PI / 2);
                const sinPerp = Math.sin(angle + Math.PI / 2);

                for (let i = 0; i < checkFeelerCount; i++) {
                    let offsetX = 0; let offsetY = 0;
                    if (i === 1) { offsetX = feelerOffsetDist * cosPerp; offsetY = feelerOffsetDist * sinPerp; }
                    else if (i === 2) { offsetX = -feelerOffsetDist * cosPerp; offsetY = -feelerOffsetDist * sinPerp; }

                    const projectedRectCenterX = this.x + offsetX + distance * cosAngle;
                    const projectedRectCenterY = this.y + offsetY + distance * sinAngle;
                    const projectedRect = {
                        x: projectedRectCenterX - this.width / 4, y: projectedRectCenterY - this.height / 4,
                        width: this.width / 2, height: this.height / 2
                    };

                    if (projectedRect.x < 0 || projectedRect.x + projectedRect.width > G_MAP_WIDTH ||
                        projectedRect.y < 0 || projectedRect.y + projectedRect.height > G_MAP_HEIGHT) {
                        return false;
                    }
                    for (const obs of obstacles) {
                        if (rectIntersect(projectedRect, obs)) return false;
                    }
                    if (otherTankToAvoid && otherTankToAvoid.health > 0 && otherTankToAvoid !== this) {
                        const otherTankHitbox = {
                            x: otherTankToAvoid.x - otherTankToAvoid.width / 2, y: otherTankToAvoid.y - otherTankToAvoid.height / 2,
                            width: otherTankToAvoid.width, height: otherTankToAvoid.height
                        };
                        if (rectIntersect(projectedRect, otherTankHitbox)) return false;
                    }
                }
                return true;
            }

            isPathClearToPoint(targetX, targetY, otherTankToAvoid = null, maxDist = G_MAP_WIDTH) {
                const dx = targetX - this.x; const dy = targetY - this.y;
                const distToTarget = Math.hypot(dx, dy);
                if (distToTarget === 0) return true;
                if (maxDist > 0 && distToTarget > maxDist) return false;
                const angleToTarget = Math.atan2(dy, dx);
                const checkDist = Math.max(0, distToTarget - (this.width / 2) - (otherTankToAvoid ? otherTankToAvoid.width / 2 : 0));
                return this.isPathClear(angleToTarget, checkDist, otherTankToAvoid);
            }

            canSeeTarget(target) {
                if (!target || target.health <= 0) return false;
                return this.isPathClearToPoint(target.x, target.y, target);
            }
        }
        class Bullet {
            constructor(x, y, angle, owner, damage = BASE_BULLET_DAMAGE, color = '#222222') {
                this.x = x; this.y = y; this.angle = angle;
                this.speed = BULLET_SPEED_BASE; this.size = BULLET_SIZE; this.owner = owner;
                this.damage = damage;
                this.color = color;
            }
            draw() {
                ctx.save();
                const ownerSkin = SKINS[this.owner.skinId] || SKINS['default'];
                let shouldGlow = false;
                let glowCol = this.color;

                if (ownerSkin.price >= 1000 || ['golden_goliath', 'phantom', 'sharpshooter'].includes(this.owner.skinId)) {
                    shouldGlow = true;
                    if (this.owner.skinId === 'golden_goliath') glowCol = 'rgba(255,180,50,0.9)';
                    else if (this.owner.skinId === 'phantom') glowCol = 'rgba(200,100,255,0.9)';
                    else if (this.owner.skinId === 'sharpshooter') glowCol = 'rgba(0,220,220,0.9)';
                    else if (this.color) glowCol = this.color.replace(')', ', 0.8)').replace('rgb', 'rgba');
                }

                if (shouldGlow) {
                    ctx.shadowColor = glowCol;
                    ctx.shadowBlur = 8 + Math.sin(Date.now() / 100) * 3;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();

                if (!shouldGlow) {
                    ctx.fillStyle = this.color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                    ctx.beginPath();
                    ctx.arc(this.x - Math.cos(this.angle) * this.speed * 0.2, this.y - Math.sin(this.angle) * this.speed * 0.2, this.size / 2.8, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
            update() {
                this.x += this.speed * Math.cos(this.angle); this.y += this.speed * Math.sin(this.angle);
            }
        }
        class Obstacle {
            constructor(x, y, width, height, color = '#7a5230') {
                this.x = x; this.y = y; this.width = width; this.height = height;
                this.color = color;
                this.darkerColor = getShadedColor(color, -20);
            }
            draw() {
                ctx.fillStyle = this.darkerColor;
                ctx.fillRect(this.x + 3, this.y + 3, this.width, this.height);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.radius = POWERUP_SIZE / 2;
                this.type = type; this.active = true; this.spawnTime = Date.now(); this.lifeTime = 18000; // 18 seconds
            }
            draw() {
                if (!this.active) return;
                ctx.save(); ctx.translate(this.x, this.y);
                const pulseFactor = 0.8 + Math.abs(Math.sin(Date.now() / 300)) * 0.4;
                const currentRadius = this.radius * pulseFactor;
                ctx.beginPath(); ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                let fillColor, strokeColor, letter;
                if (this.type === 'shield') { fillColor = 'rgba(0, 191, 255, 0.7)'; strokeColor = 'rgba(0, 121, 205, 1)'; letter = 'S'; }
                else if (this.type === 'speed') { fillColor = 'rgba(255, 215, 0, 0.7)'; strokeColor = 'rgba(205, 165, 0, 1)'; letter = 'F'; }
                else if (this.type === 'health') { fillColor = 'rgba(50, 205, 50, 0.7)'; strokeColor = 'rgba(0, 155, 0, 1)'; letter = 'H'; }
                ctx.fillStyle = fillColor; ctx.fill();
                ctx.strokeStyle = strokeColor; ctx.lineWidth = 2.5; ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.font = `bold ${this.radius*1.1}px Arial`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(letter, 0, 1);
                ctx.restore();
            }
            update() { // Note: deltaTime parameter was here but unused. Removed for clarity.
                 if (Date.now() - this.spawnTime > this.lifeTime && this.active) {
                     this.active = false;
                 }
            }
        }

        function switchScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            if (screenId && document.getElementById(screenId)) {
                document.getElementById(screenId).classList.add('active');
                 gameArea.style.display = 'none';
            } else {
                document.getElementById('menuScreen').classList.add('active');
                gameArea.style.display = 'none';
            }
            requestAnimationFrame(rescaleGame);
        }

        function initGame() {
            const selectedMapConfig = MAPS_CONFIG[currentMapId];
            G_MAP_WIDTH = selectedMapConfig.width;
            G_MAP_HEIGHT = selectedMapConfig.height;

            canvas.width = G_MAP_WIDTH;
            canvas.height = G_MAP_HEIGHT;
            gameContainer.style.width = G_MAP_WIDTH + 'px';
            gameContainer.style.height = G_MAP_HEIGHT + 'px';

            bullets.length = 0;
            powerUps.length = 0;
            lastPowerUpSpawnTime = Date.now();
            while (uiLayer.firstChild) uiLayer.removeChild(uiLayer.firstChild);

            const p1SkinId = playerData.selectedSkinId || 'default';
            const p1Spawn = selectedMapConfig.playerSpawns[0];
            player1 = new Tank('player1', typeof p1Spawn.x === 'function' ? p1Spawn.x() : p1Spawn.x, typeof p1Spawn.y === 'function' ? p1Spawn.y() : p1Spawn.y, false, p1SkinId);
            player1.angle = typeof p1Spawn.angle === 'function' ? p1Spawn.angle() : p1Spawn.angle;
            player1.turretAngle = player1.angle;


            const p2Spawn = selectedMapConfig.playerSpawns[1];
            if (gameMode === 'vsCPU') {
                player2 = new Tank('player2_ai', typeof p2Spawn.x === 'function' ? p2Spawn.x() : p2Spawn.x, typeof p2Spawn.y === 'function' ? p2Spawn.y() : p2Spawn.y, true, 'default', currentAiDifficulty);
            } else if (gameMode === 'twoPlayer') {
                player2 = new Tank('player2', typeof p2Spawn.x === 'function' ? p2Spawn.x() : p2Spawn.x, typeof p2Spawn.y === 'function' ? p2Spawn.y() : p2Spawn.y, false, 'default');
            }
            if (player2) {
                player2.angle = typeof p2Spawn.angle === 'function' ? p2Spawn.angle() : p2Spawn.angle;
                player2.turretAngle = player2.angle;
            }


            initObstacles();
            spawnInitialPowerUps(Math.floor( (G_MAP_WIDTH * G_MAP_HEIGHT) / (1200*800) * 3) );

            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            gameArea.style.display = 'block';
            gameRunning = true;
            setupMobileControls();

            rescaleGame();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = performance.now();
            gameLoop();
        }


        function initObstacles() {
            obstacles.length = 0;
            const mapObsConfig = MAPS_CONFIG[currentMapId].obstacles;
            mapObsConfig.forEach(obsData => {
                const x = typeof obsData.x === 'function' ? obsData.x() : obsData.x;
                const y = typeof obsData.y === 'function' ? obsData.y() : obsData.y;
                const w = typeof obsData.w === 'function' ? obsData.w() : obsData.w;
                const h = typeof obsData.h === 'function' ? obsData.h() : obsData.h;
                obstacles.push(new Obstacle(x, y, w, h, obsData.color || '#7a5230'));
            });
        }
        function spawnPowerUp() {
            if (powerUps.filter(p => p.active).length >= Math.floor( (G_MAP_WIDTH*G_MAP_HEIGHT) / (1200*800) * 4) +1 ) return;
            let validPosition = false; let x, y, attempts = 0;
            const types = ['shield', 'speed', 'health', 'health'];
            const type = types[Math.floor(Math.random() * types.length)];
            while (!validPosition && attempts < 50) {
                x = Math.random() * (G_MAP_WIDTH - POWERUP_SIZE * 3) + POWERUP_SIZE * 1.5;
                y = Math.random() * (G_MAP_HEIGHT - POWERUP_SIZE * 3) + POWERUP_SIZE * 1.5;
                validPosition = true;
                const powerUpRect = { x: x - POWERUP_SIZE, y: y - POWERUP_SIZE, width: POWERUP_SIZE*2, height: POWERUP_SIZE*2 };
                for (const obs of obstacles) if (rectIntersect(powerUpRect, obs)) { validPosition = false; break; }
                for (const pup of powerUps) if (pup.active && Math.hypot(x-pup.x, y-pup.y) < POWERUP_SIZE * 4) { validPosition = false; break; }
                if (player1 && Math.hypot(x - player1.x, y - player1.y) < player1.width * 3) { validPosition = false; }
                if (player2 && Math.hypot(x - player2.x, y - player2.y) < player2.width * 3) { validPosition = false; }
                attempts++;
            }
            if (validPosition) powerUps.push(new PowerUp(x, y, type));
        }
        function spawnInitialPowerUps(count) { for(let i = 0; i < count; i++) spawnPowerUp(); }

        let lastTime = 0;
        function update(currentTime) {
            if (!gameRunning) return;
            const deltaTime_ms = (currentTime - lastTime) || (1000/60); // Raw milliseconds
            lastTime = currentTime;

            const normalizedDeltaTime = deltaTime_ms / (1000/60); // Factor relative to 60FPS

            if (player1 && player1.health > 0) {
                player1.update(normalizedDeltaTime, deltaTime_ms); // Pass both
                if (isTouch && p1JoystickState.active) {
                    if (p1JoystickState.joyX !== 0 || p1JoystickState.joyY !== 0) {
                        const moveAngle = Math.atan2(p1JoystickState.joyY, p1JoystickState.joyX);
                        player1.angle = moveAngle; player1.turretAngle = moveAngle; player1.move(1);
                    }
                } else {
                    if (keys['w'] || keys['W']) player1.move(1); if (keys['s'] || keys['S']) player1.move(-1);
                    if (keys['a'] || keys['A']) player1.rotateBody(-1); if (keys['d'] || keys['D']) player1.rotateBody(1);
                    if (keys['q'] || keys['Q']) player1.rotateTurret(-1); if (keys['e'] || keys['E']) player1.rotateTurret(1);
                }
                if ((isTouch && fireP1Active) || keys[' ']) player1.shoot();
            }

            if (player2 && player2.health > 0) {
                player2.update(normalizedDeltaTime, deltaTime_ms); // Pass both
                if (gameMode === 'twoPlayer') {
                     if (isTouch && p2JoystickState.active) {
                        if (p2JoystickState.joyX !== 0 || p2JoystickState.joyY !== 0) {
                            const moveAngle = Math.atan2(p2JoystickState.joyY, p2JoystickState.joyX);
                            player2.angle = moveAngle; player2.turretAngle = moveAngle; player2.move(1);
                        }
                    } else {
                        if (keys['ArrowUp']) player2.move(1); if (keys['ArrowDown']) player2.move(-1);
                        if (keys['ArrowLeft']) player2.rotateBody(-1); if (keys['ArrowRight']) player2.rotateBody(1);
                        if (keys[','] || keys['<']) player2.rotateTurret(-1); if (keys['.'] || keys['>']) player2.rotateTurret(1);
                    }
                    if ((isTouch && fireP2Active) || keys['Enter']) player2.shoot();
                } else if (gameMode === 'vsCPU' && player1 && player1.health > 0) {
                    player2.updateAI(deltaTime_ms, player1); // AI uses raw ms for its internal timers
                }
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i]; bullet.update();
                if (bullet.x < -BULLET_SIZE || bullet.x > G_MAP_WIDTH + BULLET_SIZE || bullet.y < -BULLET_SIZE || bullet.y > G_MAP_HEIGHT + BULLET_SIZE) {
                    bullets.splice(i, 1); continue;
                }
                let hit = false;
                for (const obs of obstacles) if (pointInRect({x: bullet.x, y: bullet.y}, obs)) { bullets.splice(i, 1); hit = true; break; }
                if (hit) continue;

                const targets = [];
                if (player1 && player1.health > 0) targets.push(player1);
                if (player2 && player2.health > 0) targets.push(player2);

                for (const tank of targets) {
                    if (bullet.owner !== tank) {
                        const dist = Math.hypot(bullet.x - tank.x, bullet.y - tank.y);
                        if (dist < tank.width / 2 + bullet.size / 2) {
                            tank.takeDamage(bullet.damage);
                            bullets.splice(i, 1);
                            hit = true;
                            break;
                        }
                    }
                }
                if (hit) continue;
            }

            const activeTanks = [];
            if (player1 && player1.health > 0) activeTanks.push(player1); if (player2 && player2.health > 0) activeTanks.push(player2);
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                pu.update(); // PowerUp.update uses Date.now(), doesn't need deltaTime
                if (!pu.active) {
                    powerUps.splice(i, 1);
                    continue;
                }
                for (const tank of activeTanks) {
                    const dist = Math.hypot(tank.x - pu.x, tank.y - pu.y);
                    if (dist < tank.width / 2 + pu.radius) {
                        tank.applyPowerUp(pu.type);
                        pu.active = false; // Mark as collected
                        break; // Powerup collected, no need to check other tank for this powerup
                    }
                }
            }
            if (Date.now() - lastPowerUpSpawnTime > POWERUP_SPAWN_INTERVAL) { spawnPowerUp(); lastPowerUpSpawnTime = Date.now(); }
        }
        function draw() {
            ctx.fillStyle = MAPS_CONFIG[currentMapId].bgColor || '#bfa870';
            ctx.fillRect(0, 0, G_MAP_WIDTH, G_MAP_HEIGHT);
            obstacles.forEach(obs => obs.draw());
            powerUps.forEach(pu => pu.draw());
            if (player1 && player1.health > 0) player1.draw();
            if (player2 && player2.health > 0) player2.draw();
            bullets.forEach(bullet => bullet.draw());
        }
        function gameLoop(currentTime) {
            if (!gameRunning) return;
            animationFrameId = requestAnimationFrame(gameLoop);
            update(currentTime); draw();
        }
        function endGame(message) {
            gameRunning = false;
            messageText.textContent = message;
            switchScreen('messageScreen');
            hideAllMobileControls();
        }
        function rectIntersect(r1, r2) { return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y); }
        function pointInRect(point, rect) { return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height; }

        window.addEventListener('keydown', (e) => { keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key] = false; });

        let isTouch = false;
        let fireP1Active = false; let fireP1Identifier = null;
        let fireP2Active = false; let fireP2Identifier = null;

        function isTouchDevice() { return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)); }

        function setupMobileControls() {
            isTouch = isTouchDevice();
            hideAllMobileControls();

            if (isTouch && gameRunning) {
                if (gameMode === 'twoPlayer') {
                    joystickContainerP1.style.top = '20px'; joystickContainerP1.style.bottom = 'auto'; joystickContainerP1.style.left = '20px'; joystickContainerP1.style.right = 'auto'; joystickContainerP1.style.display = 'block';
                    fireButtonContainerP1.style.top = '30px'; fireButtonContainerP1.style.bottom = 'auto'; fireButtonContainerP1.style.right = '20px'; fireButtonContainerP1.style.left = 'auto'; fireButtonContainerP1.style.display = 'flex';
                    joystickContainerP2.style.top = 'auto'; joystickContainerP2.style.bottom = '20px'; joystickContainerP2.style.right = '20px'; joystickContainerP2.style.left = 'auto'; joystickContainerP2.style.display = 'block';
                    fireButtonContainerP2.style.top = 'auto'; fireButtonContainerP2.style.bottom = '30px'; fireButtonContainerP2.style.left = '20px'; fireButtonContainerP2.style.right = 'auto'; fireButtonContainerP2.style.display = 'flex';
                } else if (gameMode === 'vsCPU') {
                    joystickContainerP1.style.top = 'auto'; joystickContainerP1.style.bottom = '20px'; joystickContainerP1.style.left = '20px'; joystickContainerP1.style.right = 'auto'; joystickContainerP1.style.display = 'block';
                    fireButtonContainerP1.style.top = 'auto'; fireButtonContainerP1.style.bottom = '30px'; fireButtonContainerP1.style.right = '20px'; fireButtonContainerP1.style.left = 'auto'; fireButtonContainerP1.style.display = 'flex';
                    joystickContainerP2.style.display = 'none'; fireButtonContainerP2.style.display = 'none';
                }
                if (joystickContainerP1.style.display === 'block' && joystickContainerP1.offsetWidth > 0) {
                    p1JoystickState.radius = joystickContainerP1.offsetWidth / 2;
                    p1JoystickState.handleRadius = joystickHandleP1.offsetWidth / 2;
                }
                if (joystickContainerP2.style.display === 'block' && joystickContainerP2.offsetWidth > 0) {
                    p2JoystickState.radius = joystickContainerP2.offsetWidth / 2;
                    p2JoystickState.handleRadius = joystickHandleP2.offsetWidth / 2;
                }
            }
        }
        function hideAllMobileControls() {
            joystickContainerP1.style.display = 'none'; fireButtonContainerP1.style.display = 'none';
            joystickContainerP2.style.display = 'none'; fireButtonContainerP2.style.display = 'none';
        }

        const p1JoystickState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };
        const p2JoystickState = { active: false, identifier: null, radius: 0, handleRadius: 0, joyX: 0, joyY: 0 };

        function newJoystickInit(joystickCont, joystickHandle, stateObj) {
            if (!joystickCont || !joystickHandle) return;
            stateObj.radius = parseFloat(getComputedStyle(joystickCont).width) / 2 || 60;
            stateObj.handleRadius = parseFloat(getComputedStyle(joystickHandle).width) / 2 || 30;

            joystickHandle.style.left = '50%'; joystickHandle.style.top = '50%';
            joystickHandle.style.transform = 'translate(-50%, -50%)';
            joystickCont.addEventListener('touchstart', (e) => {
                e.preventDefault(); if (stateObj.active) return;
                if (joystickCont.offsetWidth > 0) {
                     stateObj.radius = joystickCont.offsetWidth / 2;
                     stateObj.handleRadius = joystickHandle.offsetWidth / 2;
                }
                const touch = e.changedTouches[0]; stateObj.active = true; stateObj.identifier = touch.identifier;
                newUpdateJoystickPosition(touch, joystickCont, joystickHandle, stateObj);
            }, { passive: false });
        }
        function newUpdateJoystickPosition(touch, joystickCont, joystickHandle, stateObj) {
             if (!joystickCont || !joystickHandle) return;
            const rect = joystickCont.getBoundingClientRect();
            let currentX = touch.clientX - rect.left; let currentY = touch.clientY - rect.top;
            let deltaX = currentX - stateObj.radius; let deltaY = currentY - stateObj.radius;
            const distance = Math.hypot(deltaX, deltaY);
            const maxDist = stateObj.radius - stateObj.handleRadius;
            if (maxDist <= 0) return; // Avoid division by zero or negative if radii are miscalculated
            if (distance > maxDist) { deltaX = (deltaX / distance) * maxDist; deltaY = (deltaY / distance) * maxDist; }
            joystickHandle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            stateObj.joyX = maxDist ? deltaX / maxDist : 0; stateObj.joyY = maxDist ? deltaY / maxDist : 0;
        }
        function newResetJoystick(joystickHandle, stateObj) {
            if (!joystickHandle) return;
            stateObj.active = false; stateObj.identifier = null;
            joystickHandle.style.transform = 'translate(-50%, -50%)';
            stateObj.joyX = 0; stateObj.joyY = 0;
        }

        window.addEventListener('touchmove', (e) => {
            if (!gameRunning) return; e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i];
                if (p1JoystickState.active && touch.identifier === p1JoystickState.identifier) newUpdateJoystickPosition(touch, joystickContainerP1, joystickHandleP1, p1JoystickState);
                if (p2JoystickState.active && touch.identifier === p2JoystickState.identifier) newUpdateJoystickPosition(touch, joystickContainerP2, joystickHandleP2, p2JoystickState);
            }
        }, { passive: false });
        window.addEventListener('touchend', (e) => {
            if (!gameRunning) return;
            for (let i = 0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i];
                if (p1JoystickState.active && touch.identifier === p1JoystickState.identifier) newResetJoystick(joystickHandleP1, p1JoystickState);
                if (p2JoystickState.active && touch.identifier === p2JoystickState.identifier) newResetJoystick(joystickHandleP2, p2JoystickState);
                if (fireP1Active && touch.identifier === fireP1Identifier) { fireP1Active = false; fireP1Identifier = null; fireButtonP1.classList.remove('glowing'); }
                if (fireP2Active && touch.identifier === fireP2Identifier) { fireP2Active = false; fireP2Identifier = null; fireButtonP2.classList.remove('glowing'); }
            }
        }, { passive: false });
        function setupFireButton(fireButtonElem, playerIndex) {
            if (!fireButtonElem) return;
            fireButtonElem.addEventListener('touchstart', (e) => { e.preventDefault(); fireButtonElem.classList.add('glowing'); const touch = e.changedTouches[0]; if (playerIndex === 1) { fireP1Active = true; fireP1Identifier = touch.identifier; } else if (playerIndex === 2) { fireP2Active = true; fireP2Identifier = touch.identifier; } }, { passive: false });
            fireButtonElem.addEventListener('touchend', (e) => { e.preventDefault(); fireButtonElem.classList.remove('glowing');}, { passive: false });
            fireButtonElem.addEventListener('touchcancel', (e) => { e.preventDefault(); fireButtonElem.classList.remove('glowing');}, { passive: false });
        }

        function populateShop() {
            shopItemsContainer.innerHTML = '';
            Object.keys(SKINS).forEach(skinId => {
                if (skinId === 'default') return;
                const skin = SKINS[skinId];
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shopItem';

                if (skin.price >= 500) {
                    itemDiv.classList.add('expensive-skin-glow');
                }

                const colorPreview = document.createElement('div');
                colorPreview.className = 'skin-color-preview';
                colorPreview.style.backgroundColor = skin.color;
                const nameH3 = document.createElement('h3');
                nameH3.textContent = skin.name;
                const bulletPreview = document.createElement('span');
                bulletPreview.className = 'bullet-color-preview';
                bulletPreview.style.backgroundColor = skin.bulletColor;
                nameH3.appendChild(bulletPreview);
                const descP = document.createElement('p');
                descP.textContent = skin.description;
                const priceP = document.createElement('p');
                priceP.className = 'price';
                priceP.textContent = `Price: $${skin.price}`;
                const buyButton = document.createElement('button');
                buyButton.className = 'buySkinButton baseButton';
                if (playerData.ownedSkins.includes(skinId)) { buyButton.textContent = 'Owned'; buyButton.disabled = true; }
                else if (playerData.money < skin.price) { buyButton.textContent = 'Too Expensive'; buyButton.disabled = true; }
                else { buyButton.textContent = 'Buy'; buyButton.onclick = () => buySkin(skinId); }
                itemDiv.appendChild(colorPreview); itemDiv.appendChild(nameH3); itemDiv.appendChild(descP); itemDiv.appendChild(priceP); itemDiv.appendChild(buyButton);
                shopItemsContainer.appendChild(itemDiv);
            });
        }
        function buySkin(skinId) {
            const skin = SKINS[skinId];
            if (skin && !playerData.ownedSkins.includes(skinId) && playerData.money >= skin.price) {
                playerData.money -= skin.price; playerData.ownedSkins.push(skinId);
                savePlayerData();
                populateShop();
                populateSkinSelector();
            }
        }
        function populateSkinSelector() {
            skinSelector.innerHTML = '';
            playerData.ownedSkins.forEach(skinId => { const skin = SKINS[skinId]; if (skin) { const option = document.createElement('option'); option.value = skinId; option.textContent = skin.name; if (skinId === playerData.selectedSkinId) option.selected = true; skinSelector.appendChild(option); } });
        }
        skinSelector.addEventListener('change', (e) => { playerData.selectedSkinId = e.target.value; savePlayerData(); });

        function populateMapSelector() {
            if (!mapSelectorMenu) return;
            mapSelectorMenu.innerHTML = '';
            Object.keys(MAPS_CONFIG).forEach(mapId => {
                const option = document.createElement('option');
                option.value = mapId;
                option.textContent = MAPS_CONFIG[mapId].name;
                if (mapId === currentMapId) option.selected = true;
                mapSelectorMenu.appendChild(option);
            });
        }
        if (mapSelectorMenu) {
            mapSelectorMenu.addEventListener('change', (e) => {
                currentMapId = e.target.value;
                savePlayerData();
            });
        }


        function populateProfileScreen() {
            if (!profileScreen.classList.contains('active')) return;
            usernameInput.value = playerData.username || "Player";
            profileMoney.textContent = `$${playerData.money || 0}`;
            profileGamesPlayed.textContent = playerData.gamesPlayed || 0;
            profileWins.textContent = playerData.wins || 0;
            profileLosses.textContent = playerData.losses || 0;
            ownedSkinsList.innerHTML = '';
            (playerData.ownedSkins || ['default']).forEach(skinId => {
                const skin = SKINS[skinId];
                if (skin) {
                    const li = document.createElement('li');

                    const skinColorDot = document.createElement('span');
                    skinColorDot.style.display = 'inline-block';
                    skinColorDot.style.width = '12px';
                    skinColorDot.style.height = '12px';
                    skinColorDot.style.borderRadius = '50%';
                    skinColorDot.style.backgroundColor = skin.color;
                    skinColorDot.style.marginRight = '10px';
                    skinColorDot.style.border = '1px solid rgba(255,255,255,0.4)';
                    li.appendChild(skinColorDot);

                    const skinNameSpan = document.createElement('span');
                    skinNameSpan.textContent = skin.name;
                    li.appendChild(skinNameSpan);

                    ownedSkinsList.appendChild(li);
                }
            });
        }
        usernameInput.addEventListener('change', (e) => {
            playerData.username = e.target.value.trim() || "Player";
            savePlayerData();
        });


        function rescaleGame() {
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;
            const scaleX = availableWidth / G_MAP_WIDTH;
            const scaleY = availableHeight / G_MAP_HEIGHT;
            G_SCALE = Math.min(scaleX, scaleY, 1);

            if (gameArea.style.display === 'block') {
                gameArea.style.transformOrigin = 'top left';
                gameArea.style.transform = `scale(${G_SCALE})`;

                const scaledWidth = G_MAP_WIDTH * G_SCALE;
                const scaledHeight = G_MAP_HEIGHT * G_SCALE;

                gameArea.style.width = G_MAP_WIDTH + 'px';
                gameArea.style.height = G_MAP_HEIGHT + 'px';

                gameArea.style.position = 'absolute';
                gameArea.style.left = `${Math.max(0, (availableWidth - scaledWidth) / 2)}px`;
                gameArea.style.top = `${Math.max(0, (availableHeight - scaledHeight) / 2)}px`;

                if (gameRunning) {
                    if (player1) player1.updateHealthBarPosition();
                    if (player2) player2.updateHealthBarPosition();
                }
            } else {
                gameArea.style.transform = `scale(1)`;
                gameArea.style.position = 'relative';
                gameArea.style.left = 'auto';
                gameArea.style.top = 'auto';
            }

            if (isTouch && gameRunning) {
                setupMobileControls();
            }
            fullscreenButton.textContent = document.fullscreenElement ? "‚ÜîÔ∏è Exit Fullscreen" : "‚ÜîÔ∏è Enter Fullscreen";
        }
        window.addEventListener('load', () => {
            loadPlayerData();
            switchScreen('menuScreen');
            isTouch = isTouchDevice();
            if(isTouch) {
                newJoystickInit(joystickContainerP1, joystickHandleP1, p1JoystickState);
                newJoystickInit(joystickContainerP2, joystickHandleP2, p2JoystickState);
                setupFireButton(fireButtonP1, 1);
                setupFireButton(fireButtonP2, 2);
            }
            hideAllMobileControls();

            const initialMapConf = MAPS_CONFIG[currentMapId];
            canvas.width = initialMapConf.width;
            canvas.height = initialMapConf.height;
            ctx.fillStyle = initialMapConf.bgColor ||'#2c2c2c';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center";
            ctx.fillText("Tank Battle by Lapis Yamz", canvas.width/2, canvas.height/2 - 20);
            ctx.font = "20px Arial"; ctx.fillText("Loading...", canvas.width/2, canvas.height/2 + 20);
        });

        window.addEventListener('resize', rescaleGame);
        document.addEventListener('fullscreenchange', rescaleGame);

        function toggleFullScreen() {
            if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`); }); }
            else { if (document.exitFullscreen) document.exitFullscreen(); }
        }
        fullscreenButton.addEventListener('click', toggleFullScreen);

        vsCPUButton.addEventListener('click', () => { gameMode = 'vsCPU'; switchScreen('difficultyScreen'); });
        twoPlayerButton.addEventListener('click', () => { gameMode = 'twoPlayer'; initGame(); });

        shopButtonMenu.addEventListener('click', () => {
            populateShop();
            switchScreen('shopScreen');
        });
        profileButtonMenu.addEventListener('click', () => {
            populateProfileScreen();
            switchScreen('profileScreen');
        });
        leaderboardButtonMenu.addEventListener('click', () => {
            populateLeaderboardScreen();
            switchScreen('leaderboardScreen');
        });


        document.querySelectorAll('.difficultyButton').forEach(button => {
            button.addEventListener('click', (e) => { currentAiDifficulty = e.target.dataset.difficulty; initGame(); });
        });

        backToMenuFromDifficulty.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromShop.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromProfile.addEventListener('click', () => switchScreen('menuScreen'));
        backToMenuFromLeaderboard.addEventListener('click', () => switchScreen('menuScreen'));


        playAgainButton.addEventListener('click', () => { initGame(); });
        backToMenuButton.addEventListener('click', () => {
            switchScreen('menuScreen');
            gameRunning = false;
            hideAllMobileControls();
        });

    </script>
</body>
</html>
